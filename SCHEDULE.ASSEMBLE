*   *****   *****  *** *** ******* ******   ***  *** ***      *******   00010000
*  ******* ******* *** *** ******* *******  ***  *** ***      *******   00020000
*  *** *** *** *** *** *** *** *** ***  *** ***  *** ***      *** ***   00030000
*  ***     ***     *** *** ***     ***  *** ***  *** ***      ***       00040000
*  ******  ***     ******* ******  ***  *** ***  *** ***      ******    00050000
*   ****** ***     ******* ******  ***  *** ***  *** ***      ******    00060000
*      *** ***     *** *** ***     ***  *** ***  *** ***      ***       00070000
*  *** *** *** *** *** *** *** *** ***  *** ***  *** ***  *** *** ***   00080000
*  ******* ******* *** *** ******* *******  ******** ******** *******   00090000
*   *****   *****  *** *** ******* ******    ******  ******** *******   00100000
         SPACE ,                                                        00110000
*.                                                                      00120000
* Module:     SCHEDULE                                                  00130000
*                                                                       00140000
* Purpose:    To provide facility for scheduling and executing various  00150000
*             CP and CMS commands,  as well as for writing messages to  00160000
*             the console at the time(s) predetermined by the user.     00170000
*                                                                       00180000
* Implementation:                                                       00190000
*                                                                       00200000
*             This program executes as a nucleus extension and is dri-  00210000
*             ven by the Clock Comparator external interrupt X'1004'.   00220000
*                                                                       00230000
*                                                                       00240000
*                                                                       00250000
* Author:     Simon Kharnas                                             00260000
*                                                                       00270000
* Date:       11/05/93                                                  00280000
*                                                                       00290000
* Attributes: Self-relocating nucleus extension.                        00300000
*                                                                       00310000
*             Designed to work under 370, XA or ESA architecture,       00320000
*             below or above the 16Mb line.                             00330000
*                                                                       00340000
*                                                                       00350000
* Generation: VMFHASM SCHEDULE ctlfname                                 00360000
*             LOAD    SCHEDULE (CLEAR AMODE 31 RMODE ANY RLDSAVE        00370000
*             GENMOD  SCHEDULE (SYSTEM                                  00380000
*                                                                       00390000
*     where - 'ctlfname' is the filename of the control file for updat- 00400000
*             ing the base source code                                  00410000
*                                                                       00420000
*                                                                       00430000
*                                                                       00440000
* Syntax:                                                               00450000
*                                                                       00460000
* >>--SCHEDULE--->                                                      00470000
*                                                                       00480000
* >-.--DELETE-.---------------.------------.--------<<                  00490000
*   '--DEL----'               '--event_id--'                            00500000
*   '                         '--ALL-------'                            00510000
*   '                                      '                            00520000
*   '--QUERY--.-.------------.--.--------.-'                            00530000
*   '--Q------' '--event_id--'  '--QUEUE-' '                            00540000
*   '           '--ALL-------'             '                            00550000
*   '           '--VERSION---'             '                            00560000
*   '           '--mm/dd/yy--'             '                            00570000
*   '           '                          '                            00580000
*   '           '--STATUS------------------'                            00590000
*   '                                      '                            00600000
*   '--ON-------.---------.---.---------.--'                            00610000
*   '           '--NOFILE-'   '--QUIET--'  '                            00620000
*   '--OFF----------------'                '                            00630000
*   '--SUSPEND------------'                '                            00640000
*   '--RESUME-------------'                '                            00650000
*   '                                      '                            00660000
*   '--HELP--------------------------------'                            00670000
*   '-- ? ---------------------------------'                            00680000
*                                                                       00690000
*                                                                       00700000
* >--ADD--.-----------------.-.-.-.-.hh:mm:ss.--.-.--.----------->> (a) 00710000
*         '---- mm/dd/yy ---' ' ' ' '        'AM' '  '                  00720000
*         '---- +nnn -------' '>' '+'        'PM' '  '-- UNTIL -->> (b) 00730000
*         '---- ==/dd ------'   '                 '                     00740000
*         '---- DAIly ------'   '                 '                     00750000
*         '---- ALL --------'   '- MIDnight ------'                     00760000
*         '---- * ----------'   '- NOON ----------'                     00770000
*         '---- TODay ------'                                           00780000
*         '---- TOMorrow ---'                                           00790000
*         '---- MON-FRI ----'                                           00800000
*         '---- M-F --------'                                           00810000
*         '---- WEEKDay ----'                                           00820000
*         '---- SAT-SUN ----'                                           00830000
*         '---- S-S --------'                                           00840000
*         '---- WEEKEnd ----'                                           00850000
*         '---- WEEKLy -----'                                           00860000
*         '---- MONTHly ----'                                           00870000
*         '---- =// --------'                                           00880000
*         '---- YEARly -----'                                           00890000
*         '---- =/=/= ------'                                           00900000
*         '-.MOnday---------'                                           00910000
*         ' 'TUesday--------'                                           00920000
*         ' 'WEdnesday------'                                           00930000
*         ' 'THursday-------'                                           00940000
*         ' 'FRiday---------'                                           00950000
*         ' 'SAturday-------'                                           00960000
*         ' 'SUnday---------'                                           00970000
*         ' '                                                           00980000
*         '+'                                                           00990000
*                                                                       01000000
*                                                                       01010000
* (a) >>-------------------------------.--.-- MSG --.-- msg_text --<<   01020000
*                                      '  '-- CMS --'                   01030000
* (b) >>-- mm/dd/yy ---.---------------'  '-- CP ---'                   01040000
*                      '               '                                01050000
*                      '--hh:mm:ss.--.-'                                01060000
*                                 'AM'                                  01070000
*                                 'PM'                                  01080000
*                                                                       01090000
*                                                                       01100000
*    where - "mm/dd/yy"  represents Month/Day/Year (each 2 digits) on   01110000
*                        which an event is to be executed or termina-   01120000
*                        ted. "mm/dd" can be used instead and defaults  01130000
*                        to the current year.                           01140000
*                                                                       01150000
*            "hh:mm:ss"  represents Hours:Minutes:Seconds (each 2 di-   01160000
*                        gits) - time at which an event is to be exe-   01170000
*                        cuted or terminated                            01180000
*                                                                       01190000
*            "+hh:mm:ss" represents Hours:Minutes:Seconds (each 2 di-   01200000
*                        gits) intervals for executing an event.        01210000
*                                                                       01220000
*            ">"         if found preceeding any time value,  tells the 01230000
*                        SCHEDULE  routine  that the  event  has  to be 01240000
*                        executed  immediately,  even if the next sche- 01250000
*                        duled date/time is a month or a year away from 01260000
*                        today. If a time interval is specified follow- 01270000
*                        ing this character  (the "+" sign),  the event 01280000
*                        will continue executing  until  midnight  that 01290000
*                        day.  Once  the  midnight boundary is crossed, 01300000
*                        the event will be scheduled to  pop  according 01310000
*                        to the date and time selected via user-suppli- 01320000
*                        ed dates and/or keywords.                      01330000
*                                                                       01340000
*            "+nnn"      represents intervals in days for executing     01350000
*                        an event. Maximum value for "nnn" is 16383,    01360000
*                        which is over 44 years.                        01370000
*                                                                       01380000
*            "msg_text"  text of a CP/CMS command to be issued or a     01390000
*                        message to be written to a user's console.     01400000
*                                                                       01410000
*    __________________________________________________________________ 01420000
*                                                                       01430000
*    SCHEDULE ON   turns the schedule facility on. If SCHEDULE TIMES A1 01440000
*                  file exists, it reads the file and establishes clock 01450000
*                  comparator interrupts, based on that information. No 01460000
*                  file reading occurs if the option "NOFILE" is given. 01470000
*                  "QUIET" option can be used to tell  SCHEDULE  not to 01480000
*                  write out the confirmation message to the terminal.  01490000
*                                                                       01500000
*    SCHEDULE OFF  turns the schedule facility off. "QUIET" option can  01510000
*                  be used to tell SCHEDULE not to write out the  con - 01520000
*                  firmation message to the terminal.                   01530000
*                                                                       01540000
*                                                                       01550000
*    SCHEDULE ADD  Adds an event to the list of events to be scheduled. 01560000
*                  It should be followed by date and time. Special key- 01570000
*                  words are self-explanatory and can be  used instead  01580000
*                  of date. A "+" sign in front of a keyword should be  01590000
*                  interpreted as "this event is to be repeated every". 01600000
*                  The  "date"  operand may be omitted alltogether, in  01610000
*                  which case the date defaults to today's date. "+nnn" 01620000
*                  operand  can  be used if an event is to be repeated  01630000
*                  every  "nnn"  days, where "nnn" can range from 1 to  01640000
*                  16383 days.  "+1" operand, if used in such fashion,  01650000
*                  will produce different results from "DAILY", "ALL",  01660000
*                  or "*", if a time interval is specified as the next  01670000
*                  operand. While in "DAILY" processing the timer in -  01680000
*                  terrupts will be scheduled accross  midnight,  "+1"  01690000
*                  will force the timer interval to be scheduled  anew  01700000
*                  after midnight. In the "mm/dd/yy" format of a  date  01710000
*                  "/YY" (year) can be omitted and will default to the  01720000
*                  current year. Operand in the format of "==/dd" will  01730000
*                  cause an event to be repeated monthly  on  the  day  01740000
*                  "dd". If "dd" exceeds the number of days in the gi-  01750000
*                  ven month, the last day of the month will be used.   01760000
*                                                                       01770000
*                  The  "time"  operand can be either an interval or a  01780000
*                  specific time at which an interrupt is to occur. If  01790000
*                  a "+" sign preceedes the "time", it should be inter- 01800000
*                  preted as  "this event is to be repeated every ..."  01810000
*                  such interval.  A  ">"  sign in front of the "time"  01820000
*                  operand will cause the event to be executed immedia- 01830000
*                  tely, before the next interrupt time is scheduled.   01840000
*                                                                       01850000
*                  If an event is repeatable, e.g. if it has any of the 01860000
*                  operands in "date" such as "WEEKEND", "M-F", "ALL",  01870000
*                  and etc., the event is considered to be non-expir -  01880000
*                  ing. To limit such event, so that it would expire on 01890000
*                  certain date and/or time, use the  "UNTIL"  option,  01900000
*                  followed by the date and time on when the event is   01910000
*                  to terminate.                                        01920000
*                                                                       01930000
*                  "MSG", "CMS", "CP" are the keywords determining the  01940000
*                  type of the event to be scheduled. If "MSG" keyword  01950000
*                  is specified,  a line of data following the keyword  01960000
*                  will be written to the terminal at the corresponding 01970000
*                  timer pop. If "CMS" or "CP" is specified, a CMS or a 01980000
*                  CP command following the keyword will be executed at 01990000
*                  the predetermined timer pop. CP  and  CMS  commands  02000000
*                  must be in upper case, except where they are a part  02010000
*                  of some text or operands to an exec or module.       02020000
*                                                                       02030000
*    SCHEDULE   Q  Displays the events scheduled on the user's console, 02040000
*      --   QUERY  or queues them on the console stack, if requested.   02050000
*                  The event to be executed next will be always marked  02060000
*                  by a ">" sign. Every event will be given an event_id 02070000
*                  number corresponding to its position in the SCHEDULE 02080000
*                  TIMES A1 file. Unlike SCHEDULE TIMES file, the QUERY 02090000
*                  command  displays  the date and the time of the NEXT 02100000
*                  scheduled timer pop,  while the former maintains the 02110000
*                  date and the time of the LAST timer pop for all re - 02120000
*                  petitive events. "mm/dd/yy" date parameter  supplied 02130000
*                  on the QUERY command will display or stack a date in 02140000
*                  the format of "MM/DD/YYYY  Day_of_week".             02150000
*                                                                       02160000
*    SCHEDULE DEL  Deletes a particular event (or all of the events, if 02170000
*      --  DELETE  "ALL" option was specified). Comments out the cor -  02180000
*                  responding entry in SCHEDULE TIMES A1 file, provided 02190000
*                  the user didn't start the SCHEDULE facility with the 02200000
*                  "NOFILE" option.                                     02210000
*                                                                       02220000
*                                                                       02230000
*    SCHEDULE SUSPEND  Quiesces the execution of scheduled events.      02240000
*                                                                       02250000
*    SCHEDULE RESUME   Restarts the execution of scheduled events which 02260000
*                      were quiesced.                                   02270000
*                                                                       02280000
*    SCHEDULE HELP     Displays help information in SCHEDULE HELPCMS.   02290000
*      --     ?                                                         02300000
*                                                                       02310000
*    __________________________________________________________________ 02320000
*                                                                       02330000
*                                                                       02340000
*    The keywords synonymous with    DAILY: "*", "ALL"                  02350000
*                                   WEEKLY: "+MONDAY"                   02360000
*                                  WEEKDAY: "M-F", "MON-FRI"            02370000
*                                  WEEKEND: "S-S", "SAT-SUN"            02380000
*                                  MONTHLY: "=//"                       02390000
*                                   YEARLY: "=/=/="                     02400000
*                                                                       02410000
*                                                                       02420000
*    Note:  events "+MONDAY", "+TUESDAY", "+WEDNESDAY", "+THURSDAY",    02430000
*           "+FRIDAY", "+SATURDAY", and "+SUNDAY" together with the     02440000
*           the keywords mentioned above will never terminate, unless   02450000
*           the "UNTIL" option is used.                                 02460000
*                                                                       02470000
*                                                                       02480000
*                                                                       02490000
*    __________________________________________________________________ 02500000
*                                                                       02510000
*    Unless "NOFILE" option is used during initialization of this pro - 02520000
*    gram, SCHEDULE TIMES A1 will be created/updated with the following 02530000
*    information:                                                       02540000
*                                                                       02550000
* Comment indicator byte in Col 1                                       02560000
* |                                                                     02570000
* |C          C            C        C        C        C        C   C    02580000
* |o          o            o        o        o        o        o   o    02590000
* |l          l            l        l        l        l        l   l    02600000
* |s          s            s        s        s        s        s   s    02610000
* |                                                                     02620000
* |2-11       13-24        26-33    35-42    44-51    53-60    62  66+  02630000
* ||          |            |        |        |        |        63  |    02640000
* ||          |            |        |        |        |        64  |    02650000
* ||          |            |        |        |        |        |   |    02660000
* VV          V            V        V        V        V        V   V    02670000
* *SchedDate  SchedTime    LastDate LastTime TillDate TillTime Cmd Text 02680000
*                                                                       02690000
*                                                                       02700000
*   This file can be used to set up the scheduled events ahead of time, 02710000
*   instead of issuing "SCHEDULE ADD" separately for each event. Start- 02720000
*   ing and ending columns should be observed for every item specified, 02730000
*   just as displayed above. SCHEDULE TIMES A1 should never be  changed 02740000
*   while the SCHEDULE routine is active. "SCHEDULE OFF" must be in ef- 02750000
*   fect if you want to alter it.                                       02760000
*                                                                       02770000
*.                                                                      02780000
SCHEDULE TITLE 'CMS Timing facility based on Clock Comparator usage.'   02790000
*                                                                       02800000
*                                                                       02810000
SCHEDULE CSECT ,                                                        02820000
         USING NUCON,R0                * Map the nucleus constant area  02830000
         USING *,R12,R11,R10,R7,R14    * Using R12,R11,R10,R7,R14 bases 02840000
         STM   R0,R14,0(R13)           * Save all general purpose regs  02850000
         LR    R12,R15                 * Set up a new base              02860000
         B     AROUND                  * Branch around the copyright    02870000
VERSION  DC    AL1(VERSIONL)                                            02880000
         DC    C'*SCHEDULE Version 1.0; (c) Copyright by Simon Kharnas,*02890000
                1993, 1994. Generated on '                              02900000
         DC    C'&SYSDATE',C' at ',C'&SYSTIME',C'.'                     02910000
VERSIONL EQU   *-VERSION-1                                              02920000
AROUND   DS    0H                                                       02930000
         LA    R11,2048(,R12)          * Set up the second base reg.    02940000
         LA    R11,2048(,R11)          * Set up the second base reg.    02950000
         LA    R10,2048(,R11)          * Set up the third  base reg.    02960000
         LA    R10,2048(,R10)          * Set up the third  base reg.    02970000
         LA    R7,2048(,R10)           * Set up the fourth base reg.    02980000
         LA    R7,2048(,R7)            * Set up the fourth base reg.    02990000
         LA    R14,2048(,R7)           * Set up the fifth  base reg.    03000000
         LA    R14,2048(,R14)          * Set up the fifth  base reg.    03010000
         LA    R0,WRKARLEN             * Obtain the length of work area 03020000
         CMSSTOR OBTAIN,DWORDS=(R0),SUBPOOL='NUCLEUS',TYPCALL=BRANCH,  *03030000
               ERROR=ERR109SW,MSG=NO,LOC=SAME * Get the storage for it  03040000
         LR    R15,R13                 * Save R13 temporarily in R15    03050000
         LR    R13,R1                  * We have a new temp save area   03060000
         USING WRKAREA,R13             * Map it with our WRKAREA sect   03070000
         ST    R15,OLDR13              * Save prev. save area pointer   03080000
         LA    R14,4(,R1)              * Point R14 to the free storage  03090000
         LR    R15,R0                  * R15 is the length of the area  03100000
         SLL   R15,3                   * Convert the length to bytes    03110000
         S     R15,FWD4                * Subtract 4 to adjust length    03120000
         LA    R3,0                    * Force the target length to 0   03130000
         MVCL  R14,R2                  * Clear the FREE storag to zeros 03140000
         SPACE ,                                                        03150000
*********************************************************************** 03160000
***                                                                 *** 03170000
***  Verify whether we are running as a Nucleus Extension           *** 03180000
***                                                                 *** 03190000
*********************************************************************** 03200000
         USING SCBLOCK,R2              * Map Subcom Control Block       03210000
NUCXCHEK EQU   *                                                        03220000
         ICM   R2,B'1111',NUCXCBLK     * Get SCBLOCK anchor pointer     03230000
         BZ    NUCXLOAD                * Empty chain, do the NUCEXT     03240000
NUCXSCAN EQU   *                                                        03250000
         CLC   NUCXNAME,SCBNAME        * Have we been NUCXLOADed be4 ?  03260000
         BNE   NUCXMORE                * No, check next NUCXNAME entry  03270000
         OI    SCBSFLAG,SCBSFSYS+SCBSFSER * Mark SYSTEM & SERVICE attr  03280000
         SPACE ,                                                        03290000
         B     INITLIZE                * Do the required initialization 03300000
NUCXMORE EQU   *                                                        03310000
         ICM   R2,B'1111',SCBFWPTR     * Have we found another pointer? 03320000
         BNZ   NUCXSCAN                * Yes, scan though more SCBLOCKs 03330000
NUCXLOAD EQU   *                                                        03340000
         LA    R14,2048(,R7)           * Get back the temp base in R14  03350000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 03360000
         LA    R0,MODSIZE              * Load this module's size dwords 03370000
         SPACE ,                                                        03380000
         CMSSTOR OBTAIN,DWORDS=(R0),SUBPOOL='NUCLEUS',TYPCALL=BRANCH,  *03390000
               ERROR=NONUCSTO,MSG=NO,LOC=ANY                            03400000
         SPACE ,                                                        03410000
         LR    R14,R1                  * Load free storage address      03420000
         LR    R5,R1                   * Make a copy of it in R5        03430000
         ST    R14,NUCXADDR            * Save the starting address      03440000
         ST    R14,NUCXORG             * Save entry point address       03450000
         LH    R15,=AL2(MODLEN)        * Load module's length           03460000
         ST    R15,NUCXLEN             * And save it in NUCXLEN         03470000
         LA    R0,0(,R12)              * Load origin address            03480000
         LR    R1,R15                  * Make a copy of target mod len  03490000
         MVCL  R14,R0                  * Copy module to FREE storage    03500000
         SPACE ,                                                        03510000
         L     R2,NUCXORG              * Get the Nucleus Ext origin     03520000
         L     R3,NUCXADDR             * Get the Nucleus Ext start addr 03530000
         L     R4,NUCXLEN              * Get the Nucleus Ext length     03540000
         NUCEXT SET,NAME='SCHEDULE',ENTRY=(R2),AMODE=31,INTTYPE=ALL,   *03550000
               ORIGIN=((R3),(R4)),KEY=NUCLEUS,SYSTEM=YES,SERVICE=YES,  *03560000
               ERROR=NUCXFAIL                                           03570000
         SPACE ,                                                        03580000
*********************************************************************** 03590000
***                                                                 *** 03600000
***  Control will be passed to the nucleus extension which was co-  *** 03610000
***  pied in the above instructions.                                *** 03620000
***                                                                 *** 03630000
*********************************************************************** 03640000
         SPACE ,                                                        03650000
         LA    R11,2048(R5)            * Set up the second base regis-  03660000
         LA    R11,2048(R11)           * ter for the nucleus extension  03670000
         LA    R10,2048(R11)           * and the third register ...     03680000
         LA    R10,2048(R10)           * ... for the nucleus extension  03690000
         LA    R7,2048(R10)            * and the fourth register ...    03700000
         LA    R7,2048(R7)             * ... for the nucleus extension  03710000
         LA    R14,2048(,R7)           * Get back the temp base in R14  03720000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 03730000
         LA    R6,NUCTRANS             * Point to the next instructon.. 03740000
         SLL   R6,20                   * to execute and extract the ... 03750000
         SRL   R6,20                   * offset to it                   03760000
         LA    R12,0(,R5)              * Set up the first base register 03770000
         B     0(R6,R12)               * Branch into the nucleus area   03780000
         SPACE ,                                                        03790000
NUCTRANS EQU   *                                                        03800000
         ICM   R2,B'1111',NUCXCBLK     * Get our SCBLOCK pointer        03810000
         SPACE ,                                                        03820000
INITLIZE EQU   *                                                        03830000
         ST    R2,SCBLOKSV             * SCBLOCK ptr for future refernc 03840000
         SPACE ,                                                        03850000
         XC    RETCODE,RETCODE         * Zero out our return code       03860000
         L     R2,OLDR13               * Get the old savearea pointer   03870000
         L     R1,4(,R2)               * Get the tokenized plist ptr    03880000
         L     R0,0(,R2)               * Get the extended plist ptr     03890000
         CLI   USECTYP-USERSAVE(R2),EPLSERVC * Was it CMS Service Call? 03900000
         BNE   PROCEED                 * No, a regular invocation       03910000
         SPACE ,                                                        03920000
         DROP  R2                      * Drop the SCBLOCK mapping       03930000
         USING TOKENS,R1               * Map the tokenized parm list    03940000
         CLC   =C'RESET ',TOKEN1       * Is this a RESET request?       03950000
         BE    RESET                   * Yes, go perform cleanup        03960000
         CLC   =C'PURGE ',TOKEN1       * Is this a PURGE request?       03970000
         BE    PURGE                   * Yes, just return to caller     03980000
         SPACE ,                                                        03990000
         B     INVALID                 * Else, invalid call             04000000
         SPACE ,                                                        04010000
RESET    EQU   *                                                        04020000
         L     R2,EXTHNDLR             * Check if we created a handler  04030000
         LTR   R2,R2                   * Did we create an extern SLIH?  04040000
         BZ    NOHANDLR                * No, continue RESET processing  04050000
         SPACE ,                                                        04060000
*********************************************************************** 04070000
***                                                                 *** 04080000
***  Clear our second level timer interrupt handler and remove all  *** 04090000
***  EVENT blocks.                                                  *** 04100000
***                                                                 *** 04110000
*********************************************************************** 04120000
         ENABLE INTTYPE=NONE,MF=(E,NUCENAWA) * Disable all interrupts   04130000
REMVEVNT EQU   *                                                        04140000
         L     R8,ANCEVENT             * Get the last EVENT block ptr   04150000
         LTR   R8,R8                   * Is there one ?                 04160000
         BZ    REMVEVN2                * No, then we are done           04170000
         SPACE ,                                                        04180000
         XR    R0,R0                   * Don't change this line in file 04190000
         BAS   R9,DELEVENT             * Go, delete this EVENT block    04200000
         SPACE ,                                                        04210000
         B     REMVEVNT                * See if more EVENTs exits       04220000
         SPACE ,                                                        04230000
REMVEVN2 EQU   *                                                        04240000
         STCTL C0,C0,CONTROL0          * Save the CR0 contents          04250000
         NI    CONTROL0+2,255-X'08'    * Turn off the Clock comp mask   04260000
         LCTL  C0,C0,CONTROL0          * Get the altered CR 0           04270000
         TM    PROGLOBL,SUSPNDOP       * Did we suspend the processing? 04280000
         BO    BYPASCLR                * Yes, the handler is off        04290000
         SPACE ,                                                        04300000
         HNDEXT CLR,CODE=1004,ERROR=*,MF=(E,HNDPLST2) * Clear the SLIH  04310000
         SPACE ,                                                        04320000
BYPASCLR EQU   *                                                        04330000
         ENABLE INTTYPE=ALL,MF=(E,NUCENAWA) Enable all interrupts back  04340000
NOHANDLR EQU   *                                                        04350000
         CLC   NUCXNAME,CMNDLIST+8     * Check for NUCXDROP * |SCHEDULE 04360000
         BNE   PURGE                   * NUCXDROP * was issued, bypass  04370000
         SPACE ,                                                        04380000
         LA    R14,2048(,R7)           * Get back the temp base in R14  04390000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 04400000
         LA    R15,ERRSC01             * Point to the correct MSG       04410000
         BAS   R9,WRITEMSG             * Go issue the error msg         04420000
PURGE    EQU   *                                                        04430000
         STCTL C0,C0,CONTROL0          * Save the CR0 contents          04440000
         NI    PROGLOBL,255-INSLIHOP   * Reset the "in SLIH" bit        04450000
EXITBRAN B     EXITENA                 * Return to caller               04460000
         EJECT ,                                                        04470000
PROCEED  DS    0H                                                       04480000
         TM    USEMFLG-USERSAVE(R2),USEPLIST * Extended plist present ? 04490000
         BNO   NOEPLIST                * No, go issue an error message  04500000
         SPACE ,                                                        04510000
         XC    PROGFLOW,PROGFLOW       * Clear the pgm flow cntrl bits  04520000
         CLC   ONCONST,TOKEN1          * 'ON' parameter supplied ?      04530000
         BE    TIMERON                 * Yes, set up the handler        04540000
         SPACE ,                                                        04550000
         CLC   OFFCONST,TOKEN1         * 'OFF' parameter supplied ?     04560000
         BE    TIMEROFF                * Yes, remove the handler        04570000
         SPACE ,                                                        04580000
         CLC   =C'ADD ',TOKEN1         * 'ADD' parameter supplied ?     04590000
         BE    TIMERADD                * Go, process the ADD function   04600000
         SPACE ,                                                        04610000
         CLC   =C'DELETE ',TOKEN1      * 'DELETE' parameter supplied ?  04620000
         BE    TIMERDEL                * Go, process the DELETE functn  04630000
         SPACE ,                                                        04640000
         CLC   =C'DEL ',TOKEN1         * 'DELETE' parameter supplied ?  04650000
         BE    TIMERDEL                * Go, process the DELETE functn  04660000
         SPACE ,                                                        04670000
         CLC   =C'QUERY ',TOKEN1       * 'QUERY' parameter supplied ?   04680000
         BE    TIMERQRY                * Go, process the QUERY function 04690000
         SPACE ,                                                        04700000
         CLC   =C'Q ',TOKEN1           * 'QUERY' parameter supplied ?   04710000
         BE    TIMERQRY                * Go, process the QUERY function 04720000
         SPACE ,                                                        04730000
         CLC   =C'RESUME ',TOKEN1      * 'RESUME' parameter supplied ?  04740000
         BE    TIMERESU                * Go, process the RESUME functn  04750000
         SPACE ,                                                        04760000
         CLC   =C'SUSPEND ',TOKEN1     * 'SUSPEND' parameter supplied ? 04770000
         BE    TIMERSUS                * Go, process the SUSPEND functn 04780000
         SPACE ,                                                        04790000
         CLC   =C'HELP ',TOKEN1        * 'HELP' parameter supplied ?    04800000
         BE    TIMERHLP                * Go, process the HELP function  04810000
         SPACE ,                                                        04820000
         CLC   =C'? ',TOKEN1           * 'HELP' parameter supplied ?    04830000
         BE    TIMERHLP                * Go, process the HELP function  04840000
         SPACE ,                                                        04850000
         CLC   FENCE,TOKEN1            * Any parameters supplied ?      04860000
         BE    INVALID3                * No, go issue an error message  04870000
         SPACE ,                                                        04880000
         B     INVALID2                * Unknown option given           04890000
         EJECT ,                                                        04900000
TIMERON  DS    0H                                                       04910000
         CLC   FENCE,TOKEN2            * Is this a CMS fence in TOKEN2? 04920000
         BE    TIMERON1                * Yes, go with the flow          04930000
         SPACE ,                                                        04940000
         CLC   QUIETCON,TOKEN2         * Is this the 'QUIET' option?    04950000
         BE    TIMERONA                * Yes, go with the flow          04960000
         SPACE ,                                                        04970000
         CLC   =C'NOFILE ',TOKEN2      * Is this the 'NOFILE' option?   04980000
         BE    TIMERONB                * Yes, go with the flow          04990000
         SPACE ,                                                        05000000
         S     R1,FWD8                 * Decrement tokens ptr by 8      05010000
         B     EXTRAPRM                * To use the general error msg   05020000
         SPACE ,                                                        05030000
TIMERONA EQU   *                                                        05040000
         OI    PROGFLOW+1,QUIETOP      * Remember the 'QUIET' option    05050000
         LA    R1,8(,R1)               * Bump up the TOKENS ptr by 8    05060000
         B     TIMERON                 * Branch to TIMERON              05070000
         SPACE ,                                                        05080000
TIMERONB EQU   *                                                        05090000
         OI    PROGFLOW+2,NOFILEOP     * Remember the 'NOFILE' option   05100000
         LA    R1,8(,R1)               * Bump up the TOKENS ptr by 8    05110000
         B     TIMERON                 * Branch to TIMERON              05120000
         SPACE ,                                                        05130000
TIMERON1 EQU   *                                                        05140000
         L     R2,EXTHNDLR             * Check if we created a handler  05150000
         LTR   R2,R2                   * Have we set it up already?     05160000
         BNZ   ALRDYON                 * Yes, we have. It's an error    05170000
         SPACE ,                                                        05180000
         NI    PROGLOBL,X'00'          * Reset the global control byte  05190000
         SPACE ,                                                        05200000
         TM    PROGFLOW+2,NOFILEOP     * Was 'NOFILE' option supplied?  05210000
         BNO   TIMERON2                * No, bypass the bit setting     05220000
         SPACE ,                                                        05230000
         OI    PROGLOBL,NOFILEOP       * Set the global 'NOFILE' optn   05240000
TIMERON2 EQU   *                                                        05250000
         ST    R7,BASE7                * Save the base register 7       05260000
         STM   R10,R12,BASE1012        * Save the base registers 10-12  05270000
         XC    ANCEVENT,ANCEVENT       * Clear the anchor of events     05280000
         XC    LSTEVENT,LSTEVENT       * Clr ptr to last event on list  05290000
         XC    TOTEVNTS,TOTEVNTS       * Clear num of events in queue   05300000
         XC    IDENTNUM,IDENTNUM       * Clear the next event number id 05310000
         STCKC OCLKCOMP                * Save the old clock compar valu 05320000
         LA    R2,SCHEDULR             * Get the ptr to sched routine   05330000
         ST    R2,ASCHEDUL             * Save the pointer to it         05340000
*********************************************************************** 05350000
***                                                                 *** 05360000
***  Clear the SLIH for code 1004 (clock comparator external in-    *** 05370000
***  terrupt), just in case it was already set by someone else,     *** 05380000
***  and create our own.                                            *** 05390000
***                                                                 *** 05400000
*********************************************************************** 05410000
         TM    PROGLOBL,NOFILEOP       * Was 'NOFILE' option supplied?  05420000
         BO    NOFILERD                * Yes, don't read the file in    05430000
         SPACE ,                                                        05440000
         LR    R3,R1                   * Save R1 temporarily            05450000
         LA    R2,TIMFNAME             * Point R1 to the 18 byte name   05460000
         FSOPEN  (R2),FSCB=OUTPUTDS,OPENTYP=WRITE,ERROR=OPENERR,       *05470000
               MSG=YES,FORM=E,RECFM=V  * Look for SCHEDULE TIMES & R/W  05480000
         L     R1,FSCBFST-FSCBD(,R1)   * Get the pointer to the FST     05490000
         LTR   R1,R1                   * Is there one ?                 05500000
         BZ    FILENEW                 * No, it's a new file            05510000
         SPACE ,                                                        05520000
         FSCLOSE (R2),FSCB=OUTPUTDS,ERROR=*  Close the output file      05530000
         SPACE ,                                                        05540000
         BAS   R9,INITIMER             * Initialize the timer informatn 05550000
         BAS   R9,EVENTINI             * Go, create the event schedule  05560000
         B     FILEOLD                 * Join the code at FSCLOSE       05570000
         SPACE ,                                                        05580000
FILENEW  EQU   *                                                        05590000
         FSCLOSE (R2),FSCB=OUTPUTDS,ERROR=*  Close the output file      05600000
         SPACE ,                                                        05610000
NOFILERD EQU   *                                                        05620000
         BAS   R9,INITIMER             * Initialize the timer informatn 05630000
         SPACE ,                                                        05640000
FILEOLD  EQU   *                                                        05650000
         HNDEXT CLR,CODE=1004,ERROR=*,MF=(E,HNDPLST2)                   05660000
         ENABLE INTTYPE=NONE,MF=(E,NUCENAWA) * Disable all interrupts   05670000
         LA    R2,EXTSLIH              * Point R2 to our external SLIH  05680000
         HNDEXT SET,(R2),CODE=1004,KEEP=YES,SYSTEM=YES,ERROR=HNDERR,   *05690000
               MF=(E,HNDPLST1)         * Set up our own external SLIH   05700000
         LA    R2,EXTSLIH              * Point R2 to our handler        05710000
         ST    R2,EXTHNDLR             * Save the pointer to it         05720000
         ENABLE INTTYPE=ALL,MF=(E,NUCENAWA) Enable all interrupts back  05730000
         LR    R1,R3                   * Restore R1 from R3             05740000
         TM    PROGFLOW+1,QUIETOP      * Should we tell user it's done? 05750000
         BO    NOINFO1                 * No, bypass the write           05760000
         SPACE ,                                                        05770000
         LA    R14,2048(,R7)           * Get back the temp base in R14  05780000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 05790000
         LA    R15,ERRSC07             * Tell the user it is in place   05800000
         BAS   R9,WRITEMSG             * Write the informational msg    05810000
NOINFO1  EQU   *                                                        05820000
         CLC   ANCEVENT,NULL           * Is there an EVENT anchor ?     05830000
         BE    NOCONTRL                * No, don't change the CR0 mask  05840000
         SPACE ,                                                        05850000
         STCTL C0,C0,CONTROL0          * Save the control register 0    05860000
         OI    CONTROL0+2,X'08'        * Turn on  the Clock comp mask   05870000
         LCTL  C0,C0,CONTROL0          * Load CR0 with the new value    05880000
NOCONTRL EQU   *                                                        05890000
         XC    RETCODE,RETCODE         * Set the return code to zero    05900000
         B     EXIT                    * Exit the program               05910000
         EJECT ,                                                        05920000
TIMEROFF DS    0H                                                       05930000
         CLC   FENCE,TOKEN2            * Is this a CMS fence in TOKEN2? 05940000
         BE    TIMEROFB                * Yes, go with the flow          05950000
         SPACE ,                                                        05960000
         CLC   QUIETCON,TOKEN2         * Is this the 'QUIET' option?    05970000
         BE    TIMEROFA                * Yes, go with the flow          05980000
         SPACE ,                                                        05990000
         S     R1,FWD8                 * Decrement tokens ptr by 8      06000000
         B     EXTRAPRM                * To use the general error msg   06010000
         SPACE ,                                                        06020000
TIMEROFA EQU   *                                                        06030000
         OI    PROGFLOW+1,QUIETOP      * Remember, no message to write  06040000
TIMEROFB EQU   *                                                        06050000
         L     R2,EXTHNDLR             * Check if we created a handler  06060000
         LTR   R2,R2                   * Have we set it up already?     06070000
         BZ    ALRDYOFF                * No, we haven't. It's an error  06080000
         SPACE ,                                                        06090000
         STCTL C0,C0,CONTROL0          * Save the CR0 contents          06100000
         NI    CONTROL0+2,255-X'08'    * Turn off the Clock comp mask   06110000
         LCTL  C0,C0,CONTROL0          * Get the altered CR 0           06120000
         ENABLE INTTYPE=NONE,MF=(E,NUCENAWA) * Disable all interrupts   06130000
TIMROFF1 EQU   *                                                        06140000
         L     R8,ANCEVENT             * Get the last EVENT block ptr   06150000
         LTR   R8,R8                   * Is there one ?                 06160000
         BZ    TIMROFF2                * No, then we are done           06170000
         SPACE ,                                                        06180000
         XR    R0,R0                   * Don't change this line in file 06190000
         BAS   R9,DELEVENT             * Go, delete this EVENT block    06200000
         SPACE ,                                                        06210000
         B     TIMROFF1                * See if more EVENTs exits       06220000
         SPACE ,                                                        06230000
TIMROFF2 EQU   *                                                        06240000
         LR    R3,R1                   * Save R1 temporarily            06250000
         HNDEXT CLR,CODE=1004,ERROR=*,MF=(E,HNDPLST2)                   06260000
         XC    EXTHNDLR,EXTHNDLR       * Clear our own SLIH pointer     06270000
         ENABLE INTTYPE=ALL,MF=(E,NUCENAWA) Enable all interrupts back  06280000
         TM    PROGLOBL,NOFILEOP       * Was there a 'NOFILE' option ?  06290000
         BO    TIMROFF3                * Yes, do not close the file     06300000
         SPACE ,                                                        06310000
         LA    R2,TIMFNAME             * Point R1 to the 18 byte name   06320000
         FSCLOSE (R2),FSCB=OUTPUTDS,ERROR=*                             06330000
TIMROFF3 EQU   *                                                        06340000
         LR    R1,R3                   * Restore R1 from R3             06350000
         TM    PROGFLOW+1,QUIETOP      * Should we tell user it's done? 06360000
         BO    NOINFO2                 * No, bypass the write           06370000
         SPACE ,                                                        06380000
         LA    R14,2048(,R7)           * Get back the temp base in R14  06390000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 06400000
         LA    R15,ERRSC10             * Tell the user it was removed   06410000
         BAS   R9,WRITEMSG             * Write the informational msg    06420000
NOINFO2  EQU   *                                                        06430000
         SCKC  OCLKCOMP                * Restore the orig clock compar  06440000
         XC    RETCODE,RETCODE         * Set the return code to zero    06450000
         B     EXIT                    * Exit the program               06460000
         EJECT ,                                                        06470000
TIMERADD DS    0H                                                       06480000
         CLC   EXTHNDLR(4),NULL        * Have we established a SLIH ?   06490000
         BE    NOSLIH                  * No, issue an error message     06500000
         SPACE ,                                                        06510000
         L     R2,0(,R2)               * Get the EPLIST pointer         06520000
         USING EPLIST,R2               * Map the Extended PLIST         06530000
         L     R0,EPLARGBG             * Point R0 to the start of args  06540000
         L     R1,EPLARGND             * Point R1 to the end of args    06550000
         BAS   R9,GETLEN               * Find out the length of string  06560000
         SPACE ,                                                        06570000
         AR    R0,R1                   * Bypass the first parameter     06580000
         L     R1,EPLARGND             * Point R1 to the end of args    06590000
         BAS   R9,GETNBLNK             * Find out the len till nonblank 06600000
         AR    R0,R1                   * Add the len to R0; 1st nonblnk 06610000
         L     R1,EPLARGND             * Point R1 to the end of args    06620000
         CR    R0,R1                   * Argument present ?             06630000
         BNL   MISPARM                 * No, go issue an error msg      06640000
         SPACE ,                                                        06650000
         BAS   R9,GETLEN               * Find out the length of string  06660000
         SPACE ,                                                        06670000
         CH    R1,HWD12                * String <= 12 characters ?      06680000
         BH    BADPARM                 * No, invalid parameter then     06690000
         SPACE ,                                                        06700000
         LA    R14,EVNTBUFF            * Point R14 to storage for clear 06710000
         LA    R15,L'EVNTBUFF          * R15 is the length of the area  06720000
         LA    R3,0                    * Force the target length to 0   06730000
         MVCL  R14,R2                  * Clear the buffer storage to 0  06740000
         SPACE ,                                                        06750000
         MVI   RECRDMAP,C' '           * Move a blank into the I/O buff 06760000
         MVC   RECRDMAP+1(RECOPERL),RECRDMAP * Clear the operation buff 06770000
         MVC   RECDATA(L'RECDATA),RECDATA-1  * Clear the data portion   06780000
         OI    PROGFLOW,CMDINPUT       * ADD function from cmd line     06790000
PARMLOOP EQU   *                                                        06800000
         MVC   PARMTEMP,BLANKS         * Clear the temp parm storage    06810000
         LR    R3,R0                   * Point R3 to start of string    06820000
         LA    R4,PARMTEMP             * Point R4 to date buffer field  06830000
         BCTR  R1,R0                   * Decrement R1 for EXecute       06840000
         EX    R1,MOVEPARM             * Execute the following:         06850000
*+++     MVC   0(*-*,R4),0(R3)         * Move the non-tokenized parm    06860000
         OC    PARMTEMP,BLANKS         * Convert the parm to upper case 06870000
         LR    R6,R4                   * Point R6 to the date buffer    06880000
         LA    R1,1(,R1)               * Get the parameter length back  06890000
         BAS   R9,CHKDATE              * Go, check if a valid date/time 06900000
         BC    CC0,CONTPARS            * Match found. Continue parsing  06910000
         SPACE ,                                                        06920000
CHECKARG EQU   *                                                        06930000
         BAS   R9,CHKSPEC              * Chk for other valid date/time  06940000
         BC    CC1,BADPARM             * If CC1, parameter is invalid   06950000
         SPACE ,                                                        06960000
CONTPARS EQU   *                                                        06970000
         AR    R0,R1                   * Bypass the first parameter     06980000
         L     R1,EPLARGND             * Point R1 to the end of args    06990000
         BAS   R9,GETNBLNK             * Find out the len till nonblank 07000000
         AR    R0,R1                   * Add the len to R0; 1st nonblnk 07010000
         L     R1,EPLARGND             * Point R1 to the end of args    07020000
         CR    R0,R1                   * Argument present ?             07030000
         BNL   MISCMDMS                * No, missing a cmd/msg itself   07040000
         SPACE ,                                                        07050000
         TM    PROGFLOW,FUNCKINC       * Have we scanned funct keyword? 07060000
         BO    MORPARMS                * Yes, we'll copy the msg/cmd    07070000
         SPACE ,                                                        07080000
         BAS   R9,GETLEN               * Find out the length of string  07090000
         B     PARMLOOP                * Go, process the next parameter 07100000
         SPACE 3                                                        07110000
MORPARMS EQU   *                                                        07120000
         LR    R3,R0                   * Point R3 to start of string    07130000
         SR    R1,R0                   * Get the data length to move    07140000
         STH   R1,MESSAGLN             * Save the message length        07150000
         LA    R4,EVNTDATA-EVENT+EVNTBUFF * Point R4 to data buffer     07160000
         BCTR  R1,R0                   * Decrement R1 for EXecute       07170000
         EX    R1,MOVEPARM             * Execute the following:         07180000
*+++     MVC   0(*-*,R4),0(R3)         * Move the non-tokenized cmd/msg 07190000
         LA    R1,EVNTFIXL+1(,R1)      * Calc the free storage needed   07200000
         STH   R1,EVNTELEN-EVENT+EVNTBUFF * Free storage bytes to reqst 07210000
         LH    R2,IDENTNUM             * Get the next avail ident num   07220000
         LA    R2,1(,R2)               * Bump the "next identifier" num 07230000
         STH   R2,IDENTNUM             * And save the new value         07240000
         STH   R2,(EVNTIDEN-EVENT)+EVNTBUFF * Set up the EVENT's ident  07250000
         TM    PROGFLOW,CMDINPUT       * ADD cmd entered from terminal? 07260000
         BO    SETAREC                 * No, continue at SETAREC        07270000
         SPACE ,                                                        07280000
         BAS   R9,SETEVENT             * Go, set up the event           07290000
         SPACE ,                                                        07300000
         CLC   ANCEVENT,NULL           * Is there an EVENT anchor ?     07310000
         BE    NOCNTRL2                * No, don't change the CR0 mask  07320000
         SPACE ,                                                        07330000
         TM    PROGLOBL,INSLIHOP       * SCHEDULE calld by SLIH itself? 07340000
         BO    NOCNTRL2                * Yes, do not change the CR0     07350000
         SPACE ,                                                        07360000
         OI    CONTROL0+2,X'08'        * Turn on  the Clock comp mask   07370000
         LCTL  C0,C0,CONTROL0          * Load CR0 with the old value    07380000
NOCNTRL2 EQU   *                                                        07390000
         B     EXIT                    * Return to caller               07400000
         SPACE 3                                                        07410000
SETAREC  EQU   *                                                        07420000
         LH    R1,MESSAGLN             * Get the message length back    07430000
         BCTR  R1,R0                   * Decrement R1 for EXecute       07440000
         LA    R4,RECDATA              * Point R4 to RECDATA            07450000
         EX    R1,MOVEPARM             * Execute the following:         07460000
*+++     MVC   0(*-*,R4),0(R3)         * Move the non-tokenized cmd/msg 07470000
         LA    R1,RECOPERL+1(,R1)      * Calculate the record length    07480000
         STH   R1,RECORDLN             * Save the record length         07490000
         SPACE ,                                                        07500000
         CLC   RECDATE,BLANKS          * Any value in RECDATE ?         07510000
         BNE   DATEGIVN                * Yes, don't change it then      07520000
         SPACE ,                                                        07530000
         STCK  TODVALUE                * Get the TOD clock              07540000
         LA    R1,RECDATE              * Point R1 to the date buffer    07550000
         LA    R2,TIMEVAL              * Point R2 to the time buffer    07560000
         LA    R0,TODVALUE             * Point R0 to the TOD clock      07570000
         BAS   R9,TOD2EBCD             * Convert TOD clock to EBCDIC    07580000
         SPACE ,                                                        07590000
DATEGIVN EQU   *                                                        07600000
         LA    R2,RECRDMAP             * Point R2 to the output buffer  07610000
         MVC   OUTPUTDS+(FSCBFILE-FSCBD)(L'FSCBFILE),TIMFNAME * Fileid  07620000
         LH    R5,RECORDLN             * Get the record length          07630000
         LH    R4,IDENTNUM             * Write the next record          07640000
         TM    PROGLOBL,NOFILEOP       * Was 'NOFILE' option supplied ? 07650000
         BO    NOWRITE                 * Yes, then don't write the line 07660000
         SPACE ,                                                        07670000
         FSWRITE FSCB=OUTPUTDS,ERROR=WRITERR,BUFFER=(R2),BSIZE=(R5),   *07680000
               NOREC=1,RECNO=(R4),RECFM=V,FORM=E  * Write 1 record out  07690000
NOWRITE  EQU   *                                                        07700000
         BAS   R9,SETEVENT             * Set up the current event       07710000
         SPACE ,                                                        07720000
         CLC   ANCEVENT,NULL           * Is there an EVENT anchor ?     07730000
         BE    NOCR0CHG                * No, don't change the CR0 mask  07740000
         SPACE ,                                                        07750000
         TM    PROGLOBL,INSLIHOP       * SCHEDULE calld by SLIH itself? 07760000
         BO    NOCR0CHG                * Yes, do not change the CR0     07770000
         SPACE ,                                                        07780000
         OI    CONTROL0+2,X'08'        * Turn on  the Clock comp mask   07790000
         LCTL  C0,C0,CONTROL0          * Load CR0 with the old value    07800000
NOCR0CHG EQU   *                                                        07810000
         B     EXIT                    * Return to caller               07820000
         SPACE 3                                                        07830000
TIMERDEL DS    0H                                                       07840000
         CLC   EXTHNDLR(4),NULL        * Have we established a SLIH ?   07850000
         BE    NOSLIH                  * No, issue an error message     07860000
         SPACE ,                                                        07870000
         CLC   FENCE,TOKEN2            * CMS fence reached prematurely? 07880000
         BE    MISPARM                 * Yes, issue an error message    07890000
         SPACE ,                                                        07900000
         CLC   FENCE,TOKEN3            * Any extraneous parameters ?    07910000
         BNE   EXTRAPRM                * Yes, issue an error message    07920000
         SPACE ,                                                        07930000
         CLC   ALLCONST,TOKEN2         * 'ALL' parameter supplied ?     07940000
         BNE   TIMERDL2                * No, do one at a time           07950000
         SPACE ,                                                        07960000
TIMERDL1 EQU   *                                                        07970000
         ENABLE INTTYPE=NONE,MF=(E,NUCENAWA) * Disable all interrupts   07980000
         STCTL C0,C0,CONTROL0          * Save the CR0 register          07990000
         NI    CONTROL0+2,255-X'08'    * Disable clock compar interr    08000000
         LCTL  C0,C0,CONTROL0          * And load the new CR0 value     08010000
         L     R8,ANCEVENT             * Get the last EVENT block ptr   08020000
         LTR   R8,R8                   * Is there one ?                 08030000
         BZ    TIMERDLA                * No, then we are done           08040000
         SPACE ,                                                        08050000
         LA    R0,1                    * We want this line commnted out 08060000
         BAS   R9,DELEVENT             * Go, delete this EVENT block    08070000
         SPACE ,                                                        08080000
         B     TIMERDL1                * See if more EVENTs exits       08090000
         SPACE ,                                                        08100000
TIMERDL2 EQU   *                                                        08110000
         ENABLE INTTYPE=NONE,MF=(E,NUCENAWA) * Disable all interrupts   08120000
         STCTL C0,C0,CONTROL0          * Save the CR0 register          08130000
         NI    CONTROL0+2,255-X'08'    * Disable clock compar interr    08140000
         LCTL  C0,C0,CONTROL0          * And load the new CR0 value     08150000
         LA    R0,TOKEN2               * Save the token pointer         08160000
         LR    R2,R0                   * Make another copy of it        08170000
         LA    R1,8(,R2)               * Point to the end of the token  08180000
         BAS   R9,GETLEN               * Find out the token's length    08190000
         LR    R0,R1                   * Get the length into R0         08200000
         LR    R1,R2                   * Point to the item itself       08210000
         BAS   R14,D2B                 * Convert the number to binary   08220000
         BNZ   BADEVTID                * Cannot convert the num. Error  08230000
         SPACE ,                                                        08240000
         CH    R1,HWD32767             * Greater than max EVENT number? 08250000
         BH    BADEVTID                * Yes, go issue an error message 08260000
         SPACE ,                                                        08270000
         BAS   R9,FINDEVNT             * Go, find matching EVENT ident  08280000
         BNZ   BADEVTID                * Non-zero CC -- error           08290000
         SPACE ,                                                        08300000
         LA    R0,1                    * We want this line commnted out 08310000
         BAS   R9,DELEVENT             * Delete the EVENT (ptr in R8)   08320000
         L     R8,ANCEVENT             * Get the events anchor pointer  08330000
         LTR   R8,R8                   * Is there a pointer             08340000
         BNZ   TIMERDLX                * Yes, then just exit            08350000
         SPACE ,                                                        08360000
TIMERDLA EQU   *                                                        08370000
         XC    LSTEVENT,LSTEVENT       * Clear the last event pointer   08380000
         SPACE ,                                                        08390000
TIMERDLX EQU   *                                                        08400000
         XR    R0,R0                   * We are not SLIH                08410000
         BAS   R14,SCHEDULR            * And re-schedule events         08420000
         SPACE ,                                                        08430000
         B     EXITENA                 * Return to caller               08440000
         EJECT ,                                                        08450000
TIMERQRY DS    0H                                                       08460000
         CLC   QUECONST,TOKEN2         * Is this a "QUEUE" parameter?   08470000
         BNE   TIMQRYA1                * No, then don't stack it        08480000
         SPACE ,                                                        08490000
         OI    PROGFLOW+1,QUEUELIN     * Remember we are queueing outpt 08500000
TIMQRYA1 EQU   *                                                        08510000
         CLC   QUECONST,TOKEN3         * Is this a "QUEUE" parameter?   08520000
         BNE   TIMQRYA2                * No, then don't stack it        08530000
         SPACE ,                                                        08540000
         OI    PROGFLOW+1,QUEUELIN     * Remember we are queueing outpt 08550000
TIMQRYA2 EQU   *                                                        08560000
         CLC   FENCE,TOKEN2            * CMS fence already reached ?    08570000
         BE    TIMQRYAL                * Yes, do a "QUERY ALL"          08580000
         SPACE ,                                                        08590000
         CLC   ALLCONST,TOKEN2         * CMS fence already reached ?    08600000
         BE    TIMQRYAL                * Yes, do a "QUERY ALL"          08610000
         SPACE ,                                                        08620000
         CLC   VERCONST,TOKEN2         * Is this a 'QUERY VERSION" ?    08630000
         BE    TIMQRYVE                * Yes, process that option       08640000
         SPACE ,                                                        08650000
         CLC   STACONST,TOKEN2         * Is this a 'QUERY STATUS"  ?    08660000
         BE    TIMQRYST                * Yes, process that option       08670000
         SPACE ,                                                        08680000
         MVC   PARMTEMP,BLANKS         * Copy blanks to temp parm       08690000
         MVC   PARMTEMP(8),TOKEN2      * Copy the possible date         08700000
         LA    R6,PARMTEMP             * Point to the parm holding area 08710000
         BAS   R9,VALIDATE             * Go, validate the date parm     08720000
         BC    CC1,TIMQRY1             * Try to check for a 1 query     08730000
         SPACE ,                                                        08740000
         CLC   EXTHNDLR(4),NULL        * Have we established a SLIH ?   08750000
         BE    NOSLIH                  * Yes, give user a msg           08760000
         SPACE ,                                                        08770000
         LR    R6,R1                   * Save R1 temporarily in R6      08780000
         MVC   DATEVAL,PARMTEMP        * Copy the validated date        08790000
         LA    R0,ZEROTIME             * Point R0 to the EBCDIC time    08800000
         LA    R1,DATEVAL              * Point R1 to the EBCDIC date    08810000
         BAS   R9,EBCD2TOD             * Convert the date to TOD clock  08820000
         SPACE ,                                                        08830000
         LA    R0,CALCTIME             * Point to the calculated TOD    08840000
         LA    R2,TIMEVAL              * Point R2 to TIMEVAL            08850000
         BAS   R9,TOD2EBCD             * Convert the date to TOD clock  08860000
         SPACE ,                                                        08870000
         MVC   PARMTEMP(8),DATEVAL     * Copy the date                  08880000
         MVC   PARMTEMP+8(2),PARMTEMP+YY * Move the year right 2 digits 08890000
         CLC   PARMTEMP+YY(2),=C'93'   * Is this year 1993 or higher ?  08900000
         BNL   TIMR20TH                * Yes, we are in 20th century    08910000
         SPACE ,                                                        08920000
         MVC   PARMTEMP+YY(2),=C'20'   * We are in the 21st century     08930000
         B     TIMQRYA3                * Join the common code           08940000
         SPACE ,                                                        08950000
TIMR20TH EQU   *                                                        08960000
         MVC   PARMTEMP+YY(2),=C'19'   * We are in the 21st century     08970000
TIMQRYA3 EQU   *                                                        08980000
         MVC   RECDATA(L'PARMTEMP),PARMTEMP * Copy the date to buffer   08990000
         MVC   RECDATA+L'PARMTEMP(10),DAYOFWK * Copy the day of week    09000000
         LA    R4,RECDATA              * Point R3 to RECDATA            09010000
         LA    R3,L'PARMTEMP+L'DAYOFWK * Put the length in R4           09020000
         BAS   R9,OUTPUT               * Go write/stack the output      09030000
         B     EXIT                    * Return to caller               09040000
         SPACE ,                                                        09050000
TIMQRYVE EQU   *                                                        09060000
         TM    PROGFLOW+1,QUEUELIN     * Was "QUEUE" parameter given?   09070000
         BNO   TIMQRYV1                * No, then don't stack it        09080000
         SPACE ,                                                        09090000
         XR    R2,R2                   * Clear R2 for insert            09100000
         IC    R2,VERSION              * Get the length of the string   09110000
         LA    R15,VERSION+1           * Point to the version data      09120000
         BAS   R9,QUEUEIT              * Go, queue the output           09130000
         B     EXIT                    * Return to caller               09140000
         SPACE ,                                                        09150000
TIMQRYV1 EQU   *                                                        09160000
         LA    R15,VERSION             * Point to the version info      09170000
         BAS   R9,WRITEMSG             * Go, write the output out       09180000
         B     EXIT                    * Return to caller               09190000
         SPACE ,                                                        09200000
TIMQRYST EQU   *                                                        09210000
         CLC   EXTHNDLR(4),NULL        * Have we established a SLIH ?   09220000
         BE    NOSLIH                  * Yes, give user a msg           09230000
         SPACE ,                                                        09240000
         LA    R3,ACTCONST             * Point R3 to the "ACTIVE " cons 09250000
         TM    PROGLOBL,SUSPNDOP       * Was the processing suspended?  09260000
         BNO   TIMQRYS1                * No, then bypass 1 instructn    09270000
         SPACE ,                                                        09280000
         LA    R3,SUSCONST             * Point R3 to the "ACTIVE " cons 09290000
TIMQRYS1 EQU   *                                                        09300000
         LA    R14,2048(,R7)           * Get back the temp base in R14  09310000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 09320000
         LA    R15,ERRSC23             * Point R15 to the message       09330000
         BAS   R9,WRITEMS2             * Go, write the output out       09340000
         B     EXIT                    * Return to caller               09350000
         SPACE ,                                                        09360000
TIMQRYAL EQU   *                                                        09370000
         CLC   EXTHNDLR(4),NULL        * Have we established a SLIH ?   09380000
         BE    NOSLIH                  * No, issue an error message     09390000
         SPACE ,                                                        09400000
         ENABLE INTTYPE=NONE,MF=(E,NUCENAWA) * Disable all interrupts   09410000
         STCTL C0,C0,CONTROL0          * Save the CR0 register          09420000
         NI    CONTROL0+2,255-X'08'    * Disable clock compar interr    09430000
         LCTL  C0,C0,CONTROL0          * And load the new CR0 value     09440000
         L     R8,ANCEVENT             * Get the EVENT chain pointer    09450000
         LTR   R8,R8                   * Is there one ?                 09460000
         BZ    EMPTYCHN                * No, the chain is empty         09470000
         SPACE ,                                                        09480000
         USING EVENT,R8                * Map out the EVENT block        09490000
TIMQRY0  EQU   *                                                        09500000
         LA    R3,L'HEADER             * Get the length of the header   09510000
         LA    R4,HEADER               * Point R4 to the header         09520000
         BAS   R9,OUTPUT               * Write or stack output line     09530000
         SPACE ,                                                        09540000
TIMQRY00 EQU   *                                                        09550000
         MVI   RECCURNT,C' '           * Put a blank into output record 09560000
         MVC   RECCURNT+1(QUERYLS-1),RECCURNT * Blank out query portion 09570000
         TM    EVNTFLG1,EVNTSCH        * Is this a curntly sched event? 09580000
         BNO   TIMQRY0A                * No, don't mark this line       09590000
         SPACE ,                                                        09600000
         MVI   RECCURNT,C'>'           * Mark the output line as SCHED  09610000
TIMQRY0A EQU   *                                                        09620000
         LH    R1,EVNTIDEN             * Get the EVENT identifier       09630000
         CVD   R1,DOUBLEWD             * Convert the number to decimal  09640000
         UNPK  RECEVTID(5),DOUBLEWD+5(3) Convert the ident into zoned   09650000
         OI    RECEVTID+4,X'F0'        * Force the sign                 09660000
         MVC   TSTINTVL,HWD16383       * Copy the max interval of days  09670000
         NC    TSTINTVL(2),EVNTFLG3    * Is this a days-oriented intvl? 09680000
         BZ    TIMQRY0B                * No, check rest of date/time    09690000
         SPACE ,                                                        09700000
         LH    R1,TSTINTVL             * Get the days interval          09710000
         CVD   R1,DOUBLEWD             * Convert the number to decimal  09720000
         UNPK  RECDATE+1(5),DOUBLEWD+5(3) Convert the interv into zoned 09730000
         OI    RECDATE+5,X'F0'         * Force the sign                 09740000
         MVI   RECDATE,C'+'            * Put a "+" sign in              09750000
         B     TIMQRY0F                * Go, get the time value         09760000
         SPACE ,                                                        09770000
TIMQRY0B EQU   *                                                        09780000
         TM    EVNTFLG1,EVNTADDD       * Is this an "=/dd" date format? 09790000
         BNO   TIMQRY$B                * No, scan through the DATETBL   09800000
         SPACE ,                                                        09810000
         MVC   RECDATE(3),=C'==/'      * Copy the "==/" cons to RECDATE 09820000
         MVC   RECDATE+3(2),EVNTOFFS   * Copy the EBCDIC day number     09830000
         B     TIMQRY0F                * Go, process the time portion   09840000
         SPACE ,                                                        09850000
TIMQRY$B EQU   *                                                        09860000
         XR    R0,R0                   * Clear R0 for insert            09870000
         LA    R1,RECDATE              * Point R1 to RECDATE            09880000
         XR    R2,R2                   * Clear R2 for insert            09890000
         LA    R4,DATETBL              * Point to the keyword table     09900000
         IC    R0,EVNTFLG5             * Get the event index flag       09910000
         LTR   R0,R0                   * Check for a non-zero flag      09920000
         BZ    TIMQRY0E                * If zero, go get regular date   09930000
         SPACE ,                                                        09940000
TIMQRY0C EQU   *                                                        09950000
         IC    R2,0(,R4)               * Get the unabbrev keyword len   09960000
         LTR   R2,R2                   * Is there a keyword length?     09970000
         BZ    TIMQRY0E                * No, end of table               09980000
         SPACE ,                                                        09990000
         CLM   R0,B'0001',5(R4)        * Compare the indexes            10000000
         BNE   TIMQRY0D                * Not matching, continue search  10010000
         SPACE ,                                                        10020000
         BCTR  R2,R0                   * Decrement R2 for Execute       10030000
         EX    R2,MOVECMD2             * Execute the following:         10040000
*+++     MVC   0(*-*,R1),8(R4)         * Move the keyword to RECDATE    10050000
         B     TIMQRY0F                * we are done with the date      10060000
         SPACE ,                                                        10070000
TIMQRY0D EQU   *                                                        10080000
         LA    R4,8(R2,R4)             * Point past this entry          10090000
         LA    R3,1                    * Load R1 with an odd value 1    10100000
         NR    R3,R4                   * Is R1 halfword aligned ?       10110000
         BZ    TIMQRY0C                * Yes, do the next entry         10120000
         SPACE ,                                                        10130000
         LA    R4,1(,R4)               * Bump up the table entry ptr    10140000
         B     TIMQRY0C                * Loop until a match is found    10150000
         SPACE 2                                                        10160000
TIMQRY0E EQU   *                                                        10170000
         LA    R0,EVNTINTD             * Point R0 to the TOD date clock 10180000
         LA    R1,RECDATE              * Point R1 to the RECDATE        10190000
         LA    R2,TIMEVAL              * Point R1 to the TIMEVAL        10200000
         BAS   R9,TOD2EBCD             * Convert to EBCDIC date         10210000
         SPACE ,                                                        10220000
TIMQRY0F EQU   *                                                        10230000
         LA    R2,RECTIME              * Point R2 to RECTIME            10240000
         TM    EVNTFLG2,EVNTIMM3       * Is/was this an IMMEDIATE func? 10250000
         BNO   TIMQR0F$                * No, don't put in a ">" sign    10260000
         SPACE ,                                                        10270000
         MVI   0(R2),C'>'              * Move a ">" sign in before time 10280000
         LA    R2,1(,R2)               * Increment the R2 pointer       10290000
TIMQR0F$ EQU   *                                                        10300000
         TM    EVNTFLG2,EVNTREPT       * Is this time repeatable EVENT? 10310000
         BNO   TIMQR0F0                * No, bypass the move of a "+"   10320000
         MVI   0(R2),C'+'              * Move a plus sign in            10330000
         LA    R2,1(,R2)               * Increment the R2 pointer       10340000
TIMQR0F0 EQU   *                                                        10350000
         LM    R0,R1,EVNTINTT          * Get the time interval          10360000
         SL    R1,ZONEOFST+4           * Adjust for timezone            10370000
         BC    CC2+CC3,*+8             * Branch if no borrow            10380000
         SL    R0,FWD1                 * Subtract the borrow from R0    10390000
         SL    R0,ZONEOFST             * Subtract from the first fword  10400000
         STM   R0,R1,TODVALUE          * Save the TOD clock in TODVALUE 10410000
         LA    R0,TODVALUE             * Point R0 to the TOD time intvl 10420000
         LA    R1,DATEVAL              * Point R1 to the DATEVAL        10430000
*                                      * R2 points to buff for RECTIME  10440000
         BAS   R9,TOD2EBCD             * Convert to EBCDIC date         10450000
         SPACE ,                                                        10460000
         LA    R0,EVNTCLCK             * Point R0 to the TOD EVENT clck 10470000
         LA    R1,QRYNDATE             * Point R1 to the QRYNDATE       10480000
         LA    R2,QRYNTIME             * Point R1 to the QRYNTIME       10490000
         BAS   R9,TOD2EBCD             * Convert to EBCDIC date         10500000
         SPACE ,                                                        10510000
         TM    EVNTFLG1,EVNTLIM        * Is there a time limit "UNTIL"? 10520000
         BNO   TIMQRY0G                * No, proceed with the rest      10530000
         SPACE ,                                                        10540000
         LA    R0,EVNTTILL             * Point R0 to the TOD UNTIL clck 10550000
         LA    R1,RECUNTID             * Point R1 to the RECUNTID       10560000
         LA    R2,RECUNTIT             * Point R1 to the RECUNTIT       10570000
         BAS   R9,TOD2EBCD             * Convert to EBCDIC date         10580000
         SPACE ,                                                        10590000
TIMQRY0G EQU   *                                                        10600000
         TM    EVNTFLG1,EVNTMSG        * Is this a "MSG" event ?        10610000
         BNO   TIMQRY0H                * No, it's not                   10620000
         SPACE ,                                                        10630000
         MVC   RECFUNC,MSGCONST        * Move the "MSG" constant in     10640000
TIMQRY0H EQU   *                                                        10650000
         TM    EVNTFLG1,EVNTCMS        * Is this a "CMS" event ?        10660000
         BNO   TIMQRY0I                * No, it's not                   10670000
         SPACE ,                                                        10680000
         MVC   RECFUNC,CMSCONST        * Move the "CMS" constant in     10690000
TIMQRY0I EQU   *                                                        10700000
         TM    EVNTFLG1,EVNTCP         * Is this a "CP"  event ?        10710000
         BNO   TIMQRY0J                * No, it's not                   10720000
         SPACE ,                                                        10730000
         MVC   RECFUNC,CPCONST         * Move the "CP " constant in     10740000
TIMQRY0J EQU   *                                                        10750000
         LA    R4,RECCURNT             * Point to the start of buffer   10760000
         LA    R3,QUERYLS              * R3 will hold the length        10770000
         BAS   R9,OUTPUT               * Write or stack an output line  10780000
         SPACE ,                                                        10790000
         MVC   RECCURNT(7),DOTS        * Put dots into first 7 bytes    10800000
         LH    R3,EVNTELEN             * Get the EVENT block length     10810000
         LA    R4,EVNTFIXL             * Get the fixed length portion   10820000
         SR    R3,R4                   * Calculate the length of text   10830000
         BCTR  R3,R0                   * Decrement length by 1 for EX   10840000
         LA    R4,RECCURNT             * Point R4 to the output buffer  10850000
         LA    R1,EVNTDATA             * Point to the text data itself  10860000
         EX    R3,MOVECMD3             * Execute the following:         10870000
*+++     MVC   7(*-*,R4),0(R1)         * Copy the MSG/CMD to output buf 10880000
         LA    R3,8(,R3)               * Get the length back + 7        10890000
         BAS   R9,OUTPUT               * Write or stack an output line  10900000
         SPACE 2                                                        10910000
         TM    PROGFLOW+1,QUERYONE     * Only 1 entry query ?           10920000
         BO    EXITENA                 * Yes, then exit                 10930000
         SPACE ,                                                        10940000
         L     R8,EVNTPREV             * Point R8 to the previous event 10950000
         LTR   R8,R8                   * Is there one ?                 10960000
         BZ    EXITENA                 * No, chain is exhausted. Exit   10970000
         SPACE ,                                                        10980000
         B     TIMQRY00                * Cont scanning the EVENT chain  10990000
         SPACE 2                                                        11000000
TIMQRY1  EQU   *                                                        11010000
         CLC   EXTHNDLR(4),NULL        * Have we established a SLIH ?   11020000
         BE    NOSLIH                  * No, issue an error message     11030000
         SPACE ,                                                        11040000
         OI    PROGFLOW+1,QUERYONE     * Only one output item to check  11050000
         ENABLE INTTYPE=NONE,MF=(E,NUCENAWA) * Disable all interrupts   11060000
         STCTL C0,C0,CONTROL0          * Save the CR0 register          11070000
         NI    CONTROL0+2,255-X'08'    * Disable clock compar interr    11080000
         LCTL  C0,C0,CONTROL0          * And load the new CR0 value     11090000
         LA    R0,TOKEN2               * Point R0 to start of TOKEN2    11100000
         LR    R2,R1                   * Save R1 temporarily in R2      11110000
         LA    R1,TOKEN2+8             * Point R1 to the end of TOKEN2  11120000
         BAS   R9,GETLEN               * Find out the length of string  11130000
         SPACE ,                                                        11140000
         LR    R0,R1                   * Get the length into R0         11150000
         LR    R1,R2                   * Get the TOKENS pointer back    11160000
         LA    R1,TOKEN2               * Point R1 to start of string    11170000
         LR    R2,R1                   * Point R2 to the same           11180000
         BAS   R14,D2B                 * Convert the number to binary   11190000
         BNZ   NOTEVTID                * CC ^= 0, bad conversion        11200000
         SPACE ,                                                        11210000
         BAS   R9,FINDEVNT             * Go, find a matching event      11220000
         BNZ   BADEVTID                * CC ^= 0, EVENT ident not found 11230000
         SPACE ,                                                        11240000
         B     TIMQRY0                 * Go, display or queue the info  11250000
         SPACE ,                                                        11260000
         DROP  R8                      * Stop mapping the EVENT block   11270000
         EJECT ,                                                        11280000
TIMERESU DS    0H                                                       11290000
         S     R1,FWD8                 * Decrement tokens ptr by 8      11300000
         CLC   QUIETCON,TOKEN3         * CMS fence already reached ?    11310000
         BNE   TIMREFNC                * No, we have to check for fence 11320000
         SPACE ,                                                        11330000
         OI    PROGFLOW+1,QUIETOP      * Remember the 'QUIET' option    11340000
         B     TIMRECNT                * And continue with resume       11350000
         SPACE ,                                                        11360000
TIMREFNC EQU   *                                                        11370000
         CLC   FENCE,TOKEN3            * CMS fence already reached ?    11380000
         BNE   EXTRAPRM                * No, we have an extraneous parm 11390000
         SPACE ,                                                        11400000
TIMRECNT EQU   *                                                        11410000
         CLC   EXTHNDLR(4),NULL        * Have we established a SLIH ?   11420000
         BE    NOSLIH                  * No, issue an error message     11430000
         SPACE ,                                                        11440000
         TM    PROGLOBL,SUSPNDOP       * Is the processing suspended ?  11450000
         BNO   BADRESUM                * No, then it's a bad resume     11460000
         SPACE ,                                                        11470000
         STCTL C0,C0,CONTROL0          * Save the contents of CR0       11480000
         HNDEXT CLR,CODE=1004,ERROR=*,MF=(E,HNDPLST2) CLR, just in case 11490000
         LA    R2,EXTSLIH              * Point R2 to our external SLIH  11500000
         HNDEXT SET,(R2),CODE=1004,KEEP=YES,SYSTEM=YES,ERROR=HNDERR,   *11510000
               MF=(E,HNDPLST1)         * Set up our own external SLIH   11520000
         NI    PROGLOBL,255-SUSPNDOP   * Turn off the SUSPNDOP bit      11530000
         SCKC  SCLKCOMP                * Restore the clock compar cont  11540000
         TM    PROGFLOW+1,QUIETOP      * Was option "QUIET" given ?     11550000
         BO    EXITENA                 * Yes, then exit-enable, no MSG  11560000
         SPACE ,                                                        11570000
         LA    R14,2048(,R7)           * Get back the temp base in R14  11580000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 11590000
         LA    R15,ERRSC22             * Point to the message to write  11600000
         LA    R3,RESCONST             * Point R3 to "RESUMED" constant 11610000
         BAS   R9,WRITEMS3             * Go write the message out       11620000
         B     EXITENA                 * Go, update the interrupt masks 11630000
         EJECT ,                                                        11640000
TIMERSUS DS    0H                                                       11650000
         S     R1,FWD8                 * Decrement tokens ptr by 8      11660000
         CLC   QUIETCON,TOKEN3         * CMS fence already reached ?    11670000
         BNE   TIMSUFNC                * No, we have to check for fence 11680000
         SPACE ,                                                        11690000
         OI    PROGFLOW+1,QUIETOP      * Remember the 'QUIET' option    11700000
         B     TIMSUCNT                * And continue with suspend      11710000
         SPACE ,                                                        11720000
TIMSUFNC EQU   *                                                        11730000
         CLC   FENCE,TOKEN3            * CMS fence already reached ?    11740000
         BNE   EXTRAPRM                * No, we have an extraneous parm 11750000
         SPACE ,                                                        11760000
TIMSUCNT EQU   *                                                        11770000
         CLC   EXTHNDLR(4),NULL        * Have we established a SLIH ?   11780000
         BE    NOSLIH                  * No, issue an error message     11790000
         SPACE ,                                                        11800000
         TM    PROGLOBL,SUSPNDOP       * Is the processing suspended ?  11810000
         BO    BADSUSP                 * Yes, no need to suspend again  11820000
         SPACE ,                                                        11830000
         STCTL C0,C0,CONTROL0          * Save the contents of CR0       11840000
         NI    CONTROL0+2,255-X'08'    * Turn off the comparator mask   11850000
         LCTL  C0,C0,CONTROL0          * Reload the CR0 with masked int 11860000
         STCKC SCLKCOMP                * Save the clock comparator cont 11870000
         HNDEXT CLR,CODE=1004,ERROR=*,MF=(E,HNDPLST2)                   11880000
         OI    PROGLOBL,SUSPNDOP       * Mark the pgm as suspended      11890000
         TM    PROGFLOW+1,QUIETOP      * Was option "QUIET" given ?     11900000
         BO    EXIT                    * Yes, then exit without MSG     11910000
         SPACE ,                                                        11920000
         LA    R14,2048(,R7)           * Get back the temp base in R14  11930000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 11940000
         LA    R15,ERRSC22             * Point to the message to write  11950000
         LA    R3,SUSCONST             * Point R3 to "SUSPEND" constant 11960000
         BAS   R9,WRITEMS3             * Go write the message out       11970000
         B     EXIT                    * Go, return to caller           11980000
         EJECT ,                                                        11990000
SETEVENT DS    0H                                                       12000000
*********************************************************************** 12010000
***                                                                 *** 12020000
***  This routine uses the EVENT block and  RECRDMAP block,  which  *** 12030000
***  were set up in the process of either "SCHEDULE ON"  or  "ADD"  *** 12040000
***  function, to create a new EVENT block in free storage chained  *** 12050000
***  either to the anchor of EVENT blocks or to the previously al-  *** 12060000
***  located EVENT block.                                           *** 12070000
***                                                                 *** 12080000
*********************************************************************** 12090000
         SPACE ,                                                        12100000
         STM   R0,R9,SETEVSAV          * Save registers R0 through R9   12110000
         LH    R0,EVNTELEN-EVENT+EVNTBUFF Get the length of the msg/cmd 12120000
         AH    R0,HWD7                 * Round it up for dword conversn 12130000
         SRL   R0,3                    * Convert to dwords              12140000
         CMSSTOR OBTAIN,DWORDS=(R0),SUBPOOL='NUCLEUS',TYPCALL=BRANCH,  *12150000
               ERROR=NONUCSTO,MSG=NO,LOC=ANY                            12160000
         LR    R8,R1                   * Make a copy of free storag ptr 12170000
         LR    R14,R1                  * Target storage address         12180000
         SLL   R0,3                    * Convert to bytes               12190000
         LR    R15,R0                  * Target length                  12200000
         LR    R1,R0                   * Make a copy of the length      12210000
         LA    R0,EVNTBUFF             * Point to the EVNTBUFF buffer   12220000
         MVCL  R14,R0                  * Copy the EVENT block over      12230000
         USING EVENT,R8                * Map out the EVENT control blk  12240000
DOTIMINT EQU   *                                                        12250000
         LA    R6,RECTIME              * Point R1 to time in output rec 12260000
         TM    EVNTFLG1,EVNTIMM        * Is this an immediate function? 12270000
         BNO   DOTIMIN2                * No, no need to adjust ptr      12280000
         SPACE ,                                                        12290000
         LA    R6,1(,R6)               * Bypass the ">"                 12300000
DOTIMIN2 EQU   *                                                        12310000
         TM    EVNTFLG2,EVNTREPT       * Timer interval given ?         12320000
         BNO   DOTIMIN4                * No, it is a one-time event     12330000
         SPACE ,                                                        12340000
DOTIMIN3 EQU   *                                                        12350000
         LA    R6,1(,R6)               * Bypass the "+" sign            12360000
DOTIMIN4 EQU   *                                                        12370000
         BAS   R9,VALITIME             * Validate the time value        12380000
         BC    CC1,DOTIMIN5            * Not HH:MM:SS format. Try other 12390000
         SPACE ,                                                        12400000
         LA    R0,TIMEVAL              * Point R0 to EBCDIC time value  12410000
         LA    R1,ZERODATE             * Point R1 to EBCDIC date value  12420000
         OI    PROGFLOW,FORCEGMT       * Force GMT to get absolute val  12430000
         BAS   R9,EBCD2TOD             * Calculate the time value       12440000
         NI    PROGFLOW,255-FORCEGMT   * Use timezone offset again      12450000
         MVC   EVNTINTT,CALCTIME       * Move the time interval value   12460000
         B     TRYINDEX                * Go, check the date index       12470000
DOTIMIN5 EQU   *                                                        12480000
         CLC   MIDNTCON,0(R6)          * Is this a constant "MIDNIGHT"? 12490000
         BNE   TRYNOON                                                  12500000
         SPACE ,                                                        12510000
         XC    EVNTINTT,EVNTINTT       * Interval till midnight (zeros) 12520000
         B     TRYINDEX                * Try to perf function via index 12530000
TRYNOON  EQU   *                                                        12540000
         CLC   NOONCON,0(R6)           * Is this a constant "NOON"?     12550000
         BNE   TRYINDEX                * Try to perf function via index 12560000
         SPACE ,                                                        12570000
         MVC   EVNTINTT,ONENOON        * Set the event interval = 12hrs 12580000
TRYINDEX EQU   *                                                        12590000
         STCK  TODVALUE                * Save the current timer value   12600000
         LA    R0,TODVALUE             * Point R0 to TOD timer value    12610000
         LA    R1,DATEVAL              * Point R1 to output date value  12620000
         LA    R2,TIMEVAL              * Point R1 to output time value  12630000
         BAS   R9,TOD2EBCD             * Convert the TOD clck to EBCDIC 12640000
         SPACE ,                                                        12650000
         LA    R0,ZEROTIME             * Point R0 to EBCDIC time val    12660000
         LA    R1,DATEVAL              * Point R1 to EBCDIC date val    12670000
         BAS   R9,EBCD2TOD             * Get TOD val @ midnite today    12680000
         SPACE 2                                                        12690000
         MVC   TODTODAY,CALCTIME       * Copy the TOD for today 00:00am 12700000
         XR    R0,R0                   * Clear R0 before shift          12710000
         XR    R1,R1                   * Clear R1 for insert            12720000
         IC    R1,EVNTFLG5             * Get the index control byte     12730000
         SLDL  R0,28                   * Separate the higher nybble     12740000
         SRL   R1,26                   * And the lower nybble times 4   12750000
         LA    R1,BRANTABL(R1)         * Point R1 to entry in brnch tbl 12760000
         BR    R1                      * Branch to that instruction     12770000
         SPACE 3                                                        12780000
BRANTABL DS    0H                                                       12790000
*********************************************************************** 12800000
***                                                                 *** 12810000
***  The following branches correspond to the DATETBL indexes       *** 12820000
***                                                                 *** 12830000
*********************************************************************** 12840000
         B     NOMATDAT            '0' * The date is in MM/DD/YY format 12850000
         B     DODAILY             '1' * Do the daily setup             12860000
         B     DOWEEKDA            '2' * Do the weekday setup           12870000
         B     DOWEEKND            '3' * Do the weekend setup           12880000
         B     DOADAY              '4' * Do the one day setup           12890000
         B     DOAMONTH            '5' * Do the one month setup         12900000
         B     DOAYEAR             '6' * Do the one year setup          12910000
         B     DOTODAY             '7' * Today's setup is in MM/DD/YY   12920000
         B     DOTOMORW            '8' * Tomrrow's setup is in MM/DD/YY 12930000
         B     DOADAY              '9' * Do the one day setup           12940000
         SPACE 2                                                        12950000
NOMATDAT DS    0H                      * Setup the starting date        12960000
         MVC   TSTINTVL,HWD16383       * Copy the max interval of days  12970000
         NC    TSTINTVL(2),EVNTFLG3    * Is this a days-oriented intvl? 12980000
         BZ    NOMATDT1                * No, check the time interval    12990000
         SPACE ,                                                        13000000
         XR    R1,R1                   * Clear R1 for insert            13010000
         ICM   R1,B'0011',EVNTFLG3     * Get the interval bytes into R1 13020000
         N     R1,FWD16383             * Isolate the bits X'00003FFF'   13030000
         L     R3,ONEDAY               * Get the 1st fwordworth of 1day 13040000
         MR    R2,R1                   * Multiply it by number of days  13050000
         L     R5,ONEDAY+4             * Get the 2nd fwordworth of 1day 13060000
         MR    R4,R1                   * Multiply it by number of days  13070000
         SLDL  R2,32                   * Shift the fullword in R3 to R2 13080000
         ALR   R3,R5                   * Add the last 2 fullwords       13090000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         13100000
         AL    R2,FWD1                 * Yes, add it onto the 1st fword 13110000
         ALR   R2,R4                   * And add the 1st 2 fullwords    13120000
         SPACE ,                                                        13130000
         AL    R3,TODTODAY+4           * Add on today's midnight time   13140000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         13150000
         AL    R2,FWD1                 * Yes, add it onto the 1st fword 13160000
         AL    R2,TODTODAY             * Add the first fullword of TOD  13170000
         STM   R2,R3,EVNTINTD          * Save the new interval start    13180000
         B     TRYUNTIL                * Go look for UNTIL condition    13190000
         SPACE ,                                                        13200000
NOMATDT1 EQU   *                                                        13210000
         LA    R0,ZEROTIME             * Point R0 to midnight EBCDIC    13220000
         LA    R1,RECDATE              * Point R1 to EBCDIC date value  13230000
         BAS   R9,EBCD2TOD             * Get TOD val @ midnite that day 13240000
         SPACE ,                                                        13250000
         TM    EVNTFLG2,EVNTREPT       * Time interval given ?          13260000
         BO    NOMATDT2                * Yes, it's not a 1-time event   13270000
         SPACE ,                                                        13280000
         MVC   EVNTINTD,CALCTIME       * Move the day time value        13290000
         B     TRYUNTIL                * Go look for UNTIL condition    13300000
         SPACE ,                                                        13310000
NOMATDT2 EQU   *                                                        13320000
         CLC   CALCTIME,TODTODAY       * Is the day specified = today?  13330000
         BNE   NOMATDT3                * No, we will use CALCTIME value 13340000
         SPACE ,                                                        13350000
         STCK  EVNTINTD                * Save the current timer value   13360000
         B     TRYUNTIL                * Go, look for until condition   13370000
NOMATDT3 EQU   *                                                        13380000
         MVC   EVNTINTD,CALCTIME       * Move TOD midnite value that da 13390000
         B     TRYUNTIL                * Go, look for until condition   13400000
         SPACE 2                                                        13410000
DODAILY  DS    0H                                                       13420000
         TM    EVNTFLG2,EVNTREPT       * Time interval given ?          13430000
         BNO   DODAILY2                * No, it a one-time event        13440000
         SPACE ,                                                        13450000
         STCK  EVNTINTD                * Save the current timer value   13460000
         B     TRYUNTIL                * Go look for UNTIL condition    13470000
         SPACE ,                                                        13480000
DODAILY2 EQU   *                                                        13490000
         MVC   EVNTINTD,TODTODAY       * Move the day time at midnight  13500000
         B     TRYUNTIL                * Go look for UNTIL condition    13510000
         SPACE ,                                                        13520000
DOWEEKDA DS    0H                                                       13530000
         XR    R1,R1                   * Clear R1 for insert            13540000
         IC    R1,DAYOFWKN             * Get the day's number           13550000
         STCK  TODVALUE                * Save the current TOD clock val 13560000
         CH    R1,HWD5                 * Is this the Monday - Friday ?  13570000
         BNH   DOWEEKD3                *                                13580000
         SPACE ,                                                        13590000
         CH    R1,HWD7                 * Is this a Sunday ?             13600000
         BE    DOWEEKD0                * Yes, set same one day interval 13610000
         SPACE ,                                                        13620000
         CH    R1,HWD4                 * Is this a weekday be4 Friday?  13630000
         BH    DOWEEKD1                * No, do some EVNTINTD adjustmts 13640000
         SPACE ,                                                        13650000
DOWEEKD0 EQU   *                                                        13660000
         LM    R0,R1,TODTODAY          * Get the current midnight TOD   13670000
         AL    R1,ONEDAY+4             * Add the second fullword        13680000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         13690000
         AL    R0,FWD1                 * Yes, add 1 to the first fullwd 13700000
         AL    R0,ONEDAY               * Add the first fullword         13710000
         STM   R0,R1,EVNTINTD          * Save the starting TOD value    13720000
         B     TRYUNTIL                * Go, check for time repeatable  13730000
         SPACE ,                                                        13740000
DOWEEKD1 EQU   *                                                        13750000
         SPACE ,                                                        13760000
         SH    R1,HWD5                 * Determine if in Friday or Sat  13770000
         BZ    DOWEEKD2                * If = 0 then today is Friday    13780000
         SPACE ,                                                        13790000
         LM    R0,R1,TODTODAY          * Get the current midnight TOD   13800000
         AL    R1,TWODAYS+4            * Add the second fullword        13810000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         13820000
         AL    R0,FWD1                 * Yes, add 1 to the first fullwd 13830000
         AL    R0,TWODAYS              * Add the first fullword         13840000
         STM   R0,R1,EVNTINTD          * Save the starting TOD value    13850000
         B     TRYUNTIL                * Go, check for time repeatable  13860000
         SPACE ,                                                        13870000
DOWEEKD2 EQU   *                                                        13880000
         LM    R0,R1,TODTODAY          * Get the current midnight TOD   13890000
         AL    R1,DAYS3+4              * Add the second fullword        13900000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         13910000
         AL    R0,FWD1                 * Yes, add 1 to the first fullwd 13920000
         AL    R0,DAYS3                * Add the first fullword         13930000
         STM   R0,R1,EVNTINTD          * Save the starting TOD value    13940000
         B     TRYUNTIL                * Go, check for time repeatable  13950000
         SPACE ,                                                        13960000
DOWEEKD3 EQU   *                                                        13970000
         TM    EVNTFLG2,EVNTREPT       * Time interval given ?          13980000
         BNO   DOWEEKD4                * No, it a one-time event        13990000
         SPACE ,                                                        14000000
         STCK  EVNTINTD                * Save the current timer value   14010000
         B     TRYUNTIL                * Go look for UNTIL condition    14020000
         SPACE ,                                                        14030000
DOWEEKD4 EQU   *                                                        14040000
         MVC   EVNTINTD,TODTODAY       * Move the day time at midnight  14050000
         B     TRYUNTIL                * Go look for UNTIL condition    14060000
         SPACE 2                                                        14070000
DOWEEKND DS    0H                                                       14080000
         XR    R1,R1                   * Clear R1 for insert            14090000
         IC    R1,DAYOFWKN             * Get the day's number           14100000
         STCK  TODVALUE                * Save the current TOD clock val 14110000
         CH    R1,HWD7                 * Is this a Sunday ?             14120000
         BNE   DOWKEND1                * No, it's not                   14130000
         SPACE ,                                                        14140000
         LM    R0,R1,TODTODAY          * Get the current midnight TOD   14150000
         AL    R1,DAYS6+4              * Add the second fullword        14160000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         14170000
         AL    R0,FWD1                 * Yes, add 1 to the first fullwd 14180000
         AL    R0,DAYS6                * Add the first fullword         14190000
         STM   R0,R1,EVNTINTD          * Save the starting TOD value    14200000
         B     TRYUNTIL                * Go, look for UNTIL condition   14210000
         SPACE ,                                                        14220000
DOWKEND1 EQU   *                                                        14230000
         LA    R2,6                    * Closest weekend day is Saturda 14240000
         SR    R2,R1                   * Get the num of days till Satur 14250000
         BNZ   DOWKEND2                * If non-zero, not a Saturday    14260000
         SPACE ,                                                        14270000
         LA    R2,1                    * 1 day till Sun (today is Sat)  14280000
DOWKEND2 EQU   *                                                        14290000
         L     R1,ONEDAY               * Get the TOD val for 1 day fwd1 14300000
         L     R5,ONEDAY+4             * Get the TOD val for 1 day fwd2 14310000
         MR    R4,R2                   * Calculate TOD till Saturday    14320000
         MR    R0,R2                   * Calculate TOD till Saturday    14330000
         ALR   R1,R4                   * Get new TOD val (1st fullword) 14340000
         LR    R0,R1                   * Reload the value into R0       14350000
         LR    R1,R5                   * Get new TOD val (2nd fullword) 14360000
         SPACE ,                                                        14370000
         AL    R1,TODTODAY+4           * Add the second fullword of TOD 14380000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         14390000
         AL    R0,FWD1                 * Yes, add 1 to the first fullwd 14400000
         AL    R0,TODTODAY             * Add the first fullword         14410000
         STM   R0,R1,EVNTINTD          * Save the starting TOD value    14420000
         B     TRYUNTIL                * Go, look for UNTIL condition   14430000
         SPACE 2                                                        14440000
DOADAY   DS    0H                                                       14450000
         XR    R1,R1                   * Clear R1 for insert            14460000
         IC    R1,DAYOFWKN             * Get the day's number           14470000
         STCK  TODVALUE                * Save the current TOD clock val 14480000
         CR    R0,R1                   * Is this the same day of week ? 14490000
         BE    DOADAY4                 * Yes, it is; go set the intervl 14500000
         BL    DOADAY2                 * Yes, it is; go set the intervl 14510000
         SPACE ,                                                        14520000
         SR    R0,R1                   * Calc num of days till that day 14530000
         LR    R2,R0                   * Put the day multiplier in R2   14540000
         B     DOADAY3                 * Joint the code at DOADAY3      14550000
         SPACE ,                                                        14560000
DOADAY2  EQU   *                                                        14570000
         LA    R2,7                    * Number of days in a week       14580000
         SR    R2,R1                   * Number of days till Monday     14590000
         AR    R2,R0                   * Number of day till that day    14600000
DOADAY3  EQU   *                                                        14610000
         L     R1,ONEDAY               * Get the TOD val for 1 day fwd1 14620000
         L     R5,ONEDAY+4             * Get the TOD val for 1 day fwd2 14630000
         MR    R4,R2                   * Calculate TOD till Saturday    14640000
         MR    R0,R2                   * Calculate TOD till Saturday    14650000
         ALR   R1,R4                   * Get new TOD val (1st fullword) 14660000
         LR    R0,R1                   * Reload the value into R0       14670000
         LR    R1,R5                   * Get new TOD val (2nd fullword) 14680000
         SPACE ,                                                        14690000
         AL    R1,TODTODAY+4           * Add the second fullword of TOD 14700000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         14710000
         AL    R0,FWD1                 * Yes, add 1 to the first fullwd 14720000
         AL    R0,TODTODAY             * Add the first fullword         14730000
         STM   R0,R1,EVNTINTD          * Save the starting TOD value    14740000
         B     TRYUNTIL                * Go, look for UNTIL condition   14750000
         SPACE ,                                                        14760000
DOADAY4  EQU   *                                                        14770000
         TM    EVNTFLG2,EVNTREPT       * Time interval given ?          14780000
         BNO   DOADAY5                 * No, it a one-time event        14790000
         SPACE ,                                                        14800000
         MVC   EVNTINTD,TODVALUE       * Move the current date/time TOD 14810000
         B     TRYUNTIL                * Go, look for UNTIL condition   14820000
         SPACE ,                                                        14830000
DOADAY5  EQU   *                                                        14840000
         LM    R0,R1,TODTODAY          * Get the today's TOD value      14850000
         AL    R1,EVNTINTT+4           * Add the second fullword of TOD 14860000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         14870000
         AL    R0,FWD1                 * Yes, add 1 to the first fullwd 14880000
         AL    R0,EVNTINTT             * Add the first fullword         14890000
         STM   R0,R1,TESTTIME          * Save the result in TESTTIME    14900000
         CLC   TESTTIME,TODVALUE       * Scheduled time < current time? 14910000
         BNH   DOADAY6                 * Yes, postpone event for 7 days 14920000
         SPACE ,                                                        14930000
         MVC   EVNTINTD,TODTODAY       * Move the new date interval     14940000
         B     TRYUNTIL                * Go, look for UNTIL condition   14950000
         SPACE ,                                                        14960000
DOADAY6  EQU   *                                                        14970000
         LM    R0,R1,TODTODAY          * Get the today's TOD value      14980000
         AL    R1,DAYS7+4              * Add the second fullword of TOD 14990000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         15000000
         AL    R0,FWD1                 * Yes, add 1 to the first fullwd 15010000
         AL    R0,DAYS7                * Add the first fullword         15020000
         STM   R0,R1,EVNTINTD          * Save the starting TOD value    15030000
         B     TRYUNTIL                * Go look for UNTIL condition    15040000
         SPACE 2                                                        15050000
DOAMONTH DS    0H                                                       15060000
         TM    EVNTFLG1,EVNTADDD       * Do we have a month offset ?    15070000
         BNO   DOAMNTH1                * No, proceed as of the 1st      15080000
         SPACE ,                                                        15090000
*********************************************************************** 15100000
***                                                                 *** 15110000
***  We have to make sure the date does not end up as invalid, be-  *** 15120000
***  cause we failed to recognize a mistake like "04/31", "02/30",  *** 15130000
***  or "02/29" in a non-leap year.                                 *** 15140000
***                                                                 *** 15150000
*********************************************************************** 15160000
         MVC   DDOFFSET,EVNTOFFS       * Copy the offset day            15170000
         MVC   DATEVAL1,DATEVAL        * Copy the today's date          15180000
         MVC   DATEVAL1+DD(2),EVNTOFFS * Copy the offset day            15190000
         LA    R0,ZEROTIME             * Set time to midnight that day  15200000
         LA    R1,DATEVAL1             * Point R1 to the test date      15210000
         BAS   R9,EBCD2TOD             * Get TOD val @ midnite          15220000
         SPACE ,                                                        15230000
DOAMNTH$ EQU   *                                                        15240000
         LA    R0,CALCTIME             * Point R0 to TOD timer value    15250000
         LA    R1,DATEVAL2             * Point R1 to output date value  15260000
         LA    R2,TIMEVAL2             * Point R1 to output time value  15270000
         BAS   R9,TOD2EBCD             * Convert the TOD clck to EBCDIC 15280000
         SPACE ,                                                        15290000
         MVC   DDOFFSET,DATEVAL2+DD    * Copy the offset day            15300000
         CLC   DATEVAL1(2),DATEVAL2    * Do the months match ?          15310000
         BE    DOAMNTH0                * Yes, date is valid then        15320000
         SPACE ,                                                        15330000
         LM    R0,R1,CALCTIME          * Get the calculated TOD clock   15340000
         SL    R1,ONEDAY+4             * Subtract the second fullword   15350000
         BC    CC2+CC3,*+8             * Branch, if no borrow           15360000
         SL    R0,FWD1                 * Decrement the first fword by 1 15370000
         SL    R0,ONEDAY               * Subtract the first fullword    15380000
         STM   R0,R1,CALCTIME          * Save the new calcted TOD clock 15390000
         B     DOAMNTH$                * Go, recalculate the TOD        15400000
         SPACE ,                                                        15410000
DOAMNTH0 EQU   *                                                        15420000
         CLC   TODTODAY,CALCTIME       * Do the days match ?            15430000
         BE    DOAMNTH4                * Yes, proceed at DOAMNTH4       15440000
         SPACE ,                                                        15450000
         CLC   DATEVAL+DD(2),DDOFFSET  * Have we reached the day ?      15460000
         BH    DOAMTH1A                * Yes, process the next month    15470000
         SPACE ,                                                        15480000
         MVC   EVNTINTD,CALCTIME       * Move the midnite date/time TOD 15490000
         B     TRYUNTIL                * Go, look for UNTIL condition   15500000
         SPACE 2                                                        15510000
DOAMNTH1 DS    0H                                                       15520000
         CLC   DATEVAL+DD(2),ZERODATE  * Is this the 1st of the month ? 15530000
         BE    DOAMNTH4                * Yes, we are on month boundary  15540000
         SPACE ,                                                        15550000
         MVC   DATEVAL+DD(2),ZERODATE  * Move a C'01' into the day fld  15560000
         B     DOAMTH1B                * Continue month processing      15570000
DOAMTH1A DS    0H                                                       15580000
         MVC   DATEVAL+DD(2),DDOFFSET  * Move a C'dd' into the day fld  15590000
DOAMTH1B DS    0H                                                       15600000
         LA    R1,DATEVAL              * Point to the month value       15610000
         LA    R0,2                    * Length of the month in chars   15620000
         BAS   R14,D2B                 * Convert the number to binary   15630000
         SPACE ,                                                        15640000
         LR    R2,R1                   * Make a copy of the MONTH numb  15650000
         LA    R1,DATEVAL+YY           * Point to the YEAR value        15660000
         LA    R0,2                    * Length of the year in chars    15670000
         BAS   R14,D2B                 * Convert the number to binary   15680000
         SPACE ,                                                        15690000
         LR    R3,R1                   * Make a copy of the YEAR numb   15700000
         LA    R2,1(,R2)               * Increment the month number     15710000
         CH    R2,HWD12                * Is the month > 12 (December)?  15720000
         BNH   DOAMNTH2                * No, don't adjust the month     15730000
         SPACE ,                                                        15740000
         LA    R2,1                    * Adjust the month to January    15750000
DOAMNTH2 EQU   *                                                        15760000
         CH    R2,HWD1                 * Are we in the month of Jan?    15770000
         BH    DOAMNTH3                * No, don't adjust the year      15780000
         SPACE ,                                                        15790000
         LA    R3,1(,R3)               * Increment the year number      15800000
         CH    R3,HWD100               * Is the year > than 100 ?       15810000
         BNH   DOAMNTH3                * No, it's not. Same century     15820000
         SPACE ,                                                        15830000
         LA    R3,0                    * Adjust the year to "00"        15840000
DOAMNTH3 EQU   *                                                        15850000
         LR    R1,R2                   * Get the month number into R1   15860000
         CVD   R1,DOUBLEWD             * Convert to decimal             15870000
         UNPK  DATEVAL(2),DOUBLEWD+6(2)  Convert the month into zone    15880000
         OI    DATEVAL+1,X'F0'         * Force the sign                 15890000
         LR    R1,R3                   * Get the month number into R1   15900000
         CVD   R1,DOUBLEWD             * Convert to decimal             15910000
         UNPK  DATEVAL+YY(2),DOUBLEWD+6(2) Convert the year into zone   15920000
         OI    DATEVAL+YY+1,X'F0'      * Force the sign                 15930000
         LA    R0,ZEROTIME             * Point R0 to EBCDIC time val    15940000
         LA    R1,DATEVAL              * Point R1 to EBCDIC date val    15950000
         BAS   R9,EBCD2TOD             * Get TOD val @ midnite that day 15960000
         SPACE ,                                                        15970000
*********************************************************************** 15980000
***                                                                 *** 15990000
***  We have to make sure the date does not end up as invalid, be-  *** 16000000
***  cause we failed to recognize a mistake like "04/31", "02/30",  *** 16010000
***  or "02/29" in a non-leap year.                                 *** 16020000
***                                                                 *** 16030000
*********************************************************************** 16040000
DOAMTH3A EQU   *                                                        16050000
         LA    R0,CALCTIME             * Point R0 to TOD timer value    16060000
         LA    R1,DATEVAL2             * Point R1 to output date value  16070000
         LA    R2,TIMEVAL2             * Point R1 to output time value  16080000
         BAS   R9,TOD2EBCD             * Convert the TOD clck to EBCDIC 16090000
         SPACE ,                                                        16100000
         CLC   DATEVAL(2),DATEVAL2     * Do the months match ?          16110000
         BE    DOAMTH3B                * Yes, date is valid then        16120000
         SPACE ,                                                        16130000
         LM    R0,R1,CALCTIME          * Get the calculated TOD clock   16140000
         SL    R1,ONEDAY+4             * Subtract the second fullword   16150000
         BC    CC2+CC3,*+8             * Branch, if no borrow           16160000
         SL    R0,FWD1                 * Decrement the first fword by 1 16170000
         SL    R0,ONEDAY               * Subtract the first fullword    16180000
         STM   R0,R1,CALCTIME          * Save the new calcted TOD clock 16190000
         B     DOAMTH3A                * Go, recalculate the TOD        16200000
         SPACE ,                                                        16210000
DOAMTH3B EQU   *                                                        16220000
         MVC   EVNTINTD,CALCTIME       * Move the midnite date/time TOD 16230000
         B     TRYUNTIL                * Go, look for UNTIL condition   16240000
         SPACE ,                                                        16250000
DOAMNTH4 EQU   *                                                        16260000
         TM    EVNTFLG2,EVNTREPT       * Time interval given ?          16270000
         BNO   DOAMNTH5                * No, it a one-time event        16280000
         SPACE ,                                                        16290000
         MVC   EVNTINTD,TODVALUE       * Move the current date/time TOD 16300000
         B     TRYUNTIL                * Go, look for UNTIL condition   16310000
         SPACE ,                                                        16320000
DOAMNTH5 EQU   *                                                        16330000
         MVC   EVNTINTD,TODTODAY       * Move the day time at midnight  16340000
         B     TRYUNTIL                * Go look for UNTIL condition    16350000
         SPACE 2                                                        16360000
DOAYEAR  DS    0H                                                       16370000
         CLC   DATEVAL(5),ZERODATE     * Is this the 1st of January ?   16380000
         BE    DOAYEAR3                * Yes, we are on month boundary  16390000
         SPACE ,                                                        16400000
         LA    R1,DATEVAL+YY           * Point to the year value        16410000
         LA    R0,2                    * Length of the year in chars    16420000
         BAS   R14,D2B                 * Convert the number to binary   16430000
         SPACE ,                                                        16440000
         LA    R1,1(,R1)               * Increment the month number     16450000
         CH    R1,HWD100               * Is the number less than 100?   16460000
         BNH   DOAYEAR2                * Yes, it is. Set up new date    16470000
         SPACE ,                                                        16480000
         LA    R1,1                    * Next is year '01', otherwise   16490000
DOAYEAR2 EQU   *                                                        16500000
         CVD   R1,DOUBLEWD             * Convert to decimal             16510000
         UNPK  DATEVAL+YY(2),DOUBLEWD+6(2)  Convert the year into zone  16520000
         OI    DATEVAL+YY+1,X'F0'      * Force the sign                 16530000
         MVC   DATEVAL(5),ZERODATE     * Move the C'01/01' into the dat 16540000
         LA    R0,ZEROTIME             * Point R0 to EBCDIC time value  16550000
         LA    R1,DATEVAL              * Point R1 to EBCDIC date value  16560000
         BAS   R9,EBCD2TOD             * Get TOD val @ midnite today    16570000
         SPACE ,                                                        16580000
         MVC   EVNTINTD,CALCTIME       * Move the current date/time TOD 16590000
         B     TRYUNTIL                * Go, look for UNTIL condition   16600000
         SPACE ,                                                        16610000
DOAYEAR3 EQU   *                                                        16620000
         TM    EVNTFLG2,EVNTREPT       * Time interval given ?          16630000
         BNO   DOAYEAR4                * No, it a one-time event        16640000
         SPACE ,                                                        16650000
         MVC   EVNTINTD,TODVALUE       * Move the current date/time TOD 16660000
         B     TRYUNTIL                * Go, look for UNTIL condition   16670000
         SPACE ,                                                        16680000
DOAYEAR4 EQU   *                                                        16690000
         MVC   EVNTINTD,TODTODAY       * Move the today's TOD at midnit 16700000
         B     TRYUNTIL                * Go, look for UNTIL condition   16710000
         SPACE 2                                                        16720000
DOTODAY  DS    0H                                                       16730000
         TM    EVNTFLG2,EVNTREPT       * Time interval given ?          16740000
         BNO   DOTODAY2                * No, it a one-time event        16750000
         SPACE ,                                                        16760000
         MVC   EVNTINTD,TODVALUE       * Move the current date/time TOD 16770000
         B     TRYUNTIL                * Go, look for UNTIL condition   16780000
         SPACE ,                                                        16790000
DOTODAY2 EQU   *                                                        16800000
         MVC   EVNTINTD,TODTODAY       * Move the today's TOD at midnit 16810000
         B     TRYUNTIL                * Go, look for UNTIL condition   16820000
         SPACE 2                                                        16830000
DOTOMORW DS    0H                                                       16840000
         LM    R0,R1,TODTODAY          * Get the current midnight TOD   16850000
         AL    R1,ONEDAY+4             * Add the second fullword        16860000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         16870000
         AL    R0,FWD1                 * Yes, add 1 to the first fullwd 16880000
         AL    R0,ONEDAY               * Add the first fullword         16890000
         STM   R0,R1,EVNTINTD          * Save the starting TOD value    16900000
         B     TRYUNTIL                * Go, look for UNTIL condition   16910000
         SPACE 2                                                        16920000
TRYUNTIL DS    0H                                                       16930000
         TM    PROGFLOW,UNTLPINC       * Did we get the date for UNTIL? 16940000
         BNO   TIPOPSET                * No, then just set up EVNTCLCK  16950000
         SPACE ,                                                        16960000
         LA    R0,RECUNTIT             * Point R0 to EBCDIC time value  16970000
         LA    R1,RECUNTID             * Point R1 to EBCDIC date value  16980000
         BAS   R9,EBCD2TOD             * Get TOD val @ midnite that day 16990000
         SPACE ,                                                        17000000
         MVC   EVNTTILL,CALCTIME       * Move the calculated TOD clock  17010000
TIPOPSET EQU   *                                                        17020000
         LM    R0,R1,EVNTINTD          * Get the interval start date    17030000
         TM    EVNTFLG1,EVNTIMM        * Is this an immediate function? 17040000
         BNO   TIPOPST2                * No, go adjust the EVNTINTD     17050000
         SPACE ,                                                        17060000
         MVC   EVNTIMTD,EVNTINTD       * Copy the calculated start time 17070000
         B     TIPTIMIN                * Join the code at TIPTIMIN      17080000
         SPACE ,                                                        17090000
TIPOPST2 EQU   *                                                        17100000
         CLC   EVNTINTD(4),TODVALUE    * Start within the same date ?   17110000
         BE    TIPTIMER                * Yes, add the time interval     17120000
         SPACE ,                                                        17130000
         LM    R2,R3,EVNTINTD          * Get the interval start date    17140000
         AL    R3,ONESEC+4             * Add 1-second interval to it    17150000
         BC    CC0+CC1,*+8             * Branch, if no carry            17160000
         AL    R2,FWD1                 * Add the carry bit on           17170000
         AL    R2,ONESEC               * Add the first fullword of 1sec 17180000
         STM   R2,R3,TESTTIME          * Save the newly calc value      17190000
         CLC   TESTTIME(4),TODVALUE    * Start within the same date ?   17200000
         BE    TIPTIMER                * Yes, add the time interval     17210000
         SPACE ,                                                        17220000
         TM    EVNTFLG2,EVNTREPT       * Time interval given ?          17230000
         BO    TIPTIMIN                * Yes, don't add the time intrvl 17240000
         SPACE ,                                                        17250000
TIPTIMER EQU   *                                                        17260000
         AL    R1,EVNTINTT+4           * Add last fword of start time   17270000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         17280000
         AL    R0,FWD1                 * Yes, add 1 to the first fullwd 17290000
         AL    R0,EVNTINTT             * Add the 1st fwrd of start time 17300000
TIPTIMIN EQU   *                                                        17310000
         STM   R0,R1,EVNTCLCK          * Save the scheduled tpop time   17320000
         SPACE 3                                                        17330000
         CLC   EVNTCLCK,TODVALUE       * Sched pop < than current time? 17340000
         BH    TIPNOCHG                * No, don't change the EVNTCLCK  17350000
         SPACE ,                                                        17360000
         OI    EVNTFLG1,EVNTFIN        * Mark event has been run before 17370000
         MVC   EVNTCLCK,TODVALUE       * Set sched pop to current time  17380000
TIPNOCHG EQU   *                                                        17390000
         ENABLE INTTYPE=NONE,MF=(E,NUCENAWA) * Disable all interrupts   17400000
         SPACE ,                                                        17410000
         STCTL C0,C0,CONTROL0          * Save the current CR0           17420000
         NI    CONTROL0+2,255-X'08'    * Turn off the Clock comp mask   17430000
         LCTL  C0,C0,CONTROL0          * Load CR0 with the new value    17440000
         BAS   R9,ADDEVENT             * Go, add the event to the list  17450000
         SPACE ,                                                        17460000
         TM    PROGFLOW,UNTLPINC       * Did we get the date for UNTIL? 17470000
         BNO   NOPREMPT                * No, no need to preempt it      17480000
         SPACE ,                                                        17490000
         CLC   EVNTCLCK,EVNTTILL       * Sched pop < than UNTIL time?   17500000
         BNH   NOPREMPT                * Yes, do not preempt this EVENT 17510000
         SPACE ,                                                        17520000
         LA    R0,1                    * Comment out the file entry     17530000
         BAS   R9,DELEVENT             * Go, delete this EVENT          17540000
         SPACE ,                                                        17550000
NOPREMPT EQU   *                                                        17560000
         XR    R0,R0                   * Mark the call as non-EXTSLIH   17570000
         L     R15,ASCHEDUL            * Point R15 to start of SCHEDULE 17580000
         BASR  R14,R15                 * Go, schedule the next event    17590000
         SPACE 2                                                        17600000
         ENABLE INTTYPE=ALL,MF=(E,NUCENAWA) Enable all interrupts back  17610000
         LM    R0,R9,SETEVSAV          * Restore registers R0 thru R9   17620000
         BR    R9                                                       17630000
         EJECT ,                                                        17640000
*********************************************************************** 17650000
***                                                                 *** 17660000
***  Each of the following labels handle processing for special     *** 17670000
***  keywords, such as S-S, WEEKDAY, TUESDAY, MONTHLY & etc. All    *** 17680000
***  appropriate fields get set for processing in RECRDMAP to pre-  *** 17690000
***  pare the information for scheduling of the EVENT blocks.       *** 17700000
***                                                                 *** 17710000
*********************************************************************** 17720000
DAILY    DS    0H                                                       17730000
WEEKDAY  DS    0H                                                       17740000
WEEKEND  DS    0H                                                       17750000
$ADAY    DS    0H                                                       17760000
MONTHLY  DS    0H                                                       17770000
YEARLY   DS    0H                                                       17780000
ADAY     DS    0H                                                       17790000
         SPACE ,                                                        17800000
         LR    R8,R9                   * Save return addr temporarily   17810000
         IC    R3,0(,R1)               * Get the actual option length   17820000
         BCTR  R3,R0                   * Decrement R3 for EXecute       17830000
         LA    R5,RECDATE              * Point R5 to RECDATE            17840000
         EX    R3,MOVDATIM             * EXecute the following:         17850000
*+++     MVC   0(*-*,R5),0(R4)         * Copy the date information      17860000
         OC    (EVNTWEEK-EVENT)+EVNTBUFF(4),2(R1) * Copy the bit flags  17870000
         OI    PROGFLOW,DATEINC        * Remember we have the date      17880000
         LR    R9,R8                   * Restore the R9 value           17890000
         BR    R9                      * Return to caller               17900000
         SPACE 2                                                        17910000
TODAY    DS    0H                                                       17920000
         LR    R8,R9                   * Save return addr temporarily   17930000
         STCK  TODVALUE                * Save the current TOD clock     17940000
         LA    R0,TODVALUE             * Point R0 to the current TOD    17950000
         LA    R1,DATEVAL              * Point R1 to date output buffer 17960000
         LA    R2,TIMEVAL              * Point R2 to time output buffer 17970000
         BAS   R9,TOD2EBCD             * Convert TOD clock to EBCDIC    17980000
         SPACE ,                                                        17990000
         MVC   RECDATE(8),DATEVAL      * Copy today's date to RECDATE   18000000
         OI    PROGFLOW,DATEINC        * Remember we have the date      18010000
         LR    R9,R8                   * Restore the R9 value           18020000
         BR    R9                      * Return to caller               18030000
         SPACE 2                                                        18040000
TOMORROW DS    0H                                                       18050000
         LR    R8,R9                   * Save return addr temporarily   18060000
         STCK  TODVALUE                * Save the current TOD clock     18070000
         LM    R0,R1,TODVALUE          * Get the TOD clock into R0-R1   18080000
         AL    R1,ONEDAY+4             * Add the clock units per 1 day  18090000
         BC    CC0+CC1,*+8             * Branch if no carry             18100000
         AL    R0,FWD1                 * Add the carry bit              18110000
         AL    R0,ONEDAY               * Add the first fullword         18120000
         STM   R0,R1,TODVALUE          * Save tomorrow's TOD value      18130000
         LA    R0,TODVALUE             * Point R0 to tomorrow's TOD     18140000
         LA    R1,DATEVAL              * Point R1 to date output buffer 18150000
         LA    R2,TIMEVAL              * Point R2 to time output buffer 18160000
         BAS   R9,TOD2EBCD             * Convert TOD clock to EBCDIC    18170000
         SPACE ,                                                        18180000
         MVC   RECDATE(8),DATEVAL      * Copy tomorrow's date 2 RECDATE 18190000
         OI    PROGFLOW,DATEINC        * Remember we have the date      18200000
         LR    R9,R8                   * Restore the R9 value           18210000
         BR    R9                      * Return to caller               18220000
         SPACE 2                                                        18230000
ATIME    DS    0H                                                       18240000
         LR    R8,R9                   * Save return addr temporarily   18250000
         IC    R3,0(,R1)               * Get the actual option length   18260000
         BCTR  R3,R0                   * Decrement R3 for EXecute       18270000
         LA    R5,RECTIME              * Point R5 to RECDATE            18280000
         EX    R3,MOVDATIM             * EXecute the following:         18290000
*+++     MVC   0(*-*,R5),0(R4)         * Copy the time information      18300000
         OC    (EVNTWEEK-EVENT)+EVNTBUFF(4),2(R1) * Copy the bit flags  18310000
         OI    PROGFLOW,TIMEINC        * Remember we have the time      18320000
         CLI   RECDATE,C' '            * Any value in RECDATE field ?   18330000
         BNE   ATIME2                  * Yes, don't set today's date    18340000
         SPACE ,                                                        18350000
         STCK  TODVALUE                * Save the current TOD clock     18360000
         LA    R0,TODVALUE             * Point R0 to the current TOD    18370000
         LA    R1,DATEVAL              * Point R1 to date output buffer 18380000
         LA    R2,TIMEVAL              * Point R2 to time output buffer 18390000
         BAS   R9,TOD2EBCD             * Convert TOD clock to EBCDIC    18400000
         SPACE ,                                                        18410000
         MVC   RECDATE(8),DATEVAL      * Copy today's date to RECDATE   18420000
         OI    PROGFLOW,DATEINC        * Remember we have the time      18430000
ATIME2   EQU   *                                                        18440000
         LR    R9,R8                   * Restore the R9 value           18450000
         BR    R9                      * Return to caller               18460000
         EJECT ,                                                        18470000
*********************************************************************** 18480000
***                                                                 *** 18490000
***  Obtain current date and time, calculate the TIMEZONE and etc.  *** 18500000
***                                                                 *** 18510000
*********************************************************************** 18520000
         SPACE ,                                                        18530000
INITIMER DS    0H                                                       18540000
         STM   R0,R9,EVENTSAV          * Save R0 through R9 temporarily 18550000
         XC    ZONEOFST(8),ZONEOFST    * Clear the zone offset to zero  18560000
         XC    TIMEZONE,TIMEZONE       * Clear the timezone value       18570000
*********************************************************************** 18580000
***  Calculate the TOD value for the start of the new century.      *** 18590000
*********************************************************************** 18600000
*+       LA    R1,CENDATIM             * Point R1 to the End Of Century 18610000
*+       LA    R0,8(,R1)               * date, & R0 to E-O-Century time 18620000
*+       BAS   R9,EBCD2TOD             * Go calculate the TOD value     18630000
         SPACE ,                                                        18640000
*+       LM    R2,R3,CALCTIME          * Put currnt time val into R2/R3 18650000
*+       AL    R3,ONESEC+4             * Add low order fullword         18660000
*+       BC    CC0+CC1,*+8             * Branch if no carry             18670000
*+       AL    R2,FWD1                 * Propagate the carry bit        18680000
*+       AL    R2,ONESEC               * Add to the high order fullword 18690000
*+       STM   R2,R3,CENTURY           * Save the value in century      18700000
         SPACE ,                                                        18710000
         LA    R1,DATETIME             * Point R1 to the DIAG 0C buffer 18720000
         DIAG  R1,R0,X'0C'             * Get the pseudo timer info      18730000
         STCK  TODVALUE                * Save the current timer info    18740000
         LA    R0,8(,R1)               * Point R0 to the time field     18750000
         BAS   R9,EBCD2TOD             * Go calculate the TOD value     18760000
         SPACE ,                                                        18770000
         LM    R2,R3,CALCTIME          * Put currnt time val into R2/R3 18780000
         SL    R3,TODVALUE+4           * Subtract low order fullword    18790000
         BC    CC2+CC3,*+8             * Branch if no borrow            18800000
         SL    R2,FWD1                 * Propagate the borrow           18810000
         SL    R2,TODVALUE             * Subtract high order            18820000
         STM   R2,R3,ZONEOFST          * Save the timezone information  18830000
         SRDA  R2,32                   * Shift zone value into R3       18840000
         LM    R0,R1,ONEHR             * Get the clock units in 1 hour  18850000
         SRDA  R0,32                   * Shift it over 32 bits into R1  18860000
         DR    R2,R1                   * Get the actual timezone        18870000
         M     R2,FWDSECHR             * Multiply R3 by 3600 seconds    18880000
         ST    R3,TIMEZONE             * Save it for future reference   18890000
         LM    R0,R9,EVENTSAV          * Restore R0 through R9          18900000
         BR    R9                      * Return to caller               18910000
         EJECT ,                                                        18920000
*********************************************************************** 18930000
***                                                                 *** 18940000
***  Scan through the linked list of EVENT blocks and select the    *** 18950000
***  one that has to be performed next. If an event is already      *** 18960000
***  scheduled, but has a higher TOD clock value than another,      *** 18970000
***  preempt that event and schedule the one with a shorter dead-   *** 18980000
***  line. Update the SCHEDULE TIMES file, if necessary.            *** 18990000
***  On entry R0 will be zero if called right after an event was    *** 19000000
***  added to the list. Non-zero if called from EXTSLIH routine.    *** 19010000
***                                                                 *** 19020000
*********************************************************************** 19030000
SCHEDULR DS    0H                                                       19040000
         STM   R0,R15,4(R13)           * Save R0 through R15 on entry   19050000
         L     R8,ANCEVENT             * Get the EVENT block anchor     19060000
         LTR   R8,R8                   * Are there any EVENT blocks ?   19070000
         BZ    NOSCHED                 * No, there is nothing to sched  19080000
         SPACE ,                                                        19090000
         LR    R4,R0                   * Save R0 in R4 temporarily      19100000
         LA    R0,WRKARLEN             * Obtain the length of work area 19110000
         CMSSTOR OBTAIN,DWORDS=(R0),SUBPOOL='USER',TYPCALL=BRANCH,     *19120000
               ERROR=ERR109SW,MSG=NO,LOC=SAME * Get the storage for it  19130000
         LR    R15,R13                 * Save R13 temporarily in R15    19140000
         LR    R13,R1                  * We have a new temp save area   19150000
         USING WRKAREA,R13             * Map it with our WRKAREA sect   19160000
         ST    R15,OLDR13              * Save prev. save area pointer   19170000
         LA    R14,4(,R1)              * Point R14 to the free storage  19180000
         LR    R15,R0                  * R15 is the length of the area  19190000
         SLL   R15,3                   * Convert the length to bytes    19200000
         S     R15,FWD4                * Subtract 4 to adjust length    19210000
         LA    R3,0                    * Force the target length to 0   19220000
         MVCL  R14,R2                  * Clear the FREE storag to zeros 19230000
         SPACE ,                                                        19240000
         LTR   R4,R4                   * Have we been calld by EXTSLIH? 19250000
         BZ    SCHEDMIN                * No, then go schedule an EVENT  19260000
         SPACE ,                                                        19270000
         L     R8,LSTEVENT             * Get the ptr to last sched evnt 19280000
         LTR   R8,R8                   * EVENT block popped or unsolic? 19290000
         BZ    SCHEDONE                * Unsolicited external interrupt 19300000
         SPACE ,                                                        19310000
         USING EVENT,R8                * Map out the EVENT control blk  19320000
         SPACE ,                                                        19330000
         STCKC TESTTIME                * Store the Clock Comparator val 19340000
         CLC   TESTTIME(5),EVNTCLCK    * Matching event ? (approximate) 19350000
         BNE   SCHEDONE                * No, we didn't cause this pop   19360000
         SPACE ,                                                        19370000
         LA    R0,EVNTCLCK             * Point R0 to the current TOD    19380000
         LA    R1,DATEVAL              * Date output from the conversn  19390000
         LA    R2,TIMEVAL              * Time output from the conversn  19400000
         BAS   R9,TOD2EBCD             * Convert the abov TOD to EBCDIC 19410000
         SPACE ,                                                        19420000
         MVC   DAYOFWKS,DAYOFWKN       * Copy the day number            19430000
         MVC   EVNTLAST,EVNTCLCK       * Save the last sched date/time  19440000
         LM    R0,R1,EVNTLAST          * Get the last timer pop TOD     19450000
         AL    R1,EVNTINTT+4           * Add the TOD time interval      19460000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         19470000
         AL    R0,FWD1                 * Yes. Add it to the 1st fullwrd 19480000
         AL    R0,EVNTINTT             * Add the first fullwords        19490000
         STM   R0,R1,TESTTIME          * Save the newly obtained value  19500000
         LA    R0,TESTTIME             * Point R0 to the TOD+EVNTINTT   19510000
         LA    R1,DATEVAL1             * Date output from the conversn  19520000
         LA    R2,TIMEVAL1             * Time output from the conversn  19530000
         BAS   R9,TOD2EBCD             * Convert the abov TOD to EBCDIC 19540000
         SPACE ,                                                        19550000
         LM    R0,R1,EVNTLAST          * Get the last timer pop TOD     19560000
         AL    R1,EVNTINTD+4           * Add the TOD date interval      19570000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         19580000
         AL    R0,FWD1                 * Yes. Add it to the 1st fullwrd 19590000
         AL    R0,EVNTINTD             * Add the first fullwords        19600000
         STM   R0,R1,TESTTIM2          * Save the newly obtained value  19610000
         LA    R0,TESTTIM2             * Point R0 to the TOD+EVNTINTD   19620000
         LA    R1,DATEVAL2             * Date output from the conversn  19630000
         LA    R2,TIMEVAL2             * Time output from the conversn  19640000
         BAS   R9,TOD2EBCD             * Convert the abov TOD to EBCDIC 19650000
         SPACE ,                                                        19660000
         LA    R0,EVNTLAST             * Point R0 to TOD of last pop    19670000
         LA    R1,DATEVAL              * Date output from the conversn  19680000
         LA    R2,TIMEVAL              * Time output from the conversn  19690000
         BAS   R9,TOD2EBCD             * Convert the abov TOD to EBCDIC 19700000
         SPACE ,                                                        19710000
         LA    R0,ZEROTIME             * Point R0 to EBCDIC time val    19720000
         LA    R1,DATEVAL              * Point R1 to EBCDIC date val    19730000
         BAS   R9,EBCD2TOD             * Get TOD val @ midnite that day 19740000
         SPACE ,                                                        19750000
         MVC   TODTODAY,CALCTIME       * Copy the TOD value at midnight 19760000
         SPACE ,                                                        19770000
         XR    R0,R0                   * Clear R0 before shift          19780000
         XR    R1,R1                   * Clear R1 for insert            19790000
         IC    R1,EVNTFLG5             * Get the index control byte     19800000
         SLDL  R0,28                   * Separate the higher nybble     19810000
         SRL   R1,26                   * And the lower nybble times 4   19820000
         LA    R1,BRANTBL2(R1)         * Point R1 to entry in brnch tbl 19830000
         BR    R1                      * Branch to that instruction     19840000
         SPACE 2                                                        19850000
BRANTBL2 DS    0H                                                       19860000
*********************************************************************** 19870000
***                                                                 *** 19880000
***  The following branches correspond to the DATETBL indexes       *** 19890000
***                                                                 *** 19900000
*********************************************************************** 19910000
         B     SCINTRVL            '0' * Date's in MM/DD/YY or +nn form 19920000
         B     SCINTRVL            '1' * Schedule the daily pop         19930000
         B     SCWEEKDA            '2' * Schedule the weekday pop       19940000
         B     SCWEEKND            '3' * Schedule the weekend pop       19950000
         B     SCINTRVL            '4' * Schedule the one day pop       19960000
         B     SCINTRVL            '5' * Schedule the monthly pop       19970000
         B     SCINTRVL            '6' * Schedule the yearly pop        19980000
         B     SCINTRVL            '7' * Schedule today's pop  MM/DD/YY 19990000
         B     SCINTRVL            '8' * Schedule tomorrow's pop MM/DD/ 20000000
         B     SCINTRVL            '9' * Schedule a single day setup    20010000
         SPACE 3                                                        20020000
SCINTRVL DS    0H                                                       20030000
         MVC   TSTINTVL,HWD16383       * Copy the max interval of days  20040000
         NC    TSTINTVL(2),EVNTFLG3    * Is this a +nnn-oriented intvl? 20050000
         BZ    SCHED00                 * No, don't change the EVNTINTD  20060000
         SPACE ,                                                        20070000
         LH    R1,TSTINTVL             * Get the +nnn interval          20080000
         L     R3,ONEDAY               * Get the 1st fwordworth of 1day 20090000
         MR    R2,R1                   * Multiply it by number of days  20100000
         L     R5,ONEDAY+4             * Get the 2nd fwordworth of 1day 20110000
         MR    R4,R1                   * Multiply it by number of days  20120000
         SLDL  R2,32                   * Shift the fullword in R3 to R2 20130000
         ALR   R3,R5                   * Add the last 2 fullwords       20140000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         20150000
         AL    R2,FWD1                 * Yes, add it onto the 1st fword 20160000
         ALR   R2,R4                   * And add the 1st 2 fullwords    20170000
         SPACE ,                                                        20180000
         LM    R0,R1,TODTODAY          * Get the TOD at today's midnite 20190000
         ALR   R1,R3                   * Add the second fullword        20200000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         20210000
         AL    R0,FWD1                 * Yes, add 1 to the first fullwd 20220000
         ALR   R0,R2                   * Add the first fullword         20230000
         STM   R0,R1,TESTTIM2          * Save next pop TOD in TESTTIM2  20240000
         B     SCWKDIFF                * Go, compute the difference     20250000
         SPACE ,                                                        20260000
SCHED00  EQU   *                                                        20270000
         TM    EVNTFLG2,EVNTREPT       * Is this time-repeatable event? 20280000
         BO    SCHED04                 * Yes, process it                20290000
         SPACE ,                                                        20300000
         TM    EVNTWEEK,EVNTREPD       * Is this date-repeatable event? 20310000
         BO    SCHED04                 * Yes, process it                20320000
         SPACE ,                                                        20330000
         TM    EVNTFLG2,EVNTIMM2       * Were we calld aftr immed func? 20340000
         BNO   SCHED0$                 * No then terminate this event   20350000
         SPACE ,                                                        20360000
         LM    R0,R1,EVNTINTD          * Get the day interval           20370000
         AL    R1,EVNTINTT+4           * Add the 2nd fword of time int  20380000
         BC    CC0+CC1,*+8             * Branch, if no carry            20390000
         AL    R0,FWD1                 * Add the carry bit              20400000
         AL    R0,EVNTINTT             * Add the 1st fword of time int  20410000
         STM   R0,R1,EVNTCLCK          * Save the new timer pop time    20420000
         NI    EVNTFLG2,255-EVNTIMM2   * Reset the immediate done bit   20430000
         CLC   EVNTCLCK,EVNTLAST       * Next pop time > than now       20440000
         BNH   SCHED01B                * No, it's not. Drop this event  20450000
         SPACE ,                                                        20460000
         L     R8,ANCEVENT             * Point R8 to the EVENT chain    20470000
         B     SCHEDMIN                * Go, schedule another event     20480000
         SPACE ,                                                        20490000
SCHED0$  EQU   *                                                        20500000
         LA    R0,1                    * We want this line commnted out 20510000
         BAS   R9,DELEVENT             * Go, delete this EVENT block    20520000
         L     R8,ANCEVENT             * Point R8 to the EVENT chain    20530000
         B     SCHEDMIN                * And schedule another EVENT     20540000
         SPACE ,                                                        20550000
SCHED01  EQU   *                                                        20560000
         LA    R0,EVNTLAST             * Point R0 to TOD of last pop    20570000
         LA    R1,DATEVAL              * Date output from the conversn  20580000
         LA    R2,TIMEVAL              * Time output from the conversn  20590000
         BAS   R9,TOD2EBCD             * Convert the abov TOD to EBCDIC 20600000
         SPACE ,                                                        20610000
         TM    EVNTFLG2,EVNTREPT       * Is this time-repeatable event? 20620000
         BNO   SCHED01A                * No, check for date-repeatable  20630000
         SPACE ,                                                        20640000
         CLC   DATEVAL1,DATEVAL        * Still within the same day ?    20650000
         BE    SCHED03                 * Yes, put in the new values     20660000
         SPACE ,                                                        20670000
         TM    EVNTFLG2,EVNTIMM2       * Was this an immediate process? 20680000
         BNO   SCHED01A                * No, then bypass the following  20690000
         SPACE ,                                                        20700000
         NI    EVNTFLG2,255-EVNTIMM2   * Reset "immed func done" bit    20710000
         MVC   EVNTCLCK,TESTTIM2       * Set the new popping time       20720000
         L     R8,ANCEVENT             * Point R8 to the EVENT chain    20730000
         B     SCHEDMIN                * Go, schedule the next event    20740000
         SPACE ,                                                        20750000
SCHED01A EQU   *                                                        20760000
         TM    EVNTWEEK,EVNTREPD       * Is the intrvl date-repeatable? 20770000
         BNO   SCHED01B                * No, then this is it ...        20780000
         SPACE ,                                                        20790000
         TM    EVNTFLG1,EVNTLIM        * Was UNTIL option specified ?   20800000
         BNO   SCHED02                 * No, recalculate the next day   20810000
         SPACE ,                                                        20820000
         CLC   TESTTIM2,EVNTTILL       * Will the next pop go over lim? 20830000
         BNH   SCHED02                 * No, recalculate the next time  20840000
         SPACE ,                                                        20850000
SCHED01B EQU   *                                                        20860000
         BAS   R9,UPDTIMES             * Go, update SCHEDULE TIMES file 20870000
         SPACE ,                                                        20880000
         LA    R0,1                    * We want this line commnted out 20890000
         BAS   R9,DELEVENT             * Go, delete this EVENT block    20900000
         SPACE ,                                                        20910000
         L     R8,ANCEVENT             * Point R8 to the EVENT chain    20920000
         B     SCHEDMIN                * And schedule another EVENT     20930000
         SPACE ,                                                        20940000
SCHED02  EQU   *                                                        20950000
         LA    R0,ZEROTIME             * Point R0 to EBCDIC time value  20960000
         LA    R1,DATEVAL              * Point R1 to EBCDIC date value  20970000
         BAS   R9,EBCD2TOD             * Get TOD val @ midnite that day 20980000
         SPACE ,                                                        20990000
         LM    R0,R1,CALCTIME          * Get the start of the day TOD   21000000
         AL    R1,EVNTINTD+4           * Add the TOD date interval      21010000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         21020000
         AL    R0,FWD1                 * Yes. Add it to the 1st fullwrd 21030000
         AL    R0,EVNTINTD             * Add the first fullwords        21040000
         TM    EVNTFLG2,EVNTREPT       * Is this time-repeatable event? 21050000
         BO    SCHED02A                * No, yes, do not add EVNTINTT   21060000
         SPACE ,                                                        21070000
         AL    R1,EVNTINTT+4           * Add the TOD time interval      21080000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         21090000
         AL    R0,FWD1                 * Yes. Add it to the 1st fullwrd 21100000
         AL    R0,EVNTINTT             * Add the first fullwords        21110000
SCHED02A EQU   *                                                        21120000
         STM   R0,R1,EVNTCLCK          * Put in the new TOD pop value   21130000
         BAS   R9,UPDTIMES             * Go, update SCHEDULE TIMES file 21140000
         SPACE ,                                                        21150000
         L     R8,ANCEVENT             * Point R8 to the EVENT chain    21160000
         B     SCHEDMIN                * And schedule another EVENT     21170000
         SPACE ,                                                        21180000
SCHED03  EQU   *                                                        21190000
         MVC   EVNTCLCK,TESTTIME       * Put in the new TOD pop value   21200000
         TM    EVNTFLG1,EVNTLIM        * Was UNTIL option specified ?   21210000
         BNO   SCHED03A                * No, proceed without the limit  21220000
         SPACE ,                                                        21230000
         CLC   EVNTCLCK,EVNTTILL       * Will the next pop go over lim? 21240000
         BNH   SCHED03A                * No, have not reached the limit 21250000
         SPACE ,                                                        21260000
         BAS   R9,UPDTIMES             * Go, update SCHEDULE TIMES file 21270000
         SPACE ,                                                        21280000
         LA    R0,1                    * We want this line commnted out 21290000
         BAS   R9,DELEVENT             * Go, delete this EVENT block    21300000
         L     R8,ANCEVENT             * Point R8 to the EVENT chain    21310000
         B     SCHEDMIN                * And schedule another EVENT     21320000
         SPACE ,                                                        21330000
SCHED03A EQU   *                                                        21340000
         BAS   R9,UPDTIMES             * Go, update SCHEDULE TIMES file 21350000
         SPACE ,                                                        21360000
         L     R8,ANCEVENT             * Point R8 to the EVENT chain    21370000
         B     SCHEDMIN                * And schedule another EVENT     21380000
         SPACE 3                                                        21390000
SCHED04  EQU   *                                                        21400000
         XR    R0,R0                   * Clear R0 before shift          21410000
         XR    R1,R1                   * Clear R1 for insert            21420000
         IC    R1,EVNTFLG5             * Get the index control byte     21430000
         SLDL  R0,28                   * Separate the higher nybble     21440000
         SRL   R1,28                   * And the lower nybble           21450000
         CH    R1,NULL                 * Is this a particular day int?  21460000
         BE    SCH1DAY                 * Yes, recalc the TOD intervl    21470000
         SPACE ,                                                        21480000
         CH    R1,HWD1                 * Is this a daily interval?      21490000
         BE    SCHDAILY                * Yes, recalc the TOD intervl    21500000
         SPACE ,                                                        21510000
         CH    R1,HWD4                 * Is this a 7 day interval?      21520000
         BE    SCH7DAYS                * Yes, recalc the TOD intervl    21530000
         SPACE ,                                                        21540000
         CH    R1,HWD9                 * Is this a 7 day interval?      21550000
         BE    SCH7DAYS                * Yes, recalc the TOD intervl    21560000
         SPACE ,                                                        21570000
         CH    R1,HWD5                 * Is this a monthly interval?    21580000
         BE    SCHMONTH                * Yes, recalc the TOD intervl    21590000
         SPACE ,                                                        21600000
         CH    R1,HWD6                 * Is this a yearly interval?     21610000
         BE    SCHYEAR                 * Yes, recalc the TOD intervl    21620000
         SPACE ,                                                        21630000
         B     SCHED01                 * No interval recalc neccessary  21640000
         SPACE ,                                                        21650000
SCH1DAY  EQU   *                                                        21660000
         TM    EVNTFLG2,EVNTIMM3       * Was this an immediate functn ? 21670000
         BNO   SCHED01                 * No, then don't change the INTD 21680000
         SPACE ,                                                        21690000
         CLC   EVNTIMTD,NULL           * Is there a saved EVNTIMTD val? 21700000
         BE    SCHED01                 * No, then don't change the INTD 21710000
         SPACE ,                                                        21720000
         LA    R0,TESTTIME             * Point R0 to TOD of next pop    21730000
         LA    R1,DATEVAL3             * Date output from the conversn  21740000
         LA    R2,TIMEVAL3             * Time output from the conversn  21750000
         BAS   R9,TOD2EBCD             * Convert the abov TOD to EBCDIC 21760000
         SPACE ,                                                        21770000
         CLC   DATEVAL3,DATEVAL        * Are we within the same date ?  21780000
         BE    SCHED01                 * Yes, we are. Join the code     21790000
         SPACE ,                                                        21800000
         LA    R0,EVNTIMTD             * Point R0 to TOD in EVNTIMTD    21810000
         LA    R1,DATEVAL3             * Date output from the conversn  21820000
         LA    R2,TIMEVAL3             * Time output from the conversn  21830000
         BAS   R9,TOD2EBCD             * Convert the abov TOD to EBCDIC 21840000
         SPACE ,                                                        21850000
         LA    R0,ZEROTIME             * Point R0 to EBCDIC time val    21860000
         LA    R1,DATEVAL3             * Point R1 to EBCDIC date val    21870000
         BAS   R9,EBCD2TOD             * Get TOD val @ midnite that day 21880000
         SPACE ,                                                        21890000
         CLC   CALCTIME,TODTODAY       * Does EVNTIMTD start today ?    21900000
         BNH   SCHED01B                * Yes, then we are done          21910000
         SPACE ,                                                        21920000
         MVC   EVNTINTD,CALCTIME       * Copy the next sched timer pop  21930000
         XC    EVNTIMTD,EVNTIMTD       * Clr the fld from where copied  21940000
         MVC   TESTTIME,EVNTINTD       * Copy the EVNTINTD to TESTTIME  21950000
         LA    R0,TESTTIME             * Point R0 to the TOD+EVNTINTT   21960000
         LA    R1,DATEVAL1             * Date output from the conversn  21970000
         LA    R2,TIMEVAL1             * Time output from the conversn  21980000
         BAS   R9,TOD2EBCD             * Convert the abov TOD to EBCDIC 21990000
         SPACE ,                                                        22000000
         MVC   TESTTIM2,EVNTINTD       * Copy the EVNTINTD to TESTTIM2  22010000
         LA    R0,TESTTIM2             * Point R0 to the TOD+EVNTINTD   22020000
         LA    R1,DATEVAL2             * Date output from the conversn  22030000
         LA    R2,TIMEVAL2             * Time output from the conversn  22040000
         BAS   R9,TOD2EBCD             * Convert the abov TOD to EBCDIC 22050000
         SPACE ,                                                        22060000
         B     SCHED01                 * Go, set up the next timer pop  22070000
         SPACE 2                                                        22080000
SCHDAILY EQU   *                                                        22090000
         TM    EVNTFLG2,EVNTREPT       * Is this time-repeatable event? 22100000
         BO    SCHDAIL1                * No, check for date-repeatable  22110000
         SPACE ,                                                        22120000
         LM    R0,R1,TODTODAY          * Get prev computed midnight TOD 22130000
         AL    R1,ONEDAY+4             * Add the second fullwd of 1 day 22140000
         BC    CC0+CC1,*+8             * Branch, if no carry            22150000
         AL    R0,FWD1                 * Add the carry bit on           22160000
         AL    R0,ONEDAY               * Add the value of 1 day TOD     22170000
         STM   R0,R1,TESTTIM2          * Save the new value in TESTTIM2 22180000
         MVC   EVNTINTD,ONEDAY         * Move the value of 1 day TOD    22190000
         SPACE ,                                                        22200000
         B     SCHED01                 * Join the common code           22210000
         SPACE ,                                                        22220000
SCHDAIL1 EQU   *                                                        22230000
         LM    R0,R1,EVNTLAST          * Get the TOD value at last pop  22240000
         AL    R1,EVNTINTT+4           * Add the second fullword        22250000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         22260000
         AL    R0,FWD1                 * Yes, add 1 to the first fullwd 22270000
         AL    R0,EVNTINTT             * Add the first fullword         22280000
         STM   R0,R1,TESTTIM2          * Save next pop TOD in TESTTIM2  22290000
         B     SCWKDIFF                * Go, compute the difference     22300000
         SPACE ,                                                        22310000
SCH7DAYS EQU   *                                                        22320000
         XR    R1,R1                   * Clear R1 for insert            22330000
         IC    R1,DAYOFWKN             * Get the day's number           22340000
         STCK  TODVALUE                * Save the current TOD clock val 22350000
         CR    R0,R1                   * Is this the same day of week ? 22360000
         BE    SCHADAY4                * Yes, it is; go set the intervl 22370000
         BL    SCHADAY2                * Yes, it is; go set the intervl 22380000
         SPACE ,                                                        22390000
         SR    R0,R1                   * Calc num of days till that day 22400000
         LR    R2,R0                   * Put the day multiplier in R2   22410000
         B     SCHADAY3                * Joint the code at SCHADAY3     22420000
         SPACE ,                                                        22430000
SCHADAY2 EQU   *                                                        22440000
         LA    R2,7                    * Number of days in a week       22450000
         SR    R2,R1                   * Number of days till Monday     22460000
         AR    R2,R0                   * Number of day till that day    22470000
SCHADAY3 EQU   *                                                        22480000
         L     R1,ONEDAY               * Get the TOD val for 1 day fwd1 22490000
         L     R5,ONEDAY+4             * Get the TOD val for 1 day fwd2 22500000
         MR    R4,R2                   * Calculate TOD till Saturday    22510000
         MR    R0,R2                   * Calculate TOD till Saturday    22520000
         ALR   R1,R4                   * Get new TOD val (1st fullword) 22530000
         LR    R0,R1                   * Reload the value into R0       22540000
         LR    R1,R5                   * Get new TOD val (2nd fullword) 22550000
         SPACE ,                                                        22560000
         STM   R0,R1,EVNTINTD          * Save the new day interval val  22570000
         AL    R1,TODTODAY+4           * Add the second fullword of TOD 22580000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         22590000
         AL    R0,FWD1                 * Yes, add 1 to the first fullwd 22600000
         AL    R0,TODTODAY             * Add the first fullword         22610000
         STM   R0,R1,TESTTIM2          * Save the new value in TESTTIM2 22620000
         B     SCHED01                 * Join the common code           22630000
         SPACE ,                                                        22640000
SCHADAY4 EQU   *                                                        22650000
         LA    R2,7                    * Force the days to 7            22660000
         TM    EVNTFLG2,EVNTIMM2       * Was the "imm func done" on ?   22670000
         BNO   SCHADAY3                * No, then set the 7-day intrvl  22680000
         SPACE ,                                                        22690000
         NI    EVNTFLG2,255-EVNTIMM2   * Turn off the "immed done func" 22700000
         MVC   TESTTIM2,TODTODAY       * Copy the today's midnight TOD  22710000
         XC    EVNTINTD,EVNTINTD       * Clear the day interval         22720000
         B     SCHED01                 * Join the common code           22730000
         SPACE 3                                                        22740000
SCHMONTH EQU   *                                                        22750000
         LA    R1,DATEVAL              * Point to the month value       22760000
         LA    R0,2                    * Length of the month in chars   22770000
         BAS   R14,D2B                 * Convert the number to binary   22780000
         SPACE ,                                                        22790000
         LA    R1,1(,R1)               * Increment the month number     22800000
         CH    R1,HWD12                * Is the number less than 12 ?   22810000
         BNH   SCHMNTH2                * Yes, it is. Set up new date    22820000
         SPACE ,                                                        22830000
         LA    R1,1                    * Next is January, otherwise     22840000
SCHMNTH2 EQU   *                                                        22850000
         CVD   R1,DOUBLEWD             * Convert to decimal             22860000
         UNPK  DATEVAL(2),DOUBLEWD+6(2)  Convert the month into zoned   22870000
         OI    DATEVAL+1,X'F0'         * Force the sign                 22880000
         C     R1,FWD1                 * Is this the month of January ? 22890000
         BNE   SCHMNT3A                * No, don't change the year      22900000
         SPACE ,                                                        22910000
         LA    R1,DATEVAL+YY           * Point to the year value        22920000
         LA    R0,2                    * Length of the year in chars    22930000
         BAS   R14,D2B                 * Convert the number to binary   22940000
         SPACE ,                                                        22950000
         LA    R1,1(,R1)               * Increment the month number     22960000
         CH    R1,HWD100               * Is the number less than 100 ?  22970000
         BNH   SCHMNTH3                * Yes, it is. Set up new date    22980000
         SPACE ,                                                        22990000
         LA    R1,0                    * No, gotta be year 100          23000000
SCHMNTH3 EQU   *                                                        23010000
         CVD   R1,DOUBLEWD             * Convert to decimal             23020000
         UNPK  DATEVAL+YY(2),DOUBLEWD+6(2) Convert the month into zone  23030000
         OI    DATEVAL+YY+1,X'F0'      * Force the sign                 23040000
SCHMNT3A EQU   *                                                        23050000
         TM    EVNTFLG1,EVNTADDD       * Is this a "==/DD" event type?  23060000
         BNO   SCHMNTH4                * No, proceed with 1st of month  23070000
         SPACE ,                                                        23080000
         MVC   DATEVAL+DD(2),EVNTOFFS  * Force the day to 'DD' in ==/DD 23090000
         B     SCHMNTH5                * Skip the next move             23100000
SCHMNTH4 EQU   *                                                        23110000
         MVC   DATEVAL+DD(2),=C'01'    * Force the day to '01'          23120000
SCHMNTH5 EQU   *                                                        23130000
         LA    R0,ZEROTIME             * Point R0 to EBCDIC time val    23140000
         LA    R1,DATEVAL              * Point R1 to EBCDIC date val    23150000
         BAS   R9,EBCD2TOD             * Get TOD val @ midnite that day 23160000
         SPACE ,                                                        23170000
*********************************************************************** 23180000
***                                                                 *** 23190000
***  We have to make sure the date does not end up as invalid, be-  *** 23200000
***  cause we failed to recognize a mistake like "04/31", "02/30",  *** 23210000
***  or "02/29" in a non-leap year.                                 *** 23220000
***                                                                 *** 23230000
*********************************************************************** 23240000
SCHMTH5A EQU   *                                                        23250000
         LA    R0,CALCTIME             * Point R0 to TOD timer value    23260000
         LA    R1,DATEVAL3             * Point R1 to output date value  23270000
         LA    R2,TIMEVAL3             * Point R1 to output time value  23280000
         BAS   R9,TOD2EBCD             * Convert the TOD clck to EBCDIC 23290000
         SPACE ,                                                        23300000
         CLC   DATEVAL(2),DATEVAL3     * Do the months match ?          23310000
         BE    SCHMTH5B                * Yes, date is valid then        23320000
         SPACE ,                                                        23330000
         LM    R0,R1,CALCTIME          * Get the calculated TOD clock   23340000
         SL    R1,ONEDAY+4             * Subtract the second fullword   23350000
         BC    CC2+CC3,*+8             * Branch, if no borrow           23360000
         SL    R0,FWD1                 * Decrement the first fword by 1 23370000
         SL    R0,ONEDAY               * Subtract the first fullword    23380000
         STM   R0,R1,CALCTIME          * Save the new calcted TOD clock 23390000
         B     SCHMTH5A                * Go, recalculate the TOD        23400000
         SPACE ,                                                        23410000
SCHMTH5B EQU   *                                                        23420000
         MVC   TESTTIM2,CALCTIME       * Save the previously comptd TOD 23430000
         B     SCWKDIFF                * Go, join the common code       23440000
         SPACE 2                                                        23450000
SCHYEAR  DS    0H                                                       23460000
         LA    R1,DATEVAL+YY           * Point to the year value        23470000
         LA    R0,2                    * Length of the year in chars    23480000
         BAS   R14,D2B                 * Convert the number to binary   23490000
         SPACE ,                                                        23500000
         LA    R1,1(,R1)               * Increment the month number     23510000
         CH    R1,HWD100               * Is the number less than 100?   23520000
         BNH   SCHYEAR2                * Yes, it is. Set up new date    23530000
         SPACE ,                                                        23540000
         LA    R1,1                    * Next is year '01', otherwise   23550000
SCHYEAR2 EQU   *                                                        23560000
         CVD   R1,DOUBLEWD             * Convert to decimal             23570000
         UNPK  DATEVAL+YY(2),DOUBLEWD+6(2)  Convert the year into zoned 23580000
         OI    DATEVAL+YY+1,X'F0'      * Force the sign                 23590000
         MVC   DATEVAL(5),ZERODATE     * Move the C'01/01' into the dat 23600000
         LA    R0,ZEROTIME             * Point R0 to EBCDIC time value  23610000
         LA    R1,DATEVAL              * Point R1 to EBCDIC date value  23620000
         BAS   R9,EBCD2TOD             * Get TOD val @ midnite that day 23630000
         SPACE ,                                                        23640000
         MVC   TESTTIM2,CALCTIME       * Save the previously comptd TOD 23650000
         B     SCWKDIFF                * Go, compute the TOD difference 23660000
         SPACE 2                                                        23670000
SCWEEKDA DS    0H                                                       23680000
         XR    R1,R1                   * Clear R1 for insert            23690000
         IC    R1,DAYOFWKN             * Get the day's number           23700000
         CH    R1,HWD7                 * Is this a Sunday ?             23710000
         BE    SCWEEKD0                * Yes, set same one day interval 23720000
         SPACE ,                                                        23730000
         CH    R1,HWD4                 * Is this a weekday before Fri?  23740000
         BH    SCWEEKD1                * No, do some EVNTINTD adjustmts 23750000
         SPACE ,                                                        23760000
         TM    EVNTFLG2,EVNTREPT       * Is this time-repeatable event? 23770000
         BNO   SCWEEKD0                * No, go calc the next day pop   23780000
         SPACE ,                                                        23790000
SCWEEKD$ EQU   *                                                        23800000
         LM    R0,R1,EVNTLAST          * Get the TOD value at last pop  23810000
         AL    R1,EVNTINTT+4           * Add the second fullword        23820000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         23830000
         AL    R0,FWD1                 * Yes, add 1 to the first fullwd 23840000
         AL    R0,EVNTINTT             * Add the first fullword         23850000
         STM   R0,R1,TESTTIM2          * Save next pop TOD in TESTTIM2  23860000
         B     SCWKDIFF                * Go, compute the difference     23870000
         SPACE ,                                                        23880000
SCWEEKD0 EQU   *                                                        23890000
         LM    R0,R1,TODTODAY          * Get the current midnight TOD   23900000
         AL    R1,ONEDAY+4             * Add the second fullword        23910000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         23920000
         AL    R0,FWD1                 * Yes, add 1 to the first fullwd 23930000
         AL    R0,ONEDAY               * Add the first fullword         23940000
         STM   R0,R1,TESTTIM2          * Save next pop TOD in TESTTIM2  23950000
         B     SCWKDIFF                * Go, compute the difference     23960000
         SPACE ,                                                        23970000
SCWEEKD1 EQU   *                                                        23980000
         SPACE ,                                                        23990000
         SH    R1,HWD5                 * Determine if in Friday or Sat  24000000
         BZ    SCWEEKD2                * If = 0 then today is Friday    24010000
         SPACE ,                                                        24020000
         LM    R0,R1,TODTODAY          * Get the current midnight TOD   24030000
         AL    R1,TWODAYS+4            * Add the second fullword        24040000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         24050000
         AL    R0,FWD1                 * Yes, add 1 to the first fullwd 24060000
         AL    R0,TWODAYS              * Add the first fullword         24070000
         STM   R0,R1,TESTTIM2          * Save next pop TOD in TESTTIM2  24080000
         B     SCWKDIFF                * Go, compute the difference     24090000
         SPACE ,                                                        24100000
SCWEEKD2 EQU   *                                                        24110000
         LM    R0,R1,TODTODAY          * Get the current midnight TOD   24120000
         AL    R1,DAYS3+4              * Add the second fullword        24130000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         24140000
         AL    R0,FWD1                 * Yes, add 1 to the first fullwd 24150000
         AL    R0,DAYS3                * Add the first fullword         24160000
         STM   R0,R1,TESTTIM2          * Save next pop TOD in TESTTIM2  24170000
         B     SCWKDIFF                * Go, compute the difference     24180000
         SPACE 2                                                        24190000
SCWEEKND DS    0H                                                       24200000
         XR    R1,R1                   * Clear R1 for insert            24210000
         IC    R1,DAYOFWKN             * Get the day's number           24220000
         CH    R1,HWD6                 * is this a Saturday ?           24230000
         BE    SCWKEND3                * Yes, process it accordingly    24240000
         SPACE ,                                                        24250000
         CH    R1,HWD7                 * Is this a Sunday ?             24260000
         BNE   SCWKEND1                * No, it's not                   24270000
         SPACE ,                                                        24280000
         LM    R0,R1,TODTODAY          * Get the current midnight TOD   24290000
         AL    R1,DAYS6+4              * Add the second fullword        24300000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         24310000
         AL    R0,FWD1                 * Yes, add 1 to the first fullwd 24320000
         AL    R0,DAYS6                * Add the first fullword         24330000
         STM   R0,R1,TESTTIM2          * Save next pop TOD in TESTTIM2  24340000
         B     SCWKDIFF                * Go, compute the difference     24350000
         SPACE ,                                                        24360000
SCWKEND1 EQU   *                                                        24370000
         LA    R2,6                    * Closest weekend day is Saturda 24380000
         SR    R2,R1                   * Get the num of days till Satur 24390000
         BNZ   SCWKEND2                * If non-zero, not a Saturday    24400000
         SPACE ,                                                        24410000
         LA    R2,1                    * 1 day till Sun (today is Sat)  24420000
SCWKEND2 EQU   *                                                        24430000
         L     R1,ONEDAY               * Get the TOD val for 1 day fwd1 24440000
         L     R5,ONEDAY+4             * Get the TOD val for 1 day fwd2 24450000
         MR    R4,R2                   * Calculate TOD till Saturday    24460000
         MR    R0,R2                   * Calculate TOD till Saturday    24470000
         ALR   R1,R4                   * Get new TOD val (1st fullword) 24480000
         LR    R0,R1                   * Reload the value into R0       24490000
         LR    R1,R5                   * Get new TOD val (2nd fullword) 24500000
         SPACE ,                                                        24510000
         AL    R1,TODTODAY+4           * Add the second fullword of TOD 24520000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         24530000
         AL    R0,FWD1                 * Yes, add 1 to the first fullwd 24540000
         AL    R0,TODTODAY             * Add the first fullword         24550000
         STM   R0,R1,TESTTIM2          * Save the starting TOD value    24560000
         B     SCWKDIFF                * Go, compute the difference     24570000
         SPACE ,                                                        24580000
SCWKEND3 EQU   *                                                        24590000
         LM    R0,R1,TODTODAY          * Get the current midnight TOD   24600000
         AL    R1,ONEDAY+4             * Add the second fullword        24610000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         24620000
         AL    R0,FWD1                 * Yes, add 1 to the first fullwd 24630000
         AL    R0,ONEDAY               * Add the first fullword         24640000
         STM   R0,R1,TESTTIM2          * Save next pop TOD in TESTTIM2  24650000
         SPACE ,                                                        24660000
         TM    EVNTFLG2,EVNTREPT       * Is this time-repeatable event? 24670000
         BNO   SCWKDIFF                * No, go compute the time diff   24680000
         SPACE ,                                                        24690000
         LM    R0,R1,EVNTLAST          * Get the TOD value at last pop  24700000
         AL    R1,EVNTINTT+4           * Add the second fullword        24710000
         BC    CC0+CC1,*+8             * Is there a carry bit ?         24720000
         AL    R0,FWD1                 * Yes, add 1 to the first fullwd 24730000
         AL    R0,EVNTINTT             * Add the first fullword         24740000
         STM   R0,R1,TESTTIM2          * Save next pop TOD in TESTTIM2  24750000
         B     SCWKDIFF                * Go, compute the difference     24760000
         SPACE 2                                                        24770000
SCWKDIFF EQU   *                                                        24780000
         LM    R0,R1,TESTTIM2          * Get the calculated TOD pop     24790000
         SL    R1,TODTODAY+4           * Subtract the 2nd fullword      24800000
         BC    CC2+CC3,*+8             * Branch if no borrow            24810000
         SL    R0,FWD1                 * Yes, subtract from 1st fullwrd 24820000
         SL    R0,TODTODAY             * Subtract the first fullword    24830000
         STM   R0,R1,EVNTINTD          * Save it in the EVNTINTD        24840000
         B     SCHED01                 * Go, join the common code       24850000
         SPACE 2                                                        24860000
SCHEDMIN EQU   *                                                        24870000
         LTR   R8,R8                   * Is there an EVENT block ptr ?  24880000
         BZ    SCHEDONE                * No, there is nothing to sched  24890000
         SPACE ,                                                        24900000
         LR    R0,R8                   * Save the EVENT control blk ptr 24910000
         TM    EVNTFLG1,EVNTIMM        * Should we run it immediately ? 24920000
         BNO   SCHDELAY                * No, it has some delay interval 24930000
         SPACE ,                                                        24940000
         STCK  EVNTCLCK                * Save the new EVENT pop clock   24950000
         B     SCHEDNUL                * Go, schedule this event        24960000
         SPACE ,                                                        24970000
SCHDELAY EQU   *                                                        24980000
         MVC   MINCLOCK,EVNTCLCK       * This may be the closest TOD    24990000
SCHEDNXT EQU   *                                                        25000000
         L     R8,EVNTPREV             * Point to the prev list item    25010000
         LTR   R8,R8                   * Is there a pointer?            25020000
         BZ    SCHEDNUL                * No, this must be the last item 25030000
         SPACE ,                                                        25040000
         TM    EVNTFLG1,EVNTIMM        * Should we run it immediately ? 25050000
         BO    SCHEDMIN                * Yes, adjust the TOD pop clock  25060000
         SPACE ,                                                        25070000
         CLC   MINCLOCK,EVNTCLCK       * Was the last pop TOD smaller ? 25080000
         BNH   SCHEDNXT                * Yes, look at the next EVENT    25090000
         SPACE ,                                                        25100000
         B     SCHEDMIN                * We found a new smallest TOD    25110000
         SPACE ,                                                        25120000
SCHEDNUL EQU   *                                                        25130000
         L     R8,LSTEVENT             * Get the last sched EVENT ptr   25140000
         LTR   R8,R8                   * Was there anything scheduled?  25150000
         BZ    SCHED20                 * No, this is the first one      25160000
         SPACE ,                                                        25170000
         NI    EVNTFLG1,255-EVNTSCH    * Turn off the "scheduled" bit   25180000
SCHED20  EQU   *                                                        25190000
         LR    R8,R0                   * Get the new EVENT block ptr    25200000
         OI    EVNTFLG1,EVNTSCH        * Turn on the "scheduled" bit    25210000
         ST    R8,LSTEVENT             * Save the new sched event ptr   25220000
         SCKC  EVNTCLCK                * Set new clck compar pop value  25230000
SCHEDONE EQU   *                                                        25240000
         LA    R0,WRKARLEN             * Get work area length in dwords 25250000
         LR    R2,R13                  * And its address for release    25260000
         L     R13,OLDR13              * Get old R13 before it is gone  25270000
         CMSSTOR RELEASE,DWORDS=(R0),ADDR=(R2),TYPCALL=BRANCH           25280000
NOSCHED  EQU   *                                                        25290000
         LM    R0,R15,4(R13)           * Restor caller's R0 through R15 25300000
         BR    R14                     * Return to caller               25310000
         EJECT ,                                                        25320000
*********************************************************************** 25330000
***                                                                 *** 25340000
***  Update "SCHEDULE TIMES" file, if necessary with new date/time  *** 25350000
***                                                                 *** 25360000
*********************************************************************** 25370000
*                                                                       25380000
*   Register usage:                                                     25390000
*                                                                       25400000
*       R8  - Current EVENT block pointer                               25410000
*       R9  - Return address of the caller                              25420000
*                                                                       25430000
UPDTIMES DS    0H                                                       25440000
         STM   R8,R9,CVTSAVER          * Save the registers             25450000
         TM    PROGLOBL,NOFILEOP       * Was 'NOFILE' option supplied?  25460000
         BO    UPDFAILD                * Yes, then don't update the fil 25470000
         SPACE ,                                                        25480000
         LA    R2,RECRDMAP             * Point R2 to the buffer         25490000
         LA    R3,TIMFNAME             * Point to the file identifier   25500000
         LH    R4,EVNTIDEN             * Get the event identification   25510000
         LA    R5,RECMAPLN             * Get the maximum record length  25520000
         MVI   RECRDMAP,C' '           * Move a blank into the I/O buff 25530000
         MVC   RECRDMAP+1(RECOPERL),RECRDMAP * Clear the operation buff 25540000
         MVC   RECDATA(L'RECDATA),RECDATA-1  * Clear the data portion   25550000
         FSREAD (R3),FSCB=INPUTDS,ERROR=UPDFAILD,BUFFER=(R2),RECNO=(R4)*25560000
               ,NOREC=1,BSIZE=(R5),FORM=E * Read a record from the file 25570000
         LR    R5,R0                   * Get the new record length      25580000
         LA    R0,EVNTLAST             * Point R0 to TOD of last pop    25590000
         LA    R1,RECLDATE             * Date output from the conversn  25600000
         LA    R2,RECLTIME             * Time output from the conversn  25610000
         BAS   R9,TOD2EBCD             * Convert the abov TOD to EBCDIC 25620000
         SPACE ,                                                        25630000
         LA    R2,RECRDMAP             * Point R2 to the buffer         25640000
         FSWRITE (R3),FSCB=OUTPUTDS,ERROR=UPDFAILD,BUFFER=(R2),        *25650000
               BSIZE=(R5),NOREC=1,RECNO=(R4),RECFM=V,FORM=E * Write rec 25660000
UPDFAILD EQU   *                                                        25670000
         LM    R8,R9,CVTSAVER          * Restore the registers          25680000
         BR    R9                      * Return to caller               25690000
         EJECT ,                                                        25700000
*********************************************************************** 25710000
***                                                                 *** 25720000
***  Add an event to the linked list of events anchored at ANCEVENT *** 25730000
***                                                                 *** 25740000
*********************************************************************** 25750000
*                                                                       25760000
*   Register usage:                                                     25770000
*                                                                       25780000
*       R8  - EVENT block pointer (to be added to linked list)          25790000
*       R9  - Return address of the caller                              25800000
*                                                                       25810000
ADDEVENT DS    0H                                                       25820000
         STM   R8,R9,CVTSAVER          * Save the registers             25830000
         CLC   ANCEVENT,NULL           * Do we have an anchor present?  25840000
         BNZ   ADDEVNT2                * Yes, then add it to the list   25850000
         SPACE ,                                                        25860000
         ST    R8,ANCEVENT             * Save the EVENT ptr at anchor   25870000
         B     ADDEVNTX                * Go, return to caller           25880000
         SPACE ,                                                        25890000
ADDEVNT2 EQU   *                                                        25900000
         LR    R9,R8                   * Save R8 in R9 temporarily      25910000
         L     R8,ANCEVENT             * Get the current EVENT anchor   25920000
ADDEVNT3 EQU   *                                                        25930000
         CLC   EVNTPREV,NULL           * Is there a previous event ptr? 25940000
         BZ    ADDEVNT4                * No, add the event here         25950000
         SPACE ,                                                        25960000
         L     R8,EVNTPREV             * Get the pointer to prev. EVENT 25970000
         B     ADDEVNT3                * Go, loop until the last item   25980000
         SPACE ,                                                        25990000
ADDEVNT4 EQU   *                                                        26000000
         ST    R9,EVNTPREV             * Save the new EVENT prev. ptr   26010000
ADDEVNTX EQU   *                                                        26020000
         LM    R8,R9,CVTSAVER          * Restore the registers          26030000
         BR    R9                      * Return to caller               26040000
         EJECT ,                                                        26050000
*********************************************************************** 26060000
***                                                                 *** 26070000
***  Delete an event from the linked list anchored at ANCEVENT.     *** 26080000
***                                                                 *** 26090000
*********************************************************************** 26100000
*                                                                       26110000
*   Register usage:                                                     26120000
*                                                                       26130000
*       R0  - non-zero if the the event is to be commented out in file  26140000
*       R8  - EVENT block pointer (to be deleted from the linked list)  26150000
*       R9  - Return address of the caller                              26160000
*                                                                       26170000
DELEVENT DS    0H                                                       26180000
         STM   R0,R9,CVTSAVER          * Save the registers             26190000
         C     R8,ANCEVENT             * Is this EVENT the last added?  26200000
         BNE   DELEVNT2                * No, then scan through the list 26210000
         SPACE ,                                                        26220000
         L     R9,EVNTPREV             * Get the previous EVENT pointer 26230000
         ST    R9,ANCEVENT             * Place the pointer into anchor  26240000
         B     DELEVNTR                * Go, release the storage        26250000
         SPACE ,                                                        26260000
DELEVNT2 EQU   *                                                        26270000
         L     R8,ANCEVENT             * Get the event anchor pointer   26280000
DELEVNT3 EQU   *                                                        26290000
         LR    R9,R8                   * Save R8 in R9 temporarily      26300000
         L     R8,EVNTPREV             * Point to the previous event    26310000
         LTR   R8,R8                   * Is there another item ?        26320000
         BZ    DELEVNTX                * No, can't delete it, then      26330000
         SPACE ,                                                        26340000
         C     R8,CVTSAVER+8*4         * Is the block to be deleted?    26350000
         BNE   DELEVNT3                * Yes, scan for the next one     26360000
         SPACE ,                                                        26370000
         L     R8,EVNTPREV             * Get the previous EVENT pointer 26380000
         ST    R8,0(R9)                * Delete the EVENT block         26390000
         L     R8,CVTSAVER+8*4         * Get the R8 at entry to routine 26400000
DELEVNTR EQU   *                                                        26410000
         TM    PROGLOBL,NOFILEOP       * Was 'NOFILE' option supplied?  26420000
         BO    DELEVNDN                * Then no file update allowed    26430000
         SPACE ,                                                        26440000
         CLC   CVTSAVER(4),NULL        * Should we commnt out the line? 26450000
         BZ    DELEVNDN                * No, then just FRET the storage 26460000
         SPACE ,                                                        26470000
         LA    R2,RECRDMAP             * Point R2 to the buffer         26480000
         LA    R3,TIMFNAME             * Point to the file identifier   26490000
         LH    R4,EVNTIDEN             * Get the event identification   26500000
         LA    R5,RECMAPLN             * Get the maximum record length  26510000
         MVI   RECRDMAP,C' '           * Move a blank into the I/O buff 26520000
         MVC   RECRDMAP+1(RECOPERL),RECRDMAP * Clear the operation buff 26530000
         MVC   RECDATA(L'RECDATA),RECDATA-1  * Clear the data portion   26540000
         FSREAD (R3),FSCB=INPUTDS,ERROR=DELEVNDN,BUFFER=(R2),RECNO=(R4)*26550000
               ,NOREC=1,BSIZE=(R5),FORM=E * Read a record from the file 26560000
         MVI   RECRDMAP,C'*'           * Comment the record out         26570000
         LR    R5,R0                   * Get the new record length      26580000
         FSWRITE (R3),FSCB=OUTPUTDS,ERROR=DELEVNDN,BUFFER=(R2),        *26590000
               BSIZE=(R5),NOREC=1,RECNO=(R4),RECFM=V,FORM=E * Write rec 26600000
DELEVNDN EQU   *                                                        26610000
         LH    R0,EVNTELEN             * The size of this blck in bytes 26620000
         AH    R0,HWD7                 * Round up to next doubleword    26630000
         SRL   R0,3                    * Convert to doublewords         26640000
         CMSSTOR RELEASE,BYTES=(R0),ADDR=(R8),TYPCALL=BRANCH            26650000
DELEVNTX EQU   *                                                        26660000
         LM    R0,R9,CVTSAVER          * Restore the registers          26670000
         BR    R9                      * Return to caller               26680000
         EJECT ,                                                        26690000
*********************************************************************** 26700000
***                                                                 *** 26710000
***  Find an event with the matching EVENT id is the linked list.   *** 26720000
***                                                                 *** 26730000
*********************************************************************** 26740000
*                                                                       26750000
*   Register usage:                                                     26760000
*                                                                       26770000
*       R1  - EVENT identifier (number from 1 to 32767)                 26780000
*       R9  - Return address of the caller                              26790000
*                                                                       26800000
*   On exit:  CC0 - R8 points to the matching EVENT block               26810000
*                                                                       26820000
*             CC1 - EVENT block with matching identifier not found      26830000
*                   Register contents remain unchanged                  26840000
*                                                                       26850000
FINDEVNT DS    0H                                                       26860000
         STM   R0,R9,CVTSAVER          * Save the registers             26870000
         L     R8,ANCEVENT             * Get the EVENT block anchor     26880000
FINDEVN0 EQU   *                                                        26890000
         LTR   R8,R8                   * Is there one ?                 26900000
         BNZ   FINDEVN1                * Yes, try to find a match       26910000
         SPACE ,                                                        26920000
         NR    R9,R9                   * Set a non-zero CC              26930000
         B     FINDEVNX                * Return to caller with non-0 CC 26940000
         SPACE ,                                                        26950000
FINDEVN1 EQU   *                                                        26960000
         CH    R1,EVNTIDEN             * Does the event id match ?      26970000
         BNE   FINDEVN2                * No, continue linked list scan  26980000
         SPACE ,                                                        26990000
         ST    R8,CVTSAVER+8*4         * Save the new R8                27000000
         B     FINDEVNX                * Go return to caller with CC0   27010000
         SPACE ,                                                        27020000
FINDEVN2 EQU   *                                                        27030000
         L     R8,EVNTPREV             * Get the previous event pointer 27040000
         B     FINDEVN0                * Continue to look for the match 27050000
         SPACE ,                                                        27060000
FINDEVNX EQU   *                                                        27070000
         LM    R0,R9,CVTSAVER          * Restore the registers          27080000
         BR    R9                      * Return to caller               27090000
         EJECT ,                                                        27100000
*********************************************************************** 27110000
***                                                                 *** 27120000
***  Convert TOD timer value to EBCDIC mm/dd/yy hh:mm:ss format.    *** 27130000
***                                                                 *** 27140000
*********************************************************************** 27150000
*                                                                       27160000
*   Register usage:                                                     27170000
*                                                                       27180000
*       R0  - Address of doubleword clock value                         27190000
*       R1  - Address to store 8 bytes of EBCDIC date value             27200000
*       R2  - Address to store 8 bytes of EBCDIC time value             27210000
*       R3  - Work register                                             27220000
*       R4  - Work register                                             27230000
*       R5  - Work register                                             27240000
*       R8  - Work register                                             27250000
*       R9  - Return address                                            27260000
*                                                                       27270000
*   On exit:  R1  - Points to the converted date value                  27280000
*             R2  - Points to the converted time value                  27290000
*             R14 - Undefined                                           27300000
*             R15 - Undefined                                           27310000
*             All other register contents remain unchanged              27320000
*                                                                       27330000
*                                                                       27340000
TOD2EBCD DS    0H                                                       27350000
         STM   R0,R9,TIMERSAV          * Save R0 through R9 temporarily 27360000
*********************************************************************** 27370000
***                                                                 *** 27380000
***  First, compute the time elapsed since the start of the epoch,  *** 27390000
***  January 1, 1900 00:00:00. TOD clock value '0000000000000000'X  *** 27400000
***                                                                 *** 27410000
*********************************************************************** 27420000
         LR    R14,R0                  * Address of input TOD clock val 27430000
         LM    R0,R1,0(R14)            * Get TOD clock value into R0-R1 27440000
         SRDL  R0,12                   * Convert it to microseconds     27450000
         D     R0,FWD8MIL              * Compute number of seconds via  27460000
         LR    R3,R0                   * double-precision division of   27470000
         SLR   R2,R2                   * X/Y=8*(X/(8*Y))+MOD(X,8*Y)/Y,  27480000
         D     R2,FWD1MIL              * where X = number of micosecs   27490000
         SLR   R0,R0                   * since the start of the epoch,  27500000
         SLDL  R0,3                    * and Y = value of 1 micosecond  27510000
         ALR   R1,R3                   * with the remainder             27520000
         BC    CC0+CC1,MICSDAYS        * If CC0 or CC1, no carry        27530000
         A     R0,FWD1                 * Add the carry bit to R0        27540000
         SPACE 2                                                        27550000
*********************************************************************** 27560000
***                                                                 *** 27570000
***  At this point R0 has the number of seconds, since Midnight and *** 27580000
***  R1 contains the number of days, since epoch.                   *** 27590000
***                                                                 *** 27600000
*********************************************************************** 27610000
         SPACE 1                                                        27620000
MICSDAYS EQU   *                                                        27630000
         D     R0,FWDAYSEC             * Calc how many days (of secs)   27640000
         A     R0,TIMEZONE             * Adjust the time from G.M.T.    27650000
         BNM   NOFAREST                * Too far East? Crossed dateline 27660000
         SPACE ,                                                        27670000
         A     R0,FWDAYSEC             * Yes, add 1 day worth 86400 sec 27680000
         BCTR  R1,R0                   * And subtract a day from R1     27690000
NOFAREST DS    0H                                                       27700000
         C     R0,FWDAYSEC             * Too far West? Crossed dateline 27710000
         BL    NOFARWST                * No, we have the time value     27720000
         SPACE ,                                                        27730000
         S     R0,FWDAYSEC             * Yes, subtract 1 day worth of   27740000
         A     R1,FWD1                 * 86400 seconds and add 1 day    27750000
         SPACE ,                                                        27760000
*********************************************************************** 27770000
***                                                                 *** 27780000
***  Convert the time back to TOD format                            *** 27790000
***                                                                 *** 27800000
*********************************************************************** 27810000
         SPACE ,                                                        27820000
NOFARWST DS    0H                                                       27830000
         LR    R5,R0                   * Prep to conv number of seconds 27840000
         M     R4,FWD1MIL              * since Midnight                 27850000
         ALR   R5,R2                   * Add R2 to format the value     27860000
         BC    CC0+CC1,MIDTIME         * No carry, bypass the following 27870000
         SPACE ,                                                        27880000
         A     R4,FWD1                 * Add the carry bit to R4        27890000
         SPACE ,                                                        27900000
*********************************************************************** 27910000
***                                                                 *** 27920000
***  Calculate the time elapsed, since Midnight                     *** 27930000
***                                                                 *** 27940000
*********************************************************************** 27950000
         SPACE ,                                                        27960000
MIDTIME  EQU   *                                                        27970000
         SLDL  R4,12                   * Shift R4 and R5 left 12 bits   27980000
         LM    R8,R9,0(R14)            * Calculate time, since Midnight 27990000
         SLR   R9,R5                   * Subtract low order fullword    28000000
         BC    CC2+CC3,*+8             * Branch if no borrow            28010000
         SPACE ,                                                        28020000
         SL    R8,FWD1                 * Propagate the borrow           28030000
         SLR   R8,R4                   * Subtract high order            28040000
         STM   R8,R9,MIDNTCLK          * Save the value of the Midnight 28050000
         SPACE ,                                                        28060000
*********************************************************************** 28070000
***                                                                 *** 28080000
***  Check for the date before January 1, 1900, 00:00:00.           *** 28090000
***                                                                 *** 28100000
*********************************************************************** 28110000
         SPACE ,                                                        28120000
         LA    R3,365                  * Days in a non-leap year        28130000
         CR    R1,R3                   * Is the number of days <= 365 ? 28140000
         BNL   AFTR1900                * No, go calculate the year num  28150000
         SPACE ,                                                        28160000
         LR    R14,R1                  * Copy the number of days to R14 28170000
         SLR   R1,R1                   * Make year = 00                 28180000
         B     CONVYEAR                * Go convert the year number     28190000
         SPACE ,                                                        28200000
*********************************************************************** 28210000
***                                                                 *** 28220000
***  Calculations of the year number follow. Year 1900 was not a    *** 28230000
***  Leap year.                                                     *** 28240000
***                                                                 *** 28250000
*********************************************************************** 28260000
         SPACE 1                                                        28270000
AFTR1900 DS    0H                                                       28280000
         SR    R1,R3                   * Subtract total days in 1900    28290000
         SLR   R0,R0                   * Clear R0 for divide            28300000
         D     R0,FWDAYRS4             * Divide by 4 years days worth   28310000
         LR    R15,R0                  * R15 will hold number of days   28320000
         SLR   R14,R14                 * since the prior leap year      28330000
         DR    R14,R3                  * Divide by 365 & R14 will hold  28340000
         A     R14,FWD1                * num of days since year's start 28350000
         C     R15,FWD4                * Multiple of 4 year periods ?   28360000
         BNE   NONLEAPY                * No, don't adjust for leap year 28370000
         SPACE ,                                                        28380000
         AR    R14,R3                  * Set num of days to 366 (Leap)  28390000
         L     R15,FWD3                * Adjust R15 to 3                28400000
NONLEAPY DS    0H                                                       28410000
         ALR   R1,R1                   * Change R1 back into 4-years-   28420000
         ALR   R1,R1                   * worth of days by multiplying   28430000
         A     R1,FWD1                 * it times 4 and adding 1 for    28440000
         AR    R1,R15                  * the leap year                  28450000
         EJECT                                                          28460000
*********************************************************************** 28470000
***                                                                 *** 28480000
***  Convert the year to EBCDIC and save it in the buffer provided  *** 28490000
***                                                                 *** 28500000
*********************************************************************** 28510000
         SPACE ,                                                        28520000
CONVYEAR EQU   *                                                        28530000
         L     R2,TIMERSAV+4           * Original R1 contents into R2   28540000
         CVD   R1,DOUBLEWD             * Convert R1 to decimal          28550000
         UNPK  6(2,R2),DOUBLEWD+6(2)   * Convert the year into zoned    28560000
         OI    7(R2),X'F0'             * Force the sign                 28570000
         MVI   5(R2),C'/'              * Move the slash in              28580000
         SPACE ,                                                        28590000
*********************************************************************** 28600000
***                                                                 *** 28610000
***  The following code uses an index to determine the day number   *** 28620000
***  & its name and places these values into the variable DAYOFWK   *** 28630000
***  which will contain the name of the day, followed by the vari-  *** 28640000
***  able DAYOFWKL, containing the len-1  of the string, followed   *** 28650000
***  by DAYOFWKN, containing the number of this day.                *** 28660000
***                                                                 *** 28670000
*********************************************************************** 28680000
         SPACE 1                                                        28690000
         LR    R3,R1                   * Copy the year number into R3   28700000
         BCTR  R3,R0                   * Decrement year by 1            28710000
         LR    R9,R3                   * Copy it to R9                  28720000
         SRL   R9,2                    * Divide that value by 4         28730000
         N     R3,FWD3                 * Calculate (year-1) // 4        28740000
         MH    R9,HWD5                 * Calculate ((year-1)/4)*5       28750000
         AR    R9,R3                   * Add to it  ((year-1) // 4)     28760000
         AR    R9,R14                  * Add the days so far this year  28770000
         XR    R8,R8                   * Clear R8 for the next divide   28780000
         D     R8,FWD7                 * Calculate weekday index        28790000
         MH    R8,HWDWKDLN             * Multiply by len of each entry  28800000
         LA    R8,WKDAYTAB(R8)         * Point R8 to table of days      28810000
         MVC   DAYOFWK(12),0(R8)       * Copy the appropriate TBL info  28820000
         SPACE 3                                                        28830000
*********************************************************************** 28840000
***                                                                 *** 28850000
***  The following code will convert a given Julian date to Grego-  *** 28860000
***  rian, using the algorithm published in "Communications of the  *** 28870000
***  ACM", Vol 13, Number 10, October 1970, Page 621, by Richard A. *** 28880000
***  Stone.                                                         *** 28890000
***                                                                 *** 28900000
***  Register usage:                                                *** 28910000
***                                                                 *** 28920000
***    R1  - Holds the year number                                  *** 28930000
***    R14 - Holds the day number 1 to 365 (366, if Leap year)      *** 28940000
***                                                                 *** 28950000
*********************************************************************** 28960000
         SPACE ,                                                        28970000
JUL2GREG DS    0H                                                       28980000
         SR    R2,R2                   * Assume a regular year (365)    28990000
         N     R1,FWD3                 * Is this a Leap year?           29000000
         BNZ   NOLEAPJG                * No, don't add an extra day     29010000
         SPACE ,                                                        29020000
         LA    R2,1                    * Yes, remember the extra day    29030000
NOLEAPJG EQU   *                                                        29040000
         LA    R1,59(,R2)              * Calculate the end of February  29050000
         CR    R14,R1                  * Is this day before end of Feb? 29060000
         BNH   NOLPADJG                * Yes, do not adjust the date    29070000
         A     R14,FWD2                * Assume February +2 more days   29080000
         SR    R14,R2                  * Minus one for Leap year        29090000
NOLPADJG DS    0H                                                       29100000
         A     R14,=F'91'              * Adjust date to end of March    29110000
         LR    R9,R14                  * Calculate the number of months 29120000
         M     R8,=F'100'              * by dividing the day number by  29130000
         D     R8,=F'3055'             * 30.55 (3055/100). Result trunc 29140000
         LR    R5,R9                   * Reload R5 with the value in R9 29150000
         M     R4,=F'3055'             * Normalize it by mult. by 30.55 29160000
         D     R4,=F'100'              * (3055/100).                    29170000
         SR    R14,R5                  * Calculate which day this month 29180000
         SL    R9,FWD2                 * Reduce the range of month ...  29190000
*                                      * from 3-14 to range 1-12.       29200000
         CVD   R14,DOUBLEWD            * Convert the day to decimal     29210000
         L     R2,TIMERSAV+4           * Original R1 contents into R2   29220000
         UNPK  3(2,R2),DOUBLEWD+6(2)   * Convert the day to zoned formt 29230000
         OI    4(R2),X'F0'             * Force the sign                 29240000
         MVI   2(R2),C'/'              * Insert '/' between month & day 29250000
         CVD   R9,DOUBLEWD             * Convert the month to decimal   29260000
         UNPK  0(2,R2),DOUBLEWD+6(2)   * And then into zoned format     29270000
         OI    1(R2),X'F0'             * Force the sign                 29280000
         SPACE 3                                                        29290000
*********************************************************************** 29300000
***                                                                 *** 29310000
***  Convert the time to HH:MM:SS format and place it into buffer.  *** 29320000
***  In order to accomplish the above, subtract the number of mic-  *** 29330000
***  roseconds elapsed starting at the turn of the current century  *** 29340000
***  (epoch) until Midnight this morning from TOD clock value. Make *** 29350000
***  timezone adjustments. Save the result  in the buffer  pointed  *** 29360000
***  to by R2.                                                      *** 29370000
***                                                                 *** 29380000
***  Register usage:                                                *** 29390000
***                                                                 *** 29400000
***   R0 - Holds the first  fullword of the clock value to convert  *** 29410000
***   R1 - Holds the second fullword of the clock value to convert  *** 29420000
***   R2 - Buffer to store the resulting EBCDIC time value          *** 29430000
***   R3 - Points to today's TOD clock value at Midnight            *** 29440000
***                                                                 *** 29450000
***                                                                 *** 29460000
*********************************************************************** 29470000
         SPACE ,                                                        29480000
         L     R2,TIMERSAV+8           * Time buffer pointer in R2      29490000
         LA    R3,MIDNTCLK             * Clock at Midnight, this day    29500000
         L     R1,TIMERSAV             * Address of TOD clock passed    29510000
         LM    R0,R1,0(R1)             * Load the contents of TOD clock 29520000
         SL    R1,4(R3)                * Subtract low order fullword    29530000
         BC    CC2+CC3,*+8             * Branch if no borrow            29540000
         SPACE ,                                                        29550000
         SL    R0,FWD1                 * Propagate the borrow           29560000
         SL    R0,0(R3)                * Subtract high order            29570000
         SRDL  R0,12                   * Calc microsecs since Midnight  29580000
         D     R0,FWD1MIL              * Compute seconds since Midnight 29590000
         XR    R0,R0                   * Clear R0 for division          29600000
         D     R0,FWDSECHR             * Calc HRS since Midnite (/3600) 29610000
         CVD   R1,DOUBLEWD             * Convert hours to decimal value 29620000
         UNPK  0(2,R2),DOUBLEWD+6(2)   * Convert the number to zoned    29630000
         OI    1(R2),X'F0'             * Force the sign                 29640000
         MVI   2(R2),C':'              * Move the separator ":"         29650000
         LR    R1,R0                   * Load R1 with the remainder     29660000
         XR    R0,R0                   * Clear R0 for division          29670000
         D     R0,FWD60                * Calculate number of minutes    29680000
         CVD   R1,DOUBLEWD             * Convert minutes to decimal val 29690000
         UNPK  3(2,R2),DOUBLEWD+6(2)   * Convert the number to zoned    29700000
         OI    4(R2),X'F0'             * Force the sign                 29710000
         MVI   5(R2),C':'              * Move the separator ":"         29720000
         CVD   R0,DOUBLEWD             * Convert the seconds to decimal 29730000
         UNPK  6(2,R2),DOUBLEWD+6(2)   * Convert the number to zoned    29740000
         OI    7(R2),X'F0'             * Force the sign                 29750000
         LM    R0,R9,TIMERSAV          * Restore R0 through R9          29760000
         BR    R9                      * Return to caller               29770000
         EJECT ,                                                        29780000
*********************************************************************** 29790000
***                                                                 *** 29800000
***  Convert EBCDIC mm/dd/yy hh:mm:ss to a simple TOD clock format  *** 29810000
***                                                                 *** 29820000
*********************************************************************** 29830000
         SPACE ,                                                        29840000
*                                                                       29850000
*   Register usage:                                                     29860000
*                                                                       29870000
*     GPR0  - Work register                                             29880000
*     GPR1  - Work register                                             29890000
*     GPR2  - Holds the leap day, if any                                29900000
*     GPR3  - Input address of date in the format of MM/DD/YY           29910000
*     GPR6  - Input address of time in the format of HH:MM:SS           29920000
*     GPR8  - High-order value of TOD during calculations               29930000
*     GPR9  - Low-order value of TOD during calculations, & return addr 29940000
*     GPR15 - Work register                                             29950000
*                                                                       29960000
*   On exit:  CC0 - R1 points to the converted TOD value                29970000
*             CC1 - input is invalid                                    29980000
*             CALCTIME doubleword contains the calculated TOD value     29990000
         SPACE ,                                                        30000000
EBCD2TOD DS    0H                                                       30010000
         STM   R0,R9,TIMERSAV          * Save R0 through R9 temporarily 30020000
         XC    CENTURY,CENTURY         * Default to 01/01/1900 00:00:00 30030000
         LR    R6,R0                   * R6 will hold the TIME field    30040000
         LR    R3,R1                   * R3 will hold the DATE field    30050000
         SPACE ,                                                        30060000
YEARS    LA    R1,YY(R3)               * Point to the 2digit year value 30070000
         LA    R0,2                    * Length of the value (2 bytes)  30080000
         BAS   R14,D2B                 * Convert to binary equivalent   30090000
         SPACE ,                                                        30100000
         TM    PROGFLOW,FORCEGMT       * Do we force Greenwich Time?    30110000
         BO    STIL1900                * Yes, do not adjust timer       30120000
         SPACE ,                                                        30130000
         CH    R1,HWD93                * Year less than 1993 ?          30140000
         BNL   STIL1900                * No, still in 1900's            30150000
         SPACE ,                                                        30160000
         MVC   CENTURY,CENTRY21        * Copy TOD clock for 21 century  30170000
STIL1900 EQU   *                                                        30180000
         LR    R8,R1                   * Make a copy of it in R8        30190000
         M     R0,FWD365               * Num of days in a non-leap year 30200000
         SPACE ,                                                        30210000
         SR    R2,R2                   * Turn off leap day indicator    30220000
         XR    R4,R4                   * Turn off the 21 century leap   30230000
         CLC   CENTURY,CENTRY21        * Are we in the 21st century ?   30240000
         BE    CENT21                  * Yes, we are. Year 2000 is LEAP 30250000
         SPACE ,                                                        30260000
         LTR   R8,R8                   * Start of another century ?     30270000
         BZ    NOLEAPYR                * Yes, we will skip 1 leap year  30280000
         SPACE ,                                                        30290000
         B     CENT20                  * We are in the 20th century     30300000
         SPACE ,                                                        30310000
CENT21   EQU   *                                                        30320000
         LA    R4,1                    * Adjust for year 2000 leap day  30330000
CENT20   EQU   *                                                        30340000
         SR    R9,R9                   * Clear the target register      30350000
         SRDL  R8,2                    * Get the total num of leap days 30360000
         LTR   R9,R9                   * If the result is ODD, it's not 30370000
         BNZ   NOLEAPYR                * a leap year                    30380000
         SPACE ,                                                        30390000
         LA    R2,1                    * We may need to adjust 1 leap   30400000
NOLEAPYR DS    0H                                                       30410000
         LR    R9,R8                   * Get the total of leap days     30420000
         ALR   R9,R1                   * Add all days of previous years 30430000
         ALR   R9,R4                   * Add the year 2000 leap day     30440000
         SPACE 3                                                        30450000
MONTHS   LR    R1,R3                   * Point to the 2digit month valu 30460000
         LA    R0,2                    * Length of the value (2 bytes)  30470000
         BAS   R14,D2B                 * Convert to binary equivalent   30480000
         SPACE ,                                                        30490000
         C     R1,FWD2                 * Month higher than February ?   30500000
         BH    NOLEAPMO                * Yes, don't adjust the counters 30510000
         SPACE ,                                                        30520000
         SLR   R9,R2                   * Leap year, but before the 29th 30530000
NOLEAPMO DS    0H                                                       30540000
         SPACE ,                                                        30550000
         LA    R0,12                   * Get calendar table ind entries 30560000
         BCTR  R1,0                    * Decrement month for zero index 30570000
         SLL   R1,1                    * Multiply by two for halfword   30580000
         AH    R9,CALENDAR(R1)         * Add num of days prior this mon 30590000
         SPACE ,                                                        30600000
DAYS     LA    R1,DD(R3)               * Point R1 to the day field      30610000
         LA    R0,2                    * Get the length of the above    30620000
         BAS   R14,D2B                 * Convert to binary equivalent   30630000
         SPACE ,                                                        30640000
         BCTR  R1,0                    * Don't count the current day    30650000
         ALR   R9,R1                   * Calculate total of full days   30660000
         M     R8,FWD24                * Convert days to hours          30670000
         TM    PROGFLOW,FORCEGMT       * Do we force Greenwich Time?    30680000
         BO    NOADJUST                * Yes, do not adjust timer       30690000
         SPACE ,                                                        30700000
ADJSTZON L     R0,TIMEZONE             * Get the timezone clock units   30710000
         LTR   R0,R0                   * If zero, we are at G.M.T.      30720000
         BZ    NOADJUST                * Yes, do not adjust timer       30730000
         SPACE ,                                                        30740000
         SRDA  R0,32                   * Arithmetic zone value into R1  30750000
         D     R0,FWDSECHR             * Translate zone secs to hours   30760000
         SLR   R9,R1                   * Add or subtract, depending on  30770000
*                                      * whether East of West of G.M.T  30780000
NOADJUST EQU   *                                                        30790000
         SPACE ,                                                        30800000
         LR    R1,R6                   * Point R1 to the hour field     30810000
         LA    R0,2                    * Length of the hour field in R0 30820000
         BAS   R14,D2B                 * Convert to binary equivalent   30830000
         SPACE ,                                                        30840000
         ALR   R9,R1                   * Add the hour value to accumltr 30850000
         M     R8,FWD60                * Multiply by  X'3C'             30860000
MINUTES  LA    R1,MM(R6)               * Point R1 to the minute field   30870000
         LA    R0,2                    * And set R0 to the length of it 30880000
         BAS   R14,D2B                 * Convert to binary equivalent   30890000
         ALR   R9,R1                   * Add the minutes in             30900000
         M     R8,FWD60MIL             * Microseconds per minute        30910000
SECONDS  LA    R1,SS(R6)               * Point R1 to the seconds field  30920000
         LA    R0,2                    * Length of the secs field in R0 30930000
         BAS   R14,D2B                 * Convert to binary equivalent   30940000
         M     R0,FWD1MIL              * One million microsecs per sec  30950000
         ALR   R9,R1                   * Add the right half             30960000
         BC    CC0+CC1,NOOVRFLW        * If CC0 or CC1, no overflow ... 30970000
         AL    R8,FWD1                 * Add 1 to R8, for overflow      30980000
NOOVRFLW EQU   *                                                        30990000
         ALR   R8,R0                   * Add the left half              31000000
TODDAYTI SLDL  R8,12                   * Shift 12 bits to bit 51 (secs) 31010000
         AL    R9,CENTURY+4            * Add start of the century TOD   31020000
         BC    CC0+CC1,*+8             * Branch, if no carry            31030000
         AL    R8,FWD1                 * Add the carry bit to 1st fword 31040000
         AL    R8,CENTURY              * Add the first fullwords        31050000
         STM   R8,R9,CALCTIME          * Save the value in CALCTIME     31060000
         LM    R0,R9,TIMERSAV          * Restore R0 through R9          31070000
         BR    R9                      * Return to caller               31080000
         EJECT ,                                                        31090000
*********************************************************************** 31100000
***                                                                 *** 31110000
***      EBCDIC decimal character to binary conversion routine      *** 31120000
***                                                                 *** 31130000
*********************************************************************** 31140000
         SPACE ,                                                        31150000
*                                                                       31160000
*        Input:  R0  = Length of the number in (EBCDIC) char format     31170000
*                R1  = Pointer to the area containing the number        31180000
*                R14 = Return adrress                                   31190000
*                                                                       31200000
*        Output: R1  = Converted binary number                          31210000
*                CC  = 0  Conversion complete                           31220000
*                CC ^= 0  Error in conversion                           31230000
*                                                                       31240000
         SPACE 2                                                        31250000
D2B      DS    0H                                                       31260000
         STM   R0,R3,CVTSAVER          * Save the regs before conversn  31270000
         LTR   R2,R0                   * Get the length into R2         31280000
         BNP   RETD2B                  * Return with CC^=0, if <= zero  31290000
         SPACE ,                                                        31300000
         CH    R2,HWD8                 * Length greater than 8 ?        31310000
         BH    RETD2B                  * Return with CC^=0, if > eight  31320000
         SPACE ,                                                        31330000
         LR    R3,R1                   * Point to the argument passed   31340000
         BCTR  R2,R0                   * Decrement R2 for execute       31350000
         EX    R2,TRANSLT1             * Find a non-DEC digit, if any   31360000
         BNZ   RETD2B                  * Error, if found                31370000
         SPACE ,                                                        31380000
         MVC   DOUBLEWD,CHRZEROS       * Set the dword area to zoned 0  31390000
         LA    R3,DOUBLEWD+7           * Point R3 to the last Dword byt 31400000
         SR    R3,R2                   * Point to the correct move pos  31410000
         EX    R2,MOV2PACK             * Move zoned data into doublewd  31420000
         PACK  DOUBLEWD(8),DOUBLEWD(8) * Convert zoned num to decimal   31430000
         CVB   R1,DOUBLEWD             * Convert decimal num to binary  31440000
         SR    R0,R0                   * Set CC = 0                     31450000
RETD2B   EQU   *                                                        31460000
         L     R0,CVTSAVER             * Restore R0                     31470000
         LM    R2,R3,CVTSAVER+8        * Restore the registers R2 & R3  31480000
         BR    R14                     * Return to caller               31490000
         EJECT ,                                                        31500000
*********************************************************************** 31510000
***                                                                 *** 31520000
***  Find out the length of the passed parameter                    *** 31530000
***                                                                 *** 31540000
***  Input:  R0  = Start of the string to be searched for a blank   *** 31550000
***          R1  = End of the string to be searched for a blank     *** 31560000
***          R9  = Return address                                   *** 31570000
***                                                                 *** 31580000
***  Output: R0  = Unchanged                                        *** 31590000
***          R1  = Length of the string until the first blank       *** 31600000
***          R9  = Unchanged                                        *** 31610000
***                                                                 *** 31620000
*********************************************************************** 31630000
GETLEN   DS    0H                                                       31640000
         STM   R0,R3,CVTSAVER          * Save the regs on entry         31650000
         LR    R2,R1                   * Copy the end-of-string pointer 31660000
         SR    R2,R0                   * Determine the maximum length   31670000
         BCTR  R2,R0                   * Decrement by 1 for EXecute     31680000
         LR    R3,R0                   * Get a copy of the pointer      31690000
         EX    R2,TRANSLT2             * Find a blank, if any           31700000
         BNZ   LENCOMP                 * Found if non-zero. compute len 31710000
         LA    R1,1(R2,R3)             * Set R1 = R3+max                31720000
LENCOMP  EQU   *                                                        31730000
         SR    R1,R3                   * We have the length             31740000
         ST    R1,CVTSAVER+4           * Save the len to be ret. in R1  31750000
         LM    R0,R3,CVTSAVER          * Restore the registers          31760000
         BR    R9                                                       31770000
         EJECT ,                                                        31780000
*********************************************************************** 31790000
***                                                                 *** 31800000
***  Find out the length until the next non-blank character         *** 31810000
***                                                                 *** 31820000
***  Input:  R0  = Start of the string to scan for a non-blank      *** 31830000
***          R1  = End of the string to be scan for a non-blank     *** 31840000
***          R9  = Return address                                   *** 31850000
***                                                                 *** 31860000
***  Output: R0  = Unchanged                                        *** 31870000
***          R1  = Length of the string until the first non-blank   *** 31880000
***          R9  = Unchanged                                        *** 31890000
***                                                                 *** 31900000
*********************************************************************** 31910000
GETNBLNK DS    0H                                                       31920000
         STM   R0,R3,CVTSAVER          * Save the regs on entry         31930000
         LR    R2,R1                   * Copy the end-of-string pointer 31940000
         SR    R2,R0                   * Determine the maximum length   31950000
         BCTR  R2,R0                   * Decrement by 1 for EXecute     31960000
         LR    R3,R0                   * Get a copy of the pointer      31970000
         EX    R2,TRANSLT3             * Find a blank, if any           31980000
         BNZ   LENCOMPN                * Found if non-zero. compute len 31990000
         LA    R1,1(R2,R3)             * Set R1 = R3+max                32000000
LENCOMPN EQU   *                                                        32010000
         SR    R1,R3                   * We have the length             32020000
         ST    R1,CVTSAVER+4           * Save the len to be ret. in R1  32030000
         LM    R0,R3,CVTSAVER          * Restore the registers          32040000
         BR    R9                                                       32050000
         EJECT ,                                                        32060000
*********************************************************************** 32070000
***                                                                 *** 32080000
***  Check the table of valid options and their abbreviations for   *** 32090000
***  a correct parameter.                                           *** 32100000
***                                                                 *** 32110000
***  Input:  R1  = Length of the parameter passed                   *** 32120000
***          R6  = Points to the parameter                          *** 32130000
***                                                                 *** 32140000
***  Output: This routine does a BAS R9,S(routine_address) in or-   *** 32150000
***          der to complete the processing, if a parameter match   *** 32160000
***          is found. CC0 is returned to caller.                   *** 32170000
***                                                                 *** 32180000
***          If no match is found a CC1 is returned.                *** 32190000
***                                                                 *** 32200000
***          Register contents remain unchanged.                    *** 32210000
***                                                                 *** 32220000
*********************************************************************** 32230000
CHKDATE  DS    0H                                                       32240000
         STM   R0,R9,CVTSAVER          * Save the regs on entry         32250000
         LR    R0,R1                   * Get the orig parm length       32260000
         LR    R5,R1                   * Get the original parm length   32270000
         BCTR  R5,R0                   * Decrement R5 by 1 for Execute  32280000
         LA    R1,DATETBL              * Point R1 to the table of dates 32290000
         XR    R2,R2                   * Clear R2 for insert            32300000
         XR    R3,R3                   * Clear R3 for insert            32310000
CHKDAT1  EQU   *                                                        32320000
         CLI   0(R1),X'00'             * More entries left ?            32330000
         BE    CHKDATNF                * No, matching parm not found    32340000
         SPACE ,                                                        32350000
         IC    R2,0(,R1)               * Get the table option length    32360000
         IC    R3,1(,R1)               * Get the abbreviated opt length 32370000
         LA    R4,8(,R1)               * Point R4 to the option itself  32380000
         CR    R0,R2                   * Parm length > max parm length? 32390000
         BH    CHKDTNXT                * Yes, check the next parm       32400000
         SPACE ,                                                        32410000
         BCTR  R2,R0                   * Decrement R2 for EXecute       32420000
         EX    R2,COMPARMS             * Execute the following:         32430000
*+++     CLC   0(*-*,R6),0(R4)         * Compare the parms supplied     32440000
         LA    R2,1(,R2)               * Recover the option length      32450000
         BE    CHKDTFND                * Equal, then matchng parm found 32460000
         SPACE ,                                                        32470000
         CR    R0,R3                   * Parm length < than min abbrev? 32480000
         BL    CHKDTNXT                * Yes, check the next parm       32490000
         SPACE ,                                                        32500000
         EX    R5,COMPARMS             * Execute the following:         32510000
*+++     CLC   0(*-*,R6),0(R4)         * Compare the abbrev parm field  32520000
         BE    CHKDTFND                * Match found ...                32530000
         SPACE ,                                                        32540000
CHKDTNXT EQU   *                                                        32550000
         LA    R1,0(R2,R4)             * Point R1 to the next tbl entry 32560000
         LA    R3,1                    * Load R1 with an odd value 1    32570000
         NR    R3,R1                   * Is R1 halfword aligned ?       32580000
         BZ    CHKDAT1                 * Yes, do the next entry         32590000
         SPACE ,                                                        32600000
         LA    R1,1(,R1)               * Bump up the table entry ptr    32610000
         B     CHKDAT1                 * Look at the next entry, if any 32620000
         SPACE ,                                                        32630000
CHKDTFND EQU   *                                                        32640000
         LA    R3,X'90'                * Set up R3 for "BAS R9,S(addr)" 32650000
         MVC   BRANCHIN(1),BRANCH      * Move the "BAL" opcode          32660000
         MVC   BRANCHIN+2(2),6(R1)     * Move the Base+Offset part      32670000
         EX    R3,BRANCHIN             * Execute the following:         32680000
*+++     BAS   R9,S(routine_address)   * Branch to the appropriate code 32690000
         CR    R4,R4                   * Set a CC0 (match found)        32700000
         B     CHKEXIT                 * Return to caller               32710000
CHKDATNF EQU   *                                                        32720000
         NR    R4,R4                   * Set a CC1 (match not found)    32730000
CHKEXIT  EQU   *                                                        32740000
         LM    R0,R9,CVTSAVER          * Restore the registers          32750000
         BR    R9                                                       32760000
         EJECT ,                                                        32770000
*********************************************************************** 32780000
***                                                                 *** 32790000
***  Check the parameters which are not in the table for a valid    *** 32800000
***  date, time, or "UNTIL" option. Also verify the presence of     *** 32810000
***  a function, e.g. "MSG","CMS","CP".                             *** 32820000
***                                                                 *** 32830000
***  Input:  R1  = Length of the parameter passed                   *** 32840000
***          R6  = Points to the parameter                          *** 32850000
***                                                                 *** 32860000
***  Output: This routine sets up appropriate fields in RECRDMAP &  *** 32870000
***          EVENTBUF blocks and also turns on additional flags     *** 32880000
***          in PROGFLOW control byte. If an option supplied is     *** 32890000
***          valid, a CC0 is returned. Otherwise a CC1 is passed.   *** 32900000
***                                                                 *** 32910000
***          If all parameters have been processed, R9 will be      *** 32920000
***          changed on return to point to MORPARMS.                *** 32930000
***                                                                 *** 32940000
***          Otherwise, register contents will remain unchanged.    *** 32950000
***                                                                 *** 32960000
*********************************************************************** 32970000
CHKSPEC  DS    0H                                                       32980000
         STM   R0,R9,CVTSAVR2          * Save the regs on entry         32990000
         LR    R4,R6                   * Make a copy of the parm ptr    33000000
         TM    PROGFLOW,FUNCKINC       * Did we process a func keyword? 33010000
         BNO   NOFUNYET                * No, not yet                    33020000
         SPACE ,                                                        33030000
         LA    R9,MORPARMS             * Yes, put in a new return addr  33040000
         ST    R9,CVTSAVR2+9*4         * Save R9 as the new return addr 33050000
         B     CHKSPEXI                * Go, return to caller           33060000
         SPACE ,                                                        33070000
NOFUNYET EQU   *                                                        33080000
         TM    PROGFLOW,TIMEINC        * Was time info supplied before? 33090000
         BO    NODATIME                * Yes, don't check for date/time 33100000
         SPACE ,                                                        33110000
         TM    PROGFLOW,DATEINC        * Was date info supplied before? 33120000
         BO    NODATCHK                * Yes, don't check for date      33130000
         SPACE ,                                                        33140000
         CLC   0(3,R6),=C'==/'         * Is this an offset interval ?   33150000
         BNE   CHKPLSNN                * No, check the "+nn" date formt 33160000
         SPACE ,                                                        33170000
         CLI   5(R6),C' '              * Is the day followed by blank?  33180000
         BNE   CHKPLSNN                * No, check the "+nn" date formt 33190000
         SPACE ,                                                        33200000
         LA    R0,2                    * Get the length into R0         33210000
         LA    R1,3(,R6)               * Point R1 to the number         33220000
         BAS   R14,D2B                 * Convert the number to binary   33230000
         BNZ   NOTAPARM                * CC^=0 - Invalid decimal number 33240000
         SPACE ,                                                        33250000
         CH    R1,HWD31                * Is the number greater than 31? 33260000
         BH    NOTAPARM                * Yes, invalid day of month      33270000
         SPACE ,                                                        33280000
         CH    R1,NULL                 * Is the number <= zero ?        33290000
         BNH   NOTAPARM                * Yes, /DD can't be zero or less 33300000
         SPACE ,                                                        33310000
         MVC   RECDATE,0(R6)           * Copy this info into RECRDMAP   33320000
         MVC   EVNTOFFS-EVENT+EVNTBUFF(2),3(R6) * Copy 'DD' from ==/DD  33330000
         MVI   EVNTFLG5-EVENT+EVNTBUFF,X'05'    Put in a function index 33340000
         OI    EVNTFLG1-EVENT+EVNTBUFF,EVNTADDD Event is in format /DD  33350000
         OI    EVNTWEEK-EVENT+EVNTBUFF,EVNTREPD Event is date-repetitiv 33360000
         OI    PROGFLOW,DATEINC        * Turn the cntrl bit on for date 33370000
         B     CHKSPEXI                * Go, return to caller           33380000
         SPACE ,                                                        33390000
CHKPLSNN EQU   *                                                        33400000
         CLI   0(R6),C'+'              * Is this a "+nn" date format?   33410000
         BNE   NOTPLSNN                                                 33420000
         SPACE ,                                                        33430000
         OI    PROGFLOW+1,DTPLSINC     * Remember we are doing a "+NN"  33440000
         SPACE ,                                                        33450000
         CLI   3(R6),C':'              * Is this a time specification?  33460000
         BE    NODATCHK                * Yes, don't check for date      33470000
         SPACE ,                                                        33480000
         LA    R0,1(,R6)               * Point R0 past the "+" sign     33490000
         LA    R1,11(,R6)              * Point R1 to the end of the num 33500000
         BAS   R9,GETLEN               * Find out the length of it      33510000
         SPACE ,                                                        33520000
         LR    R0,R1                   * Get the length into R0         33530000
         LA    R1,1(,R6)               * Point R1 to the number         33540000
         BAS   R14,D2B                 * Convert the number to binary   33550000
         BNZ   NOTAPARM                * CC^=0 - Invalid decimal number 33560000
         SPACE ,                                                        33570000
         CH    R1,HWD16383             * Is the num >16383 (max "nn")?  33580000
         BH    NOTAPARM                * Yes, parameter is invalid      33590000
         SPACE ,                                                        33600000
         LTR   R1,R1                   * Is the number positive ?       33610000
         BNP   NOTAPARM                * No, parameter is invalid       33620000
         SPACE ,                                                        33630000
         STCM  R1,B'0011',EVNTFLG3-EVENT+EVNTBUFF Sav info in event buf 33640000
         MVC   RECDATE,0(R6)           * Copy this info into RECRDMAP   33650000
         OI    EVNTWEEK-EVENT+EVNTBUFF,EVNTREPD Event is date-repetitiv 33660000
         OI    PROGFLOW,DATEINC        * Turn the cntrl bit on for date 33670000
         B     CHKSPEXI                * Go, return to caller           33680000
         SPACE ,                                                        33690000
NOTPLSNN EQU   *                                                        33700000
         BAS   R9,VALIDATE             * Go, validate the date supplied 33710000
         BC    CC0,DATECHKD            * Inval date, can be other parm  33720000
         SPACE ,                                                        33730000
         STCK  TODVALUE                * Save the current TOD clock     33740000
         LA    R0,TODVALUE             * Point R0 to the current TOD    33750000
         LA    R1,DATEVAL              * Point R1 to date output buffer 33760000
         LA    R2,TIMEVAL              * Point R2 to time output buffer 33770000
         BAS   R9,TOD2EBCD             * Convert TOD clock to EBCDIC    33780000
         SPACE ,                                                        33790000
         MVC   RECDATE(8),DATEVAL      * Copy today's date sinc omitted 33800000
         B     NODATCHK                * It may be other parm, e.g time 33810000
         SPACE 2                                                        33820000
DATECHKD EQU   *                                                        33830000
         MVC   RECDATE,0(R6)           * Copy this info into RECRDMAP   33840000
         OI    PROGFLOW,DATEINC        * Turn the cntrl bit on for date 33850000
         B     CHKSPEXI                * Go, return to caller CC0       33860000
         SPACE ,                                                        33870000
NODATCHK EQU   *                       * Here we'll be checking time    33880000
         BAS   R9,VALITIME             * Go, validate the time supplied 33890000
         BC    CC1,NOTAPARM            * Inval time, may be other parm  33900000
         SPACE ,                                                        33910000
         TM    PROGFLOW+1,IMMEDINC     * Immediate execution requested? 33920000
         BNO   NOADJST1                * Do not adjust the offset       33930000
         SPACE ,                                                        33940000
         OI    EVNTFLG1-EVENT+EVNTBUFF,EVNTIMM Mark it for immed execut 33950000
         OI    EVNTFLG2-EVENT+EVNTBUFF,EVNTIMM3 Mark it for immed exec  33960000
         LA    R4,1(,R4)               * Increment parm pointer in R4   33970000
NOADJST1 EQU   *                                                        33980000
         TM    PROGFLOW+1,TMPLSINC     * "+" sign included ?            33990000
         BNO   NOADJST2                * Do not adjust the offset       34000000
         SPACE ,                                                        34010000
         OI    EVNTFLG2-EVENT+EVNTBUFF,EVNTREPT Event is time-repetitiv 34020000
         LA    R4,1(,R4)               * Increment parm pointer in R4   34030000
NOADJST2 EQU   *                                                        34040000
         MVC   0(10,R4),BLANKS         * Clear the time field to blanks 34050000
         MVC   0(8,R4),TIMEVAL         * Move the corrected time info   34060000
         MVC   RECTIME,0(R6)           * Copy this info into RECRDMAP   34070000
         OI    PROGFLOW,TIMEINC        * Turn the cntrl bit on for time 34080000
         TM    PROGFLOW,CMDINPUT       * Command line input processing? 34090000
         BNO   CHKSPEXI                * Go, return to caller           34100000
         SPACE ,                                                        34110000
         MVC   RECLDATE,BLANKS         * Clear the last sched. date     34120000
         MVC   RECLTIME,BLANKS         * Clear the last sched. time     34130000
         B     CHKSPEXI                * Go, return to caller CC0       34140000
         SPACE 2                                                        34150000
NODATIME EQU   *                                                        34160000
         TM    PROGFLOW,UNTLKINC       * Did we already see UNTIL key ? 34170000
         BO    UNTILDAT                * Yes, have to look for a date   34180000
         SPACE ,                                                        34190000
         CLC   UNTILCON,0(R6)          * Is this the "UNTIL " keyword ? 34200000
         BNE   FUNCTNCK                * No, look for a function        34210000
         SPACE ,                                                        34220000
         OI    PROGFLOW,UNTLKINC       * Rememb that "UNTIL" key given  34230000
         B     CHKSPEXI                * Go, return to caller CC0       34240000
         SPACE ,                                                        34250000
UNTILDAT EQU   *                                                        34260000
         TM    PROGFLOW,UNTLPINC       * Did we get the date for UNTIL? 34270000
         BO    UNTILTIM                * Yes, have to look 4 UNTIL time 34280000
         SPACE ,                                                        34290000
         BAS   R9,VALIDATE             * Go, validate the date supplied 34300000
         BC    CC1,NOTAPARM            * Inval date, error              34310000
         SPACE ,                                                        34320000
         MVC   RECUNTID,0(R6)          * Copy the UNTIL date            34330000
         OI    PROGFLOW,UNTLPINC       * Rememb that we have UNTIL date 34340000
         OI    EVNTFLG1-EVENT+EVNTBUFF,EVNTLIM Remember the UNTIL claus 34350000
         B     CHKSPEXI                * Go, return to caller CC0       34360000
         SPACE ,                                                        34370000
UNTILTIM EQU   *                                                        34380000
         TM    PROGFLOW+1,UNTLQINC     * Did we get the time for UNTIL? 34390000
         BO    FUNCTNCK                * Yes, have to look for a functn 34400000
         SPACE ,                                                        34410000
         CLI   0(R6),X'F0'             * Is this a digit ?              34420000
         BNL   UNTILTVL                * Yes, it may be a valid time    34430000
         SPACE ,                                                        34440000
         MVC   RECUNTIT,ZEROTIME       * Copy the UNTIL time 00:00:00   34450000
         OI    PROGFLOW+1,UNTLQINC     * Rememb that we have UNTIL time 34460000
         B     FUNCTNCK                * Continue with function check   34470000
         SPACE ,                                                        34480000
UNTILTVL EQU   *                                                        34490000
         BAS   R9,VALITIME             * Check the time info            34500000
         BC    CC1,NOTAPARM            * Inval time, may be other parm  34510000
         SPACE ,                                                        34520000
         MVC   0(10,R4),BLANKS         * Clear the time field to blanks 34530000
         MVC   0(8,R4),TIMEVAL         * Move the corrected time info   34540000
         MVC   RECUNTIT,0(R6)          * Copy this info into RECRDMAP   34550000
         OI    PROGFLOW+1,UNTLQINC     * Rememb that we have UNTIL time 34560000
         B     CHKSPEXI                * Go, return to caller CC0       34570000
         SPACE ,                                                        34580000
FUNCTNCK EQU   *                                                        34590000
         CLC   MSGCONST,0(R6)          * Is this a message function ?   34600000
         BNE   FUNCTCMS                * No, check for "CMS" function   34610000
         SPACE ,                                                        34620000
         OI    PROGFLOW,FUNCKINC       * Remember the function keyword  34630000
         OI    (EVNTFLG1-EVENT)+EVNTBUFF,EVNTMSG  It was a "MSG" funcn  34640000
         MVC   RECFUNC,0(R6)           * Copy the function name         34650000
         B     CHKSPEXI                * Go, return to caller with CC0  34660000
         SPACE ,                                                        34670000
FUNCTCMS EQU   *                                                        34680000
         CLC   CMSCONST,0(R6)          * Is this a CMS function ?       34690000
         BNE   FUNCTNCP                * No, check for "CP" function    34700000
         SPACE ,                                                        34710000
         OI    PROGFLOW,FUNCKINC       * Remember the function keyword  34720000
         OI    (EVNTFLG1-EVENT)+EVNTBUFF,EVNTCMS  It was a "CMS" funcn  34730000
         MVC   RECFUNC,0(R6)           * Copy the function name         34740000
         B     CHKSPEXI                * Go, return to caller with CC0  34750000
         SPACE ,                                                        34760000
FUNCTNCP EQU   *                                                        34770000
         CLC   CPCONST,0(R6)           * Is this a CP function ?        34780000
         BNE   NOTAPARM                * No, invalid parameter, then    34790000
         SPACE ,                                                        34800000
         OI    PROGFLOW,FUNCKINC       * Remember the function keyword  34810000
         OI    (EVNTFLG1-EVENT)+EVNTBUFF,EVNTCP   It was a "CP" funcn   34820000
         MVC   RECFUNC,0(R6)           * Copy the function name         34830000
         B     CHKSPEXI                * Go, return to caller with CC0  34840000
         SPACE 2                                                        34850000
NOTAPARM EQU   *                                                        34860000
         NR    R6,R6                   * Set up CC1 for return          34870000
         B     SPECEXIT                * Go, return to caller           34880000
         SPACE ,                                                        34890000
CHKSPEXI EQU   *                                                        34900000
         CR    R6,R6                   * Set up CC0 for return          34910000
SPECEXIT EQU   *                                                        34920000
         LM    R0,R9,CVTSAVR2          * Restore the registers          34930000
         BR    R9                                                       34940000
         EJECT ,                                                        34950000
*********************************************************************** 34960000
***                                                                 *** 34970000
***  Validate the date supplied and return CC0 if it is valid.      *** 34980000
***                                                                 *** 34990000
***  Input:  R6  = Points to the date parameter in the form:        *** 35000000
***                MM/DD/YY or MM/DD (which expands to MM/DD/YY).   *** 35010000
***                                                                 *** 35020000
***  Output: CC0 if the date is valid                               *** 35030000
***          CC1 if the date is invalid                             *** 35040000
***                                                                 *** 35050000
*********************************************************************** 35060000
VALIDATE DS    0H                                                       35070000
         STM   R0,R9,VALSAVER          * Save the regs on entry         35080000
         CLI   2(R6),C'/'              * Do we have a slash ?           35090000
         BNE   NOTADATE                * No, it's not a date, then      35100000
         SPACE ,                                                        35110000
         CLI   5(R6),C'/'              * Do we have a slash ?           35120000
         BE    MAYBEDAT                * Yes, it may be a valid date    35130000
         SPACE ,                                                        35140000
         CLI   5(R6),C' '              * Do we have a blank ?           35150000
         BNE   NOTADATE                * No, the date cannot be valid   35160000
         SPACE ,                                                        35170000
         MVI   5(R6),C'/'              * Move a slash character in      35180000
SHORTDAT EQU   *                                                        35190000
         STCK  TODVALUE                * Get the current time of day    35200000
         LA    R0,TODVALUE             * Point R0 to the current TOD    35210000
         LA    R1,DATEVAL              * Point R1 to date output buffer 35220000
         LA    R2,TIMEVAL              * Point R2 to time output buffer 35230000
         BAS   R9,TOD2EBCD             * Convert TOD clock to EBCDIC    35240000
         SPACE ,                                                        35250000
         MVC   YY(2,R6),DATEVAL+YY     * Move the year information      35260000
         SPACE ,                                                        35270000
MAYBEDAT EQU   *                                                        35280000
         CLI   6(R6),C'0'              * Do we have numerics in year?   35290000
         BL    NOTADATE                * No, the date is invalid        35300000
         SPACE ,                                                        35310000
         CLI   7(R6),C'0'              * Do we have numerics in year?   35320000
         BL    NOTADATE                * No, the date is invalid        35330000
         SPACE ,                                                        35340000
         CLI   8(R6),C' '              * Do we have a blank after YY    35350000
         BNE   NOTADATE                * No, the date cannot be valid   35360000
         SPACE ,                                                        35370000
         LA    R1,0(,R6)               * Point R1 to the month          35380000
         LA    R0,2                    * Length of the number           35390000
         BAS   R14,D2B                 * Convert to binary              35400000
         BC    CC1,NOTADATE            * If CC1 then not a valid date   35410000
         SPACE ,                                                        35420000
         C     R1,FWD12                * Valid month ?                  35430000
         BH    NOTADATE                * No, cannot be over 12 months   35440000
         SPACE ,                                                        35450000
         LTR   R1,R1                   * Make sure it's non-zero ...    35460000
         BZ    NOTADATE                * Month cannot be equal to zero  35470000
         SPACE ,                                                        35480000
         LR    R2,R1                   * Save the month number          35490000
         LA    R1,DD(,R6)              * Point R1 to the days           35500000
         LA    R0,2                    * Length of the number           35510000
         BAS   R14,D2B                 * Convert to binary              35520000
         BC    CC1,NOTADATE            * If CC1 then not a valid date   35530000
         SPACE ,                                                        35540000
         LTR   R1,R1                   * Make sure the day is non-zero  35550000
         BZ    NOTADATE                * Day cannot be equal to zero    35560000
         SPACE ,                                                        35570000
         CH    R1,HWD31                * Is this a valid day number ?   35580000
         BH    NOTADATE                * No, cannot be over 31 days     35590000
         SPACE ,                                                        35600000
         C     R2,FWD2                 * Is this a month of February ?  35610000
         BNE   NOTAFEBR                * No, process the table then     35620000
         SPACE ,                                                        35630000
         CH    R1,HWD29                * Is this a valid February day ? 35640000
         BH    NOTADATE                * No, cannot be over 29 days     35650000
         BL    ITSADATE                * Yes, it can be 28 or less      35660000
         SPACE ,                                                        35670000
         LR    R1,R6                   * Point R1 to the date in questn 35680000
         LA    R0,ZEROTIME             * Time at midnight               35690000
         BAS   R9,EBCD2TOD             * Convert the day to TOD format  35700000
         SPACE ,                                                        35710000
         MVC   TESTTIME,CALCTIME       * Save the TOD output clock val  35720000
         MVC   DATEVAL,MARCH1ST        * Move the March 1 date          35730000
         MVC   DATEVAL+YY(2),YY(R6)    * Move the year value in         35740000
         LA    R1,DATEVAL              * Point R1 to the March 1 date   35750000
         BAS   R9,EBCD2TOD             * Convert the day to TOD format  35760000
         SPACE ,                                                        35770000
         CLC   TESTTIME,CALCTIME       * Was that a valid day of a Leap 35780000
         BE    NOTADATE                * year? No, invalid date then    35790000
         B     ITSADATE                * It's a valid date, then        35800000
         SPACE ,                                                        35810000
NOTAFEBR EQU   *                                                        35820000
         IC    R2,MONTHTAB(R2)         * Get the number of days         35830000
         CR    R1,R2                   * Is this a valid day number?    35840000
         BNH   ITSADATE                * Yes, it is valid               35850000
         SPACE ,                                                        35860000
NOTADATE EQU   *                                                        35870000
         NR    R6,R6                   * Set up a CC1 for invalid date  35880000
         B     VALIEXIT                * Go, return to caller           35890000
         SPACE ,                                                        35900000
ITSADATE EQU   *                                                        35910000
         CR    R6,R6                   * Set up a CC0 for valid date    35920000
VALIEXIT EQU   *                                                        35930000
         LM    R0,R9,VALSAVER          * Restore the registers          35940000
         BR    R9                                                       35950000
         EJECT ,                                                        35960000
*********************************************************************** 35970000
***                                                                 *** 35980000
***  Validate the time supplied and return CC0 if it is valid.      *** 35990000
***                                                                 *** 36000000
***  Input:  R6  = Points to the time parameter in the form:        *** 36010000
***             <">+">HH:MM<:SS><AM|PM>                             *** 36020000
***                                                                 *** 36030000
***  Output: CC0 if the date is valid                               *** 36040000
***          TIMEVAL contains the time in HH:MM:SS format           *** 36050000
***                                                                 *** 36060000
***          CC1 if the time is invalid                             *** 36070000
***                                                                 *** 36080000
*********************************************************************** 36090000
VALITIME DS    0H                                                       36100000
         STM   R0,R9,VALSAVER          * Save the regs on entry         36110000
         CLI   0(R6),C'>'              * Is this a ">+HH:MM:SS" time?   36120000
         BNE   NOGRTSGN                * N, this isn't "immediat" sign? 36130000
         SPACE ,                                                        36140000
         OI    PROGFLOW+1,IMMEDINC     * Remember the immediate parm    36150000
         LA    R6,1(,R6)               * Point to the next parm byte    36160000
NOGRTSGN EQU   *                                                        36170000
         CLI   0(R6),C'+'              * Is this a "+HH:MM:SS" time?    36180000
         BNE   NOTPLSHH                * No, this is not an interval    36190000
         SPACE ,                                                        36200000
         OI    PROGFLOW+1,TMPLSINC     * Remember the "+" interval      36210000
         LA    R6,1(,R6)               * Point to the next parm byte    36220000
         CLC   ZEROTIME,0(R6)          * Is this a +00:00:00 value?     36230000
         BE    NOTATIME                * Yes, it's invalid then         36240000
         SPACE ,                                                        36250000
         CLC   ZEROTIM2,0(R6)          * Is this a +00:00:00 value?     36260000
         BE    NOTATIME                * Yes, it's invalid then         36270000
         SPACE ,                                                        36280000
NOTPLSHH EQU   *                                                        36290000
         CLI   2(R6),C':'              * Is this a time specification?  36300000
         BNE   NOTATIME                * No, it's an invalid parm then  36310000
         SPACE ,                                                        36320000
         LR    R1,R6                   * Point R1 to hours string       36330000
         LA    R0,2                    * We want to convert 2 digits    36340000
         BAS   R14,D2B                 * Convert the number to binary   36350000
         BNZ   NOTATIME                * CC^=0 - Invalid decimal number 36360000
         SPACE ,                                                        36370000
         C     R1,FWD24                * Hours greater than 23 ?        36380000
         BNL   NOTATIME                * Yes, then it's an invalid parm 36390000
         SPACE ,                                                        36400000
         MVC   TIMEVAL,ZEROTIME        * Move the "00:00:00" value      36410000
         MVC   TIMEVAL(2),0(R6)        * Move the hours value           36420000
         LR    R5,R1                   * Get the value of hours into R5 36430000
         LR    R4,R6                   * Point R4 to hours value        36440000
         LA    R1,MM(,R6)              * Point R0 to the minutes field  36450000
         LA    R0,2                    * We want to convert 2 digits    36460000
         BAS   R14,D2B                 * Convert the number to binary   36470000
         BNZ   NOTATIME                * CC^=0 - Invalid decimal number 36480000
         SPACE ,                                                        36490000
         C     R1,FWD60                * Minutes greater than 59 ?      36500000
         BNL   NOTATIME                * Yes, then it's an invalid parm 36510000
         SPACE ,                                                        36520000
         MVC   TIMEVAL+MM(2),MM(R6)    * Move the minutes value         36530000
         CLI   5(R6),C':'              * Is this a time specification?  36540000
         BNE   TIMEAMPM                * No, it may be an AM/PM specif. 36550000
         SPACE ,                                                        36560000
         LA    R1,SS(,R6)              * Point R0 to the seconds field  36570000
         LA    R0,2                    * We want to convert 2 digits    36580000
         BAS   R14,D2B                 * Convert the number to binary   36590000
         BNZ   NOTATIME                * CC^=0 - Invalid decimal number 36600000
         SPACE ,                                                        36610000
         C     R1,FWD60                * Seconds greater than 59 ?      36620000
         BNL   NOTATIME                * Yes, then it's an invalid parm 36630000
         SPACE ,                                                        36640000
         MVC   TIMEVAL+SS(2),SS(R6)    * Move the seconds value         36650000
         LA    R6,3(,R6)               * Bypass the seconds             36660000
TIMEAMPM EQU   *                                                        36670000
         SPACE ,                                                        36680000
         CLI   5(R6),C' '              * Is this a "HH:MM<:SS>" spec ?  36690000
         BE    ITSATIME                * Yes, this is a correct format  36700000
         SPACE ,                                                        36710000
         CLC   5(2,R6),AMCONST         * Is this an "AM" time ?         36720000
         BNE   TIMECKPM                * Yes, this is a correct format  36730000
         SPACE ,                                                        36740000
         TM    PROGFLOW,UNTLKINC       * Have we processed "UNTIL" key? 36750000
         BO    TIMNPLS1                * Yes, than don't check for "+"  36760000
         SPACE ,                                                        36770000
         TM    PROGFLOW+1,TMPLSINC     * Any preceeding "+" ?           36780000
         BNZ   NOTATIME                * Yes, then "AM" is invalid here 36790000
         SPACE ,                                                        36800000
TIMNPLS1 EQU   *                                                        36810000
         C     R5,FWD12                * Can hours have an AM/PM spec ? 36820000
         BH    NOTATIME                * No, cannot be 13:00AM and over 36830000
         SPACE ,                                                        36840000
         B     ITSATIME                * Yes, this is a correct format  36850000
TIMECKPM EQU   *                                                        36860000
         TM    PROGFLOW,UNTLKINC       * Have we processed "UNTIL" key? 36870000
         BO    TIMNPLS2                * Yes, than don't check for "+"  36880000
         SPACE ,                                                        36890000
         TM    PROGFLOW+1,TMPLSINC     * Any preceeding "+" ?           36900000
         BNZ   NOTATIME                * Yes, then "AM" is invalid here 36910000
         SPACE ,                                                        36920000
TIMNPLS2 EQU   *                                                        36930000
         CLC   5(2,R6),PMCONST         * Is this a  "PM" time ?         36940000
         BNE   NOTATIME                * No, then it's an invalid parm  36950000
         SPACE ,                                                        36960000
         LA    R5,12(,R5)              * Get the new value for hours    36970000
         C     R5,FWD24                * Hours greater than 24 ?        36980000
         BH    NOTATIME                * Yes, then it's an invalid parm 36990000
         SPACE ,                                                        37000000
         CVD   R5,DOUBLEWD             * Convert R5 to decimal          37010000
         UNPK  0(2,R4),DOUBLEWD+6(2)   * Convert the hours into zoned   37020000
         OI    1(R4),X'F0'             * Force the sign                 37030000
         MVC   TIMEVAL(2),0(R4)        * Move the hours new value       37040000
         B     ITSATIME                * Go, return to caller with CC0  37050000
NOTATIME EQU   *                                                        37060000
         NR    R6,R6                   * Set up a CC1 for invalid date  37070000
         B     VALIEXI2                * Go, return to caller           37080000
         SPACE ,                                                        37090000
ITSATIME EQU   *                                                        37100000
         CR    R6,R6                   * Set up a CC0 for valid date    37110000
VALIEXI2 EQU   *                                                        37120000
         LM    R0,R9,VALSAVER          * Restore the registers          37130000
         BR    R9                                                       37140000
         EJECT ,                                                        37150000
*********************************************************************** 37160000
***                                                                 *** 37170000
***  Initialize the event schedule using the SCHEDULE TIMES A file  *** 37180000
***                                                                 *** 37190000
*********************************************************************** 37200000
         SPACE ,                                                        37210000
EVENTINI DS    0H                                                       37220000
         STM   R0,R9,EVENTSAV          * Save R0 through R9 temporarily 37230000
         LA    R6,INPUTDS              * Point R6 to the input FSCB     37240000
         USING FSCBD,R6                * Map out the FSCBD for input    37250000
         MVC   FSCBFILE,TIMFNAME       * Move the complete input fileid 37260000
         FSOPEN FSCB=INPUTDS,ERROR=OPENERR,OPENTYP=WRITE,FORM=E,MSG=YES*37270000
               ,NOREC=1,RECFM=V        * Open the input file            37280000
         LA    R2,RECRDMAP             * Point R2 to the buffer         37290000
         SPACE ,                                                        37300000
RECREAD  EQU   *                                                        37310000
         LA    R14,EVNTBUFF            * Point R14 to storage for clear 37320000
         LA    R15,L'EVNTBUFF          * R15 is the length of the area  37330000
         LA    R3,0                    * Force the target length to 0   37340000
         MVCL  R14,R2                  * Clear the buffer storage to 0  37350000
         SPACE ,                                                        37360000
         LA    R2,RECRDMAP             * Point R2 to the buffer         37370000
         LA    R5,RECMAPLN             * Get the maximum record length  37380000
         MVI   RECRDMAP,C' '           * Move a blank into the I/O buff 37390000
         MVC   RECRDMAP+1(RECOPERL),RECRDMAP * Clear the operation buff 37400000
         MVC   RECDATA(L'RECDATA),RECDATA-1  * Clear the data portion   37410000
         FSREAD FSCB=INPUTDS,ERROR=CKRETCOD,BUFFER=(R2),RECNO=0,NOREC=1*37420000
               ,BSIZE=(R5),FORM=E      * Read a record from the file    37430000
         B     READRC0                 * Branch (RC = 0)                37440000
         SPACE ,                                                        37450000
CKRETCOD EQU   *                                                        37460000
         CH    R15,HWD12               * End-Of-File reached ???        37470000
         BE    READDONE                * Yes, close the input & output  37480000
         SPACE ,                                                        37490000
         B     READERR                 * Any other non-zero RC -> ERROR 37500000
         SPACE ,                                                        37510000
READRC0  EQU   *                       * At this point R0 = rec length  37520000
         STH   R0,TEMPLEN              * Save the record length         37530000
         LH    R4,IDENTNUM             * Start with the first record    37540000
         LA    R4,1(,R4)               * Increment the number of recs   37550000
         STH   R4,IDENTNUM             * Save the next event id number  37560000
         CLI   RECDONE,C'*'            * Record to be ignored ?         37570000
         BE    RECREAD                 * Yes, process the next record   37580000
         SPACE ,                                                        37590000
         XC    PROGFLOW,PROGFLOW       * Clear the pgm flow cntrl bits  37600000
         STH   R0,RECORDLN             * Save the current record length 37610000
         MVC   PARMTEMP,BLANKS         * Clear the temp parm storage    37620000
         MVC   PARMTEMP(L'RECDATE),RECDATE * Move the date file parm    37630000
         LA    R4,PARMTEMP             * Point R4 to date buffer field  37640000
         LR    R6,R4                   * Point R6 to the date buffer    37650000
         LR    R0,R4                   * Point R0 to the parm buffer    37660000
         LA    R1,L'PARMTEMP(,R4)      * Point R1 to the end of the num 37670000
         BAS   R9,GETLEN               * Find out the length of it      37680000
         BAS   R9,CHKDATE              * Go, check if a valid date/time 37690000
         BC    CC0,RDATEFND            * Match found. Continue parsing  37700000
         SPACE ,                                                        37710000
         BAS   R9,CHKSPEC              * Chk for other valid date/time  37720000
         BC    CC1,BADFPARM            * If CC1, parameter is invalid   37730000
         SPACE ,                                                        37740000
RDATEFND EQU   *                                                        37750000
         MVC   PARMTEMP,BLANKS         * Clear the temp parm storage    37760000
         MVC   PARMTEMP(L'RECTIME),RECTIME * Move the time file parm    37770000
         LA    R1,L'PARMTEMP(,R4)      * Point R1 to the end of the num 37780000
         BAS   R9,GETLEN               * Find out the length of it      37790000
         BAS   R9,CHKDATE              * Go, check if a valid date/time 37800000
         BC    CC0,RTIMEFND            * Match found. Continue parsing  37810000
         SPACE ,                                                        37820000
         BAS   R9,CHKSPEC              * Chk for other valid date/time  37830000
         BC    CC1,BADFPARM            * If CC1, parameter is invalid   37840000
         SPACE ,                                                        37850000
RTIMEFND EQU   *                                                        37860000
         CLC   RECUNTID,BLANKS         * Do we have an until clause ?   37870000
         BE    NORDUNTL                * No, we don't. Let's bypass it  37880000
         SPACE ,                                                        37890000
         OI    PROGFLOW,UNTLKINC       * Indicate "UNTIL" keyword       37900000
         MVC   PARMTEMP,BLANKS         * Clear the temp parm storage    37910000
         MVC   PARMTEMP(L'RECUNTID),RECUNTID Move the until date parm   37920000
         LA    R1,L'PARMTEMP(,R4)      * Point R1 to the end of the num 37930000
         BAS   R9,GETLEN               * Find out the length of it      37940000
         BAS   R9,CHKDATE              * Go, check if a valid date/time 37950000
         BC    CC1,RUNTLCHK            * Match not found. Try again     37960000
         SPACE ,                                                        37970000
         OI    PROGFLOW,UNTLPINC       * Ind "UNTIL" parm was processed 37980000
         B     RUNTLFND                * Go, look for "UNTIL" time      37990000
         SPACE ,                                                        38000000
RUNTLCHK EQU   *                                                        38010000
         BAS   R9,CHKSPEC              * Chk for other valid date/time  38020000
         BC    CC1,BADFPARM            * If CC1, parameter is invalid   38030000
         SPACE ,                                                        38040000
         OI    PROGFLOW,UNTLPINC       * Ind "UNTIL" parm was processed 38050000
RUNTLFND EQU   *                                                        38060000
         MVC   PARMTEMP,BLANKS         * Clear the temp parm storage    38070000
         MVC   PARMTEMP(L'RECUNTIT),RECUNTIT Move the until time parm   38080000
         LA    R1,L'PARMTEMP(,R4)      * Point R1 to the end of the num 38090000
         BAS   R9,GETLEN               * Find out the length of it      38100000
         BAS   R9,CHKDATE              * Go, check if a valid date/time 38110000
         BC    CC1,RUNTLFN2            * Not a regular time, continue   38120000
         SPACE ,                                                        38130000
         OI    PROGFLOW+1,UNTLQINC     * Ind "UNTIL" time was processed 38140000
         B     NORDUNTL                * Go, look for "UNTIL" time      38150000
         SPACE ,                                                        38160000
RUNTLFN2 EQU   *                                                        38170000
         BAS   R9,CHKSPEC              * Chk for other valid date/time  38180000
         BC    CC1,BADFPARM            * If CC1, parameter is invalid   38190000
         SPACE ,                                                        38200000
         OI    PROGFLOW+1,UNTLQINC     * Ind "UNTIL" time was processed 38210000
NORDUNTL EQU  *                                                         38220000
         MVC   PARMTEMP,BLANKS         * Clear the temp parm storage    38230000
         MVC   PARMTEMP(L'RECFUNC),RECFUNC * Move the function parm     38240000
         LA    R1,L'PARMTEMP(,R4)      * Point R1 to the end of the num 38250000
         BAS   R9,GETLEN               * Find out the length of it      38260000
         BAS   R9,CHKSPEC              * Chk for other valid date/time  38270000
         BC    CC1,BADFPARM            * If CC1, parameter is invalid   38280000
         SPACE 2                                                        38290000
         CLC   RECLDATE,BLANKS         * Any last executn date present? 38300000
         BE    NOLASTDT                * No, bypass the last time chk   38310000
         SPACE ,                                                        38320000
         MVC   PARMTEMP,BLANKS         * Clear the temp parm storage    38330000
         MVC   PARMTEMP(L'RECLDATE),RECLDATE  Move the last exec date   38340000
         LA    R6,RECLDATE             * Point R6 to RECLDATE field     38350000
         BAS   R9,VALIDATE             * Chk for other valid date/time  38360000
         BC    CC1,BADFPARM            * If CC1, parameter is invalid   38370000
         SPACE ,                                                        38380000
         MVC   RECLDATE,DATEVAL        * Move the validated date        38390000
         CLC   RECLDATE,BLANKS         * Any last executn date present? 38400000
         BE    NOLASTDT                * No, bypass the last time chk   38410000
         SPACE ,                                                        38420000
         MVC   PARMTEMP,BLANKS         * Clear the temp parm storage    38430000
         MVC   PARMTEMP(L'RECLTIME),RECLTIME  Move the last exec time   38440000
         LA    R6,RECLTIME             * Point R6 to RECLTIME field     38450000
         BAS   R9,VALITIME             * Chk for other valid date/time  38460000
         BC    CC1,BADFPARM            * If CC1, parameter is invalid   38470000
         SPACE ,                                                        38480000
         MVC   RECLTIME,TIMEVAL        * Move the validated time        38490000
NOLASTDT EQU   *                                                        38500000
         LH    R1,RECORDLN             * Get the record length into R1  38510000
         LA    R0,RECOPERL             * Get the fixed portion length   38520000
         SR    R1,R0                   * Calculate the msg length itslf 38530000
         STH   R1,MESSAGLN             * Save the message length        38540000
         LA    R3,RECDATA              * Point to the msg/cmd in record 38550000
         LA    R4,EVNTDATA-EVENT+EVNTBUFF * Point R4 to data buffer     38560000
         BCTR  R1,R0                   * Decrement R1 for EXecute       38570000
         EX    R1,MOVEPARM             * Execute the following:         38580000
*+++     MVC   0(*-*,R4),0(R3)         * Move the non-tokenized cmd/msg 38590000
         LA    R1,EVNTFIXL+1(,R1)      * Calc the free storage needed   38600000
         STH   R1,EVNTELEN-EVENT+EVNTBUFF * Free storage bytes to reqst 38610000
         LH    R2,IDENTNUM             * Get the next avail ident num   38620000
         STH   R2,(EVNTIDEN-EVENT)+EVNTBUFF * Set up the EVENT's ident  38630000
         BAS   R9,SETEVENT             * Go, set up the current event   38640000
         B     RECREAD                 * Go, read the next record       38650000
READDONE EQU   *                                                        38660000
         LM    R0,R9,EVENTSAV          * Restore R0 through R9          38670000
         BR    R9                      * Return to caller               38680000
         EJECT ,                                                        38690000
*********************************************************************** 38700000
***                                                                 *** 38710000
***  Exit routines                                                  *** 38720000
***                                                                 *** 38730000
*********************************************************************** 38740000
EXITENA  EQU   *                                                        38750000
         ENABLE INTTYPE=ALL,MF=(E,NUCENAWA) Enable all interrupts back  38760000
         CLC   ANCEVENT,NULL           * Are there any EVENTs pending ? 38770000
         BZ    NOENABLE                * No, don't turn on clk comp msk 38780000
         SPACE ,                                                        38790000
         TM    PROGLOBL,SUSPNDOP       * Is the processing suspended ?  38800000
         BO    NOENABLE                * Yes, do not enable the mask    38810000
         SPACE ,                                                        38820000
         TM    PROGLOBL,INSLIHOP       * SCHEDULE called from SLIH ???  38830000
         BO    NOENABLE                * Yes, do not enable the mask    38840000
         SPACE ,                                                        38850000
         OI    CONTROL0+2,X'08'        * Turn on  the Clock comp mask   38860000
         LCTL  C0,C0,CONTROL0          * Load CR0 with the old value    38870000
         B     EXIT                    * Go, return to caller           38880000
         SPACE ,                                                        38890000
NOENABLE EQU   *                                                        38900000
         STCTL C0,C0,CONTROL0          * Save the contents of CR0       38910000
         NI    CONTROL0+2,X'08'        * Turn off the Clock comp mask   38920000
         LCTL  C0,C0,CONTROL0          * Load CR0 with the old value    38930000
ERREXIT  EQU   *                                                        38940000
EXIT     EQU   *                                                        38950000
         LA    R0,WRKARLEN             * Get work area length in dwords 38960000
         LR    R2,R13                  * And its address for release    38970000
         L     R9,RETCODE              * Load R9 with our return code   38980000
         L     R13,OLDR13              * Get old R13 before it is gone  38990000
         CMSSTOR RELEASE,DWORDS=(R0),ADDR=(R2),TYPCALL=BRANCH           39000000
NOFRET   EQU   *                                                        39010000
         LR    R15,R9                  * Put the return code into R15   39020000
         LM    R0,R14,0(R13)           * Restore all registers          39030000
         BR    R14                     * Return to caller               39040000
         EJECT                                                          39050000
*********************************************************************** 39060000
***                                                                 *** 39070000
***  Second level external interrupt handler for Clock Comparator.  *** 39080000
***                                                                 *** 39090000
*********************************************************************** 39100000
EXTSLIH  DS    0H                                                       39110000
         PUSH  USING                   * We will establish new bases    39120000
         USING EXTSLIH,R12,R11,R10,R7,R14 * Start addr of EXTSLIH       39130000
         LA    R11,2048(,R12)          * And use R11 to map the rest    39140000
         LA    R11,2048(,R11)          * Establish R11 as the 2nd base  39150000
         LA    R10,2048(,R11)          * Establish R10 as the 3rd base  39160000
         LA    R10,2048(,R10)          * Establish R10 as the 3rd base  39170000
         LA    R7,2048(,R10)           * Establish R7  as the 4th base  39180000
         LA    R7,2048(,R7)            * Establish R7  as the 4th base  39190000
         L     R7,BASE7                * Get the original R7 base       39200000
         LM    R10,R12,BASE1012        * Get the original R10-R12 bases 39210000
         POP   USING                   * Drop the previous bases        39220000
         PUSH  USING                   * We will establish new bases    39230000
         USING SCHEDULE,R12,R11,R10,R7,R14 * Addr from the start of PGM 39240000
         STM   R0,R15,0(R13)           * Save R0 through R15 EXTUSAVE   39250000
         LA    R14,2048(,R7)           * Set up the 5th base reg (temp) 39260000
         LA    R14,2048(,R14)          * Set up the 5th base reg (temp) 39270000
         ST    R13,SLIHSAVE            * Save the R13 in SLIHSAVE       39280000
         LA    R13,SLIHSAVE            * And point R13 to it            39290000
         LA    R0,(SLIHFREE+7)/8       * Get the length of stor needed  39300000
         CMSSTOR OBTAIN,DWORDS=(R0),SUBPOOL='USER',TYPCALL=BRANCH,     *39310000
               ERROR=ERR109SW,MSG=NO,LOC=SAME * Get the storage for it  39320000
         LR    R14,R1                  * Point R14 to the free storage  39330000
         LR    R15,R0                  * R15 is the length of the area  39340000
         SLL   R15,3                   * Convert the length to bytes    39350000
         LA    R3,0                    * Force the target length to 0   39360000
         MVCL  R14,R2                  * Clear the FREE storag to zeros 39370000
         LR    R9,R1                   * Save R1 in R9 for future ref   39380000
         SPACE ,                                                        39390000
         USING SLIHDSEC,R9             * Make use of FREE storage       39400000
         MVI   FLOWFLG1,X'00'          * Clear the flow flag            39410000
         STCTL C0,C0,CR0SAVE           * Save the CTL register 0        39420000
         NI    CR0SAVE+2,255-X'08'     * Turn off the Clock comp mask   39430000
         LCTL  C0,C0,CR0SAVE           * Get the altered CR 0           39440000
         OI    PROGLOBL,INSLIHOP       * Mark as in SLIH execution      39450000
         L     R8,NUCSMBLK             * Get addr of SM control block   39460000
         LTR   R8,R8                   * Does the control block exist?  39470000
         BZ    NOTFSCRN                * No, Fullscreen gotta be OFF    39480000
         SPACE ,                                                        39490000
         USING SCRCB,R8                * Map the Session Manager ctl bk 39500000
         TM    SCRFLAG4,SCRMGRON       * Is fullscreen 'ON' ?           39510000
         BZ    NOTFSCRN                * No, do not set the flag bit    39520000
         SPACE ,                                                        39530000
         OI    FLOWFLG1,FULLSCRN       * Remember, fullscreen is 'ON'   39540000
NOTFSCRN EQU   *                                                        39550000
         DROP  R8                      * Stop mapping the SM control bk 39560000
*********************************************************************** 39570000
***                                                                 *** 39580000
***  WAITSAVE registers in  NUCON have to be preserved,  since  we  *** 39590000
***  may be required to do I/O. Here, we are violating most of the  *** 39600000
***  rules of programming for SLIH's and FLIH's, while keeping the  *** 39610000
***  code re-entrant.                                               *** 39620000
***                                                                 *** 39630000
*********************************************************************** 39640000
         MVC   WAITSSAV(64),WAITSAVE   * Save the original WAITSAVE     39650000
         USING EVENT,R8                * Map the EVENT block in R8      39660000
         L     R8,LSTEVENT             * Get the scheduled event ptr    39670000
         LTR   R8,R8                   * Is there one ?                 39680000
         BZ    EVTCOMPL                * No, just exit                  39690000
         SPACE ,                                                        39700000
         STCKC CLCKCOMP                * Save current clock comp value  39710000
         CLC   EVNTCLCK(5),CLCKCOMP    * Is it the scheduled event pop? 39720000
         BE    OUREVENT                * Yes, it is. Process it         39730000
         SPACE ,                                                        39740000
         LR    R5,R9                   * Save R9 temporarily            39750000
         OI    FLOWFLG1,UNSOLIC        * Mark the interrupt unsolicited 39760000
         LA    R14,2048(,R7)           * Get back the temp base in R14  39770000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 39780000
         LA    R15,ERRSC25             * Point R15 to the EMSG to write 39790000
         BAS   R9,WRITEMSG             * Go, write the error message    39800000
         SPACE ,                                                        39810000
         LR    R9,R5                   * Restore R9 from R5             39820000
         B     EVTDONE                 * And join the code at WAITT     39830000
         SPACE ,                                                        39840000
OUREVENT EQU   *                                                        39850000
         LH    R3,EVNTELEN             * Get the len of this EVENT blk  39860000
         LA    R0,EVNTFIXL             * Get the fixed portion length   39870000
         SR    R3,R0                   * Calculate the length of data   39880000
         LA    R2,EVNTDATA             * Point to the MSG/CP/CMS data   39890000
         SPACE ,                                                        39900000
         TM    EVNTFLG1,EVNTIMM        * Is this an immediate function? 39910000
         BO    DOIMMED                 * Yes, process it accordingly    39920000
         SPACE ,                                                        39930000
         TM    EVNTFLG1,EVNTFIN        * Event finshed some time befor? 39940000
         BO    EVTDONE2                * Yes, just reschedule it        39950000
         SPACE ,                                                        39960000
DOIMMED  EQU   *                                                        39970000
         TM    EVNTFLG1,EVNTMSG        * Is this a console message req? 39980000
         BNO   TMEVTCP                 * No, go look for CP command     39990000
         SPACE ,                                                        40000000
         LINEWRT DATA=((R2),(R3)),MF=(E,LINWRLST)                       40010000
         B     EVTDONE                 * Console message write complete 40020000
         SPACE ,                                                        40030000
TMEVTCP  EQU   *                                                        40040000
         TM    EVNTFLG1,EVNTCP         * Is this a CP command request?  40050000
         BNO   TMEVTCMS                * No, go look for CMS command    40060000
         SPACE ,                                                        40070000
         DIAG  R2,R3,X'08'             * Issue a CP command             40080000
         B     EVTDONE2                * CP command execution complete  40090000
         SPACE ,                                                        40100000
TMEVTCMS EQU   *                                                        40110000
         LA    R4,TESTCMDO                                              40120000
         SCAN  TEXT=((R2),(R3)),BUFFER=((R4),L'TESTCMDO),ERROR=*,      *40130000
               MF=(E,SCANLST)                                           40140000
         TM    OPTFLAGS,NOVMREAD       * Is AUTOREAD OFF ?              40150000
         BZ    RDSVC                   * No, don't set the direct flag  40160000
         SPACE ,                                                        40170000
         OI    MISFLAGS,QSWITCH        * DMSCRD 'QUIET' switch is ON    40180000
RDSVC    EQU   *                                                        40190000
         CMSCALL PLIST=(R1),EPLIST=(R0),CALLTYP=CMS,COPY=YES,          *40200000
               ERROR=*                                                  40210000
EVTDONE  EQU   *                                                        40220000
         WAITT ,                                                        40230000
EVTDONE2 EQU   *                                                        40240000
         ENABLE INTTYPE=NONE,MF=(E,NUCENAWA)                            40250000
         NI    EVNTFLG1,255-EVNTFIN    * Reset the re-scheduling bit    40260000
         TM    EVNTFLG1,EVNTIMM        * Is this an immediate event ?   40270000
         BNO   EVTDONE3                * No, don't mark it as processed 40280000
         SPACE ,                                                        40290000
         OI    EVNTFLG2,EVNTIMM2       * Mark the immediate processed   40300000
EVTDONE3 EQU   *                                                        40310000
         NI    EVNTFLG1,255-EVNTIMM    * Turn off "IMMEDIATE" indicator 40320000
         MVC   WAITSAVE(64),WAITSSAV   * Restore the original WAITSAVE  40330000
         B     EVTCOMPL                * Branch to event completion     40340000
         SPACE ,                                                        40350000
EVTCOMPL EQU   *                                                        40360000
         LA    R0,(SLIHFREE+7)/8       * Get the length of stor to FRET 40370000
         CMSSTOR RELEASE,DWORDS=(R0),ADDR=(R9),TYPCALL=BRANCH           40380000
         TM    FLOWFLG1,UNSOLIC        * Unsolicited interrupt ?        40390000
         BNO   EVTCOMP1                * No, bypass the following EMSG  40400000
         SPACE ,                                                        40410000
         LA    R0,0                    * Mark for SCHEDMIN routine      40420000
         L     R8,ANCEVENT             * Get the anchor EVENT pointer   40430000
         B     EVTCOMP2                * Go, run the scheduling routine 40440000
EVTCOMP1 EQU   *                                                        40450000
         LA    R0,1                    * Mark as a call from EXTSLIH    40460000
EVTCOMP2 EQU   *                                                        40470000
         L     R15,ASCHEDUL            * Get the ptr to sched routine   40480000
         BASR  R14,R15                 * Go, re-schedule another event  40490000
         SPACE ,                                                        40500000
         NI    PROGLOBL,255-INSLIHOP   * Reset the "in SLIH" bit        40510000
         LA    R15,0                   * Function handled RC (default)  40520000
*                                      * RC = 4 could have been used    40530000
         TM    FLOWFLG1,UNSOLIC        * Unsolicited interrupt ?        40540000
         BNO   HANDLED                 * No, created by us              40550000
         SPACE ,                                                        40560000
         LA    R15,0                   * Tell CMS to post an ECB if any 40570000
*********************************************************************** 40580000
***                                                                 *** 40590000
***  Although the interrupt wasn't caused by us, put in an RC = 4.  *** 40600000
***  We may want to do something in the future to address this.     *** 40610000
***  Also, we are not doing an ENABLE INTTYPE=ALL, to prevent loss  *** 40620000
***  of control until the exit point.                               *** 40630000
***                                                                 *** 40640000
*********************************************************************** 40650000
HANDLED  EQU   *                                                        40660000
         STCTL C0,C0,0(R0)             * Save the altered CR 0 in loc 0 40670000
         CLC   ANCEVENT,NULL           * Are there any events queued?   40680000
         BE    DONTENAB                * No, then don't enable clc comp 40690000
         SPACE ,                                                        40700000
         OI    2(R0),X'08'             * Turn on the Clock comp mask    40710000
DONTENAB EQU   *                                                        40720000
         L     R13,0(,R13)             * Get the old R13 back           40730000
         LM    R0,R12,0(R13)           * Restore R0 through R13         40740000
         L     R14,56(,R13)            * Restore return addr in R14     40750000
         LCTL  C0,C0,0(R0)             * Get the altered CR 0           40760000
         BR    R14                     * Return to caller               40770000
         DROP  R9                      * Stop mapping FREE stor DSECT   40780000
SLIHSAVE DS    17F                     * Temporary abend save area      40790000
*                                      * will be passed to SCHEDULR as  40800000
*                                      * if the reqst came from cmdline 40810000
         SPACE 2                                                        40820000
SLIHDSEC DSECT ,                                                        40830000
CLCKCOMP DS    D                       * Clock comparator value         40840000
CR0SAVE  DS    F                       * Save location for CR0          40850000
WAITSSAV DS    16F                     * Original WAITSAVE holding area 40860000
         DS    0D                                                       40870000
TESTCMDO DS    CL288                   * Buffer for scanning the text   40880000
FLOWFLG1 DS    X                       * Flow Control flag 1            40890000
FULLSCRN EQU   X'80'                   * Full screen is 'ON' bit        40900000
UNSOLIC  EQU   X'40'                   * Unsolicited timer interrupt    40910000
SCANLST  SCAN   MF=L                   * To be used with SCAN macro     40920000
LINWRLST LINEWRT  MF=L                 * To be used with LINEWRT macro  40930000
SLIHFREE EQU   *-SLIHDSEC              * Len of the SLIH FREE stor DSEC 40940000
EXTSLIHL EQU   *-EXTSLIH               * Len of the abend recov routine 40950000
         POP   USING                   * Cont with the original bases   40960000
         EJECT ,                                                        40970000
SCHEDULE CSECT ,                                                        40980000
         SPACE ,                                                        40990000
*********************************************************************** 41000000
***                                                                 *** 41010000
***  Error message routines                                         *** 41020000
***                                                                 *** 41030000
*********************************************************************** 41040000
         SPACE ,                                                        41050000
ERR109SW DS    0H                                                       41060000
         LA    R2,NOFRET               * Set R2 for no FRET             41070000
         B     ERR109                  * Continue                       41080000
ERR109S  EQU   *                                                        41090000
         LA    R2,ERREXIT              * Set R2 for FRET                41100000
ERR109   EQU   *                                                        41110000
         DMSMSG NUM=109                                                 41120000
         LA    R15,RC104               * Load bad return code           41130000
         ST    R15,RETCODE             * Set bad return code            41140000
         BR    R2                                                       41150000
         SPACE 1                                                        41160000
NUCXFAIL EQU   *                                                        41170000
         ST    R15,RETCODE             * Save NUCEXT return code        41180000
         LA    R14,2048(,R7)           * Get back the temp base in R14  41190000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 41200000
         LA    R15,ERRSC05             * Point R15 to the error message 41210000
         BAS   R9,WRITEMSG             * Go write the output message    41220000
         B     ERREXIT                 * Exit this program              41230000
         SPACE ,                                                        41240000
INVALID  EQU   *                                                        41250000
         LA    R14,2048(,R7)           * Get back the temp base in R14  41260000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 41270000
         LA    R15,ERRSC02             * Point to the correct ERRMSG    41280000
         BAS   R9,WRITEMSG             * Go write the output message    41290000
         SPACE ,                                                        41300000
         LA    R15,1                   * Load a bad return code         41310000
         ST    R15,RETCODE             * And save it for later          41320000
         B     ERREXIT                 * Exit this program              41330000
         SPACE ,                                                        41340000
INVALID2 EQU   *                                                        41350000
         LA    R14,2048(,R7)           * Get back the temp base in R14  41360000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 41370000
         LA    R15,ERRSC03             * Point to the correct ERRMSG    41380000
         LA    R3,8(,R1)               * Point R3 to the token in error 41390000
         BAS   R9,WRITEMS3             * Go write the output message    41400000
         SPACE ,                                                        41410000
         LA    R15,3                   * Load a bad return code         41420000
         ST    R15,RETCODE             * And save it for later          41430000
         B     ERREXIT                 * Exit this program              41440000
         SPACE ,                                                        41450000
INVALID3 EQU   *                                                        41460000
         LA    R14,2048(,R7)           * Get back the temp base in R14  41470000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 41480000
         LA    R15,ERRSC$3             * Point to the correct ERRMSG    41490000
         BAS   R9,WRITEMSG             * Go write the output message    41500000
         SPACE ,                                                        41510000
         LA    R15,3                   * Load a bad return code         41520000
         ST    R15,RETCODE             * And save it for later          41530000
         B     ERREXIT                 * Exit this program              41540000
         SPACE ,                                                        41550000
NONUCSTO EQU   *                                                        41560000
         LA    R14,2048(,R7)           * Get back the temp base in R14  41570000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 41580000
         LA    R15,ERRSC04             * Point to the correct ERRMSG    41590000
         BAS   R9,WRITEMSG             * Go write the output message    41600000
         SPACE ,                                                        41610000
         LA    R15,04                  * Load a bad return code         41620000
         ST    R15,RETCODE             * And save it for later          41630000
         B     ERREXIT                 * Exit this program              41640000
         SPACE ,                                                        41650000
ALRDYON  EQU   *                                                        41660000
         LA    R14,2048(,R7)           * Get back the temp base in R14  41670000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 41680000
         LA    R15,ERRSC06             * Point to the correct ERRMSG    41690000
         BAS   R9,WRITEMSG             * Go write the output message    41700000
         SPACE ,                                                        41710000
         LA    R15,6                   * Load a bad return code         41720000
         ST    R15,RETCODE             * And save it for later          41730000
         B     ERREXIT                 * Exit this program              41740000
         SPACE ,                                                        41750000
HNDERR   EQU   *                                                        41760000
         ST    R15,RETCODE             * Save the HNDEXT return code    41770000
         LA    R14,2048(,R7)           * Get back the temp base in R14  41780000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 41790000
         LA    R15,ERRSC08             * Point to the correct ERRMSG    41800000
         BAS   R9,WRITEMSG             * Go write the output message    41810000
         SPACE ,                                                        41820000
         B     ERREXIT                 * Exit this program              41830000
         SPACE ,                                                        41840000
ALRDYOFF EQU   *                                                        41850000
         LA    R14,2048(,R7)           * Get back the temp base in R14  41860000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 41870000
         LA    R15,ERRSC09             * Point to the correct ERRMSG    41880000
         BAS   R9,WRITEMSG             * Go write the output message    41890000
         SPACE ,                                                        41900000
         LA    R15,9                   * Load a bad return code         41910000
         ST    R15,RETCODE             * And save it for later          41920000
         B     ERREXIT                 * Exit this program              41930000
         SPACE ,                                                        41940000
NOSLIH   EQU   *                                                        41950000
         LA    R14,2048(,R7)           * Get back the temp base in R14  41960000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 41970000
         LA    R15,ERRSC11             * Point to the correct ERRMSG    41980000
         BAS   R9,WRITEMSG             * Go write the output message    41990000
         SPACE ,                                                        42000000
         LA    R15,11                  * Load a bad return code         42010000
         ST    R15,RETCODE             * And save it for later          42020000
         B     ERREXIT                 * Exit this program              42030000
         SPACE ,                                                        42040000
OPENERR  EQU   *                                                        42050000
         ST    R15,RETCODE             * And save it for later          42060000
         LA    R14,2048(,R7)           * Get back the temp base in R14  42070000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 42080000
         LA    R15,ERRSC12             * Point to the correct ERRMSG    42090000
         BAS   R9,WRITEMSG             * Go write the output message    42100000
         SPACE ,                                                        42110000
         B     ERREXIT                 * Exit this program              42120000
         SPACE ,                                                        42130000
NOEPLIST EQU   *                                                        42140000
         LA    R14,2048(,R7)           * Get back the temp base in R14  42150000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 42160000
         LA    R15,ERRSC13             * Point to the correct ERRMSG    42170000
         BAS   R9,WRITEMSG             * Go write the output message    42180000
         SPACE ,                                                        42190000
         LA    R15,13                  * Load a bad return code         42200000
         ST    R15,RETCODE             * And save it for later          42210000
         B     ERREXIT                 * Exit this program              42220000
         SPACE ,                                                        42230000
BADPARM  EQU   *                                                        42240000
         LA    R14,2048(,R7)           * Get back the temp base in R14  42250000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 42260000
         LA    R15,ERRSC14             * Point to the correct ERRMSG    42270000
         LR    R3,R0                   * Point R3 to start of parm      42280000
         LR    R4,R1                   * Set R4 to parameter's length   42290000
         BAS   R9,WRITEMS4             * Go write the output message    42300000
         SPACE ,                                                        42310000
         LA    R15,14                  * Load a bad return code         42320000
         ST    R15,RETCODE             * And save it for later          42330000
         B     ERREXIT                 * Exit this program              42340000
         SPACE ,                                                        42350000
MISPARM  EQU   *                                                        42360000
         LA    R14,2048(,R7)           * Get back the temp base in R14  42370000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 42380000
         LA    R15,ERRSC15             * Point to the correct ERRMSG    42390000
         BAS   R9,WRITEMSG             * Go write the output message    42400000
         SPACE ,                                                        42410000
         LA    R15,15                  * Load a bad return code         42420000
         ST    R15,RETCODE             * And save it for later          42430000
         B     ERREXIT                 * Exit this program              42440000
         SPACE ,                                                        42450000
MISCMDMS EQU   *                                                        42460000
         LA    R14,2048(,R7)           * Get back the temp base in R14  42470000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 42480000
         LA    R15,ERRSC16             * Point to the correct ERRMSG    42490000
         BAS   R9,WRITEMSG             * Go write the output message    42500000
         SPACE ,                                                        42510000
         LA    R15,16                  * Load a bad return code         42520000
         ST    R15,RETCODE             * And save it for later          42530000
         B     ERREXIT                 * Exit this program              42540000
         SPACE ,                                                        42550000
BADSUSP  EQU   *                                                        42560000
         LA    R14,2048(,R7)           * Get back the temp base in R14  42570000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 42580000
         LA    R15,ERRSC26             * Point to the correct ERRMSG    42590000
         BAS   R9,WRITEMSG             * Go write the output message    42600000
         SPACE ,                                                        42610000
         LA    R15,26                  * Load a bad return code         42620000
         ST    R15,RETCODE             * And save it for later          42630000
         B     ERREXIT                 * Exit this program              42640000
         SPACE ,                                                        42650000
BADRESUM EQU   *                                                        42660000
         LA    R14,2048(,R7)           * Get back the temp base in R14  42670000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 42680000
         LA    R15,ERRSC27             * Point to the correct ERRMSG    42690000
         BAS   R9,WRITEMSG             * Go write the output message    42700000
         SPACE ,                                                        42710000
         LA    R15,27                  * Load a bad return code         42720000
         ST    R15,RETCODE             * And save it for later          42730000
         B     ERREXIT                 * Exit this program              42740000
         SPACE ,                                                        42750000
WRITERR  EQU   *                                                        42760000
         ST    R15,RETCODE             * And save it for later          42770000
         FSCLOSE FSCB=INPUTDS,ERROR=*  * Close the input file           42780000
         FSCLOSE FSCB=OUTPUTDS,ERROR=* * Close the output file          42790000
         LA    R14,2048(,R7)           * Get back the temp base in R14  42800000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 42810000
         LA    R15,ERRSC17             * Point to the correct ERRMSG    42820000
         BAS   R9,WRITEMSG             * Go write the output message    42830000
         SPACE ,                                                        42840000
         B     ERREXIT                 * Exit this program              42850000
         SPACE ,                                                        42860000
BADFPARM EQU   *                                                        42870000
         LA    R14,2048(,R7)           * Get back the temp base in R14  42880000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 42890000
         LA    R15,ERRSC18             * Point to the correct ERRMSG    42900000
         LA    R3,PARMTEMP             * Point R3 to start of parm      42910000
         LA    R4,L'PARMTEMP           * Set R4 to parameter's length   42920000
         LH    R5,IDENTNUM             * Get the record number          42930000
         BAS   R9,WRITEMS5             * Go write the output message    42940000
         SPACE ,                                                        42950000
         B     ERREXIT                                                  42960000
         SPACE ,                                                        42970000
READERR  EQU   *                                                        42980000
         ST    R15,RETCODE             * And save it for later          42990000
         FSCLOSE FSCB=INPUTDS,ERROR=*  * Close the input file           43000000
         FSCLOSE FSCB=OUTPUTDS,ERROR=* * Close the output file          43010000
         LA    R14,2048(,R7)           * Get back the temp base in R14  43020000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 43030000
         LA    R15,ERRSC19             * Point to the correct ERRMSG    43040000
         BAL   R9,WRITEMSG             * Go write the output message    43050000
         SPACE ,                                                        43060000
         B     ERREXIT                 * Exit this program              43070000
         SPACE ,                                                        43080000
BADEVTID EQU   *                                                        43090000
         LA    R14,2048(,R7)           * Get back the temp base in R14  43100000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 43110000
         LA    R15,ERRSC20             * Point to the correct ERRMSG    43120000
         LR    R3,R2                   * Set R3 to point to the parm    43130000
         BAS   R9,WRITEMS3             * Go write the output message    43140000
         SPACE ,                                                        43150000
         LA    R15,20                  * Load a bad return code         43160000
         ST    R15,RETCODE             * And save it for later          43170000
         B     EXITENA                 * Exit this program after clnup  43180000
         SPACE ,                                                        43190000
NOTEVTID EQU   *                                                        43200000
         LA    R14,2048(,R7)           * Get back the temp base in R14  43210000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 43220000
         LA    R15,ERRSC24             * Point to the correct ERRMSG    43230000
         LR    R3,R2                   * Set R3 to point to the parm    43240000
         BAS   R9,WRITEMS3             * Go write the output message    43250000
         SPACE ,                                                        43260000
         LA    R15,24                  * Load a bad return code         43270000
         ST    R15,RETCODE             * And save it for later          43280000
         B     EXITENA                 * Exit this program after clnup  43290000
         SPACE ,                                                        43300000
EXTRAPRM EQU   *                                                        43310000
         LA    R14,2048(,R7)           * Get back the temp base in R14  43320000
         LA    R14,2048(,R14)          * ..which will addr the 5th page 43330000
         LA    R15,ERRSC21             * Point to the correct ERRMSG    43340000
         LA    R3,TOKEN3-TOKENS(,R1)   * Set R3 to point to the parm    43350000
         BAS   R9,WRITEMS3             * Go write the output message    43360000
         SPACE ,                                                        43370000
         LA    R15,21                  * Load a bad return code         43380000
         ST    R15,RETCODE             * And save it for later          43390000
         B     ERREXIT                 * Exit this program              43400000
         SPACE ,                                                        43410000
EMPTYCHN EQU   *                                                        43420000
         LA    R4,NOCHAIN              * Point to the correct msg       43430000
         LA    R3,L'NOCHAIN            * Get the length of it           43440000
         BAS   R9,OUTPUT               * Go write/queue the output msg  43450000
         SPACE ,                                                        43460000
         LA    R15,0                   * Load a bad return code         43470000
         ST    R15,RETCODE             * And save it for later          43480000
         B     EXITENA                 * Exit this program              43490000
         EJECT ,                                                        43500000
TIMERHLP DS    0H                                                       43510000
         LA    R1,HELPSCH              * Point R1 to the HELP command   43520000
         CMSCALL PLIST=(R1),CALLTYP=PROGRAM,COPY=YES,ERROR=*            43530000
         B     EXIT                    * Return to caller               43540000
         EJECT ,                                                        43550000
OUTPUT   EQU   *                                                        43560000
*********************************************************************** 43570000
***                                                                 *** 43580000
***  This subroutine will determine whether the output should  be   *** 43590000
***  directed to the terminal or the console stack. Then, it will   *** 43600000
***  write ot stack the output.                                     *** 43610000
***                                                                 *** 43620000
*********************************************************************** 43630000
         TM    PROGFLOW+1,QUEUELIN     * Should we stack the output ?   43640000
         BO    OUTPUTST                * Yes, set it up for queueing    43650000
         SPACE ,                                                        43660000
         LA    R1,HEADER               * Point R1 to the header record  43670000
         CR    R1,R4                   * Is this the header record?     43680000
         BNE   OUTPUTLI                * No, go write a line out        43690000
         SPACE ,                                                        43700000
         LINEWRT DATA=((R4),(R3)),COLOR=YELLOW,HILITE=HIGH,            *43710000
               PROTECT=YES             * Write the output to console    43720000
         BR    R9                      * Return to caller               43730000
OUTPUTLI EQU   *                                                        43740000
         LINEWRT DATA=((R4),(R3)),COLOR=TURQUOISE,HILITE=NOHIGH,       *43750000
               PROTECT=YES             * Write the output to console    43760000
         BR    R9                      * Return to caller               43770000
         SPACE ,                                                        43780000
OUTPUTST EQU   *                                                        43790000
         LR    R15,R4                  * Point R15 to the output buffer 43800000
         LR    R2,R3                   * Put the length into R2         43810000
*********************************************************************** 43820000
***                                                                 *** 43830000
***  This subroutine will place the output pointed to by R15 into   *** 43840000
***  the CMS stack, then it will return to caller by branching to   *** 43850000
***  the contents of R9.                                            *** 43860000
***                                                                 *** 43870000
*********************************************************************** 43880000
QUEUEIT  EQU   *                                                        43890000
         CMSSTACK TEXT=((R15),(R2)),ERROR=*,MF=(E,APPLPLST)             43900000
         BR    R9                      * Return to caller               43910000
         EJECT ,                                                        43920000
*********************************************************************** 43930000
***                                                                 *** 43940000
***  This subroutine will write an output message pointed to by     *** 43950000
***  R15 and return to caller by branching to the location in R9.   *** 43960000
***  There are no parameters for substitution.                      *** 43970000
***                                                                 *** 43980000
*********************************************************************** 43990000
WRITEMSG EQU   *                                                        44000000
         APPLMSG TEXTA=((R15)),DISP=ERRMSG,APPLID=DMS,MF=(E,APPLPLST)   44010000
         BR    R9                      * Return to caller               44020000
         SPACE 2                                                        44030000
*********************************************************************** 44040000
***                                                                 *** 44050000
***  This subroutine will write the output message pointed to by    *** 44060000
***  R15 and return to caller by branching to the location in R9.   *** 44070000
***  An item to be substituted is pointed by R3.                    *** 44080000
***                                                                 *** 44090000
*********************************************************************** 44100000
WRITEMS2 EQU   *                                                        44110000
         LA    R4,8(,R3)               * Point R4 to the filetype       44120000
         APPLMSG TEXTA=((R15)),DISP=ERRMSG,APPLID=DMS,MF=(E,APPLPLST), *44130000
               SUB=(CHARA,((R3),8),CHARA,((R4),8)),COMP=YES             44140000
         BR    R9                      * Return to caller               44150000
         SPACE 2                                                        44160000
WRITEMS3 EQU   *                                                        44170000
         APPLMSG TEXTA=((R15)),DISP=ERRMSG,APPLID=DMS,MF=(E,APPLPLST), *44180000
               SUB=(CHARA,((R3),8)),COMP=YES                            44190000
         BR    R9                      * Return to caller               44200000
         SPACE 2                                                        44210000
WRITEMS4 EQU   *                                                        44220000
         APPLMSG TEXTA=((R15)),DISP=ERRMSG,APPLID=DMS,MF=(E,APPLPLST), *44230000
               SUB=(CHARA,((R3),(R4))),COMP=YES                         44240000
         BR    R9                      * Return to caller               44250000
         SPACE 2                                                        44260000
WRITEMS5 EQU   *                                                        44270000
         APPLMSG TEXTA=((R15)),DISP=ERRMSG,APPLID=DMS,MF=(E,APPLPLST), *44280000
               SUB=(CHARA,((R3),(R4)),DEC,(R5)),COMP=YES                44290000
         BR    R9                      * Return to caller               44300000
         SPACE 2                                                        44310000
ERR1284T EQU   *                                                        44320000
         DMSMSG NUM=1284,TYPCALL=BALR  * Issue message 1284T            44330000
         L      R15,NUCADIE            * Get address of DMSDIE          44340000
         BALR   R14,R15                * Go, terminate abnormally       44350000
         EJECT                                                          44360000
*********************************************************************** 44370000
***                                                                 *** 44380000
***  Constants and Symbolic Definitions                             *** 44390000
***                                                                 *** 44400000
*********************************************************************** 44410000
         SPACE ,                                                        44420000
*                                                                       44430000
*        Read-only Constants                                            44440000
*                                                                       44450000
         SPACE ,                                                        44460000
         DS    0D                                                       44470000
ONEMICRO DC    X'0000000000001000'     * Clock units in 1 microsecond   44480000
ONEMILLI DC    X'00000000003E8000'     * Clock units in 1 millisecond   44490000
ONESEC   DC    X'00000000F4240000'     * Clock units in 1 second        44500000
ONEMIN   DC    X'0000003938700000'     * Clock units in 1 minute        44510000
ONEHR    DC    X'00000D693A400000'     * Clock units in 1 hour          44520000
ONENOON  DC    X'0000A0EEBB000000'     * Clock units in 12 hours        44530000
ONEDAY   DC    X'000141DD76000000'     * Clock units in 1 day           44540000
TWODAYS  DC    X'000283BAEC000000'     * Clock units in 2 days          44550000
DAYS3    DC    X'0003C59862000000'     * Clock units in 3 days          44560000
DAYS6    DC    X'00078B30C4000000'     * Clock units in 6 days          44570000
DAYS7    DC    X'0008CD0E3A000000'     * Clock units in 7 days          44580000
ONEMON28 DC    X'00233438E8000000'     * Clock units in a 28-day month  44590000
ONEMON29 DC    X'002476165E000000'     * Clock units in a 29-day month  44600000
ONEMON30 DC    X'0025B7F3D4000000'     * Clock units in a 30-day month  44610000
ONEMON31 DC    X'0026F9D14A000000'     * Clock units in a 31-day month  44620000
ONEYR    DC    X'01CAE8C13E000000'     * Clock units in 1 year          44630000
ONELPYR  DC    X'01CC2A9EB4000000'     * Clock units in 1 leap year     44640000
FOURYRS  DC    X'072CE4E26E000000'     * Clock units in 4 yrs, inc leap 44650000
         SPACE 2                                                        44660000
FWD1     DC    F'1'                    * Fullword value of 1            44670000
FWD2     DC    F'2'                    * Fullword value of 2            44680000
FWD3     DC    F'3'                    * Fullword value of 3            44690000
FWD4     DC    F'4'                    * Fullword value of 4            44700000
FWD7     DC    F'7'                    * Fullword value of 7            44710000
FWD8     DC    F'8'                    * Fullword value of 8            44720000
FWD12    DC    F'12'                   * Fullword value of 12           44730000
FWD24    DC    F'24'                   * Fullword value of 24           44740000
FWD60    DC    F'60'                   * Minutes in each hour           44750000
FWD60MIL DC    F'60000000'             * Microseconds in each minute    44760000
FWD1MIL  DC    F'1000000'              * Microseconds in each second    44770000
FWD8MIL  DC    F'8000000'              * Microsecond conversion factor  44780000
FWD365   DC    F'365'                  * Num of days in non-leap year   44790000
FWDSECHR DC    F'3600'                 * Number of seconds in an hour   44800000
FWDAYSEC DC    A(60*60*24)             * Number of seconds in 1 day     44810000
FWDAYRS4 DC    A(365*4+1)              * Days within 4 years, inc. Leap 44820000
FWD16383 DC    F'16383'                * Max +nnn interval of execution 44830000
HWD1     DC    H'1'                    * Halfword value of 1            44840000
HWD4     DC    H'4'                    * Halfword value of 4            44850000
HWD5     DC    H'5'                    * Halfword value of 5            44860000
HWD6     DC    H'6'                    * Halfword value of 6            44870000
HWD7     EQU   FWD7+2,2                * Halfword value of 7            44880000
HWD8     EQU   FWD8+2,2                * Halfword value of 8            44890000
HWD9     DC    H'9'                    * Halfword value of 9            44900000
HWD10    DC    H'10'                   * Halfword value of 10           44910000
HWD12    EQU   FWD12+2,2               * Halfword value of 12           44920000
HWD29    DC    H'29'                   * Halfword value of 29           44930000
HWD31    DC    H'31'                   * Halfword value of 31           44940000
HWD93    DC    H'93'                   * Halfword value of 93           44950000
HWD100   DC    H'100'                  * Halfword value of 100          44960000
HWD16383 EQU   FWD16383+2,2            * Max +nnn interval of execution 44970000
HWD32767 DC    H'32767'                * Halfword value of 32767        44980000
BRANCH   BAL   R0,0                    * Branch instruction for EXECUTE 44990000
TRANSLT1 TRT   0(*-*,R3),DECTAB        * Execute TRT for EBCDIC D2B con 45000000
TRANSLT2 TRT   0(*-*,R3),BLANKTAB      * Execute TRT to look for blank  45010000
TRANSLT3 TRT   0(*-*,R3),NOBLNKTB      * Exec TRT to look for non-blank 45020000
MOV2PACK MVC   0(*-*,R3),0(R1)         * To copy zoned num to free stor 45030000
MOVEPARM MVC   0(*-*,R4),0(R3)         * Move the non-tokenized parm    45040000
MOVDATIM MVC   0(*-*,R5),0(R4)         * Move the date or time param    45050000
COMPARMS CLC   0(*-*,R6),0(R4)         * Compare the parms supplied     45060000
MOVECMD1 MVC   0(*-*,R1),0(R3)         * To copy the non-tokenized cmd  45070000
MOVECMD2 MVC   0(*-*,R1),8(R4)         * To copy the table keyword      45080000
MOVECMD3 MVC   7(*-*,R4),0(R1)         * To copy the text of msg/cmd    45090000
MOVBLNKS MVC   1(*-*,R5),0(R5)         * Propagate the blank character  45100000
NULL     DC    XL8'00'                 * Null pointer                   45110000
         SPACE 3                                                        45120000
CALENDAR DS    0H                      * Days in prior months,non-leaps 45130000
         DC    H'0'                    * January, no prior days         45140000
         DC    H'31'                   * February - count January's 31  45150000
         DC    H'59'                   * March, include February's 28   45160000
         DC    H'90'                   * April, include March's 31      45170000
         DC    H'120'                  * May, include April's 30 days   45180000
         DC    H'151'                  * June, include May's 31         45190000
         DC    H'181'                  * July, include June's 30        45200000
         DC    H'212'                  * August, include July's 31      45210000
         DC    H'243'                  * September, include August's 31 45220000
         DC    H'273'                  * October, incl September's 30   45230000
         DC    H'304'                  * Novermber, count October's 31  45240000
         DC    H'334'                  * December, count November's 30  45250000
         SPACE 3                                                        45260000
HWDWKDLN DC    AL2(WKDAYTLN)           * Length of each table entry     45270000
WKDAYTAB DC    CL10'MONDAY',X'5',X'1'  * Table of day names posit & len 45280000
WKDAYTLN EQU   *-WKDAYTAB              * Length of each table entry     45290000
         DC    CL10'TUESDAY',X'6',X'2'                                  45300000
         DC    CL10'WEDNESDAY',X'8',X'3'                                45310000
         DC    CL10'THURSDAY',X'7',X'4'                                 45320000
         DC    CL10'FRIDAY',X'5',X'5'                                   45330000
         DC    CL10'SATURDAY',X'7',X'6'                                 45340000
         DC    CL10'SUNDAY',X'5',X'7'                                   45350000
         SPACE 3                                                        45360000
MONTHTAB DC    AL1(00,31,28,31,30,31,30,31,31,30,31,30,31)              45370000
         SPACE ,                                                        45380000
DATETBL  DS    0H                                                       45390000
         DC    AL1(05,3),B'11111111',X'000001',S(DAILY),C'DAILY'        45400000
         DS    0H                                                       45410000
         DC    AL1(01,1),B'11111111',X'000001',S(DAILY),C'*'            45420000
         DS    0H                                                       45430000
         DC    AL1(03,3),B'11111111',X'000001',S(DAILY),C'ALL'          45440000
         DS    0H                                                       45450000
         DC    AL1(07,7),B'11111100',X'000002',S(WEEKDAY),C'MON-FRI'    45460000
         DS    0H                                                       45470000
         DC    AL1(03,3),B'11111100',X'000002',S(WEEKDAY),C'M-F'        45480000
         DS    0H                                                       45490000
         DC    AL1(07,5),B'11111100',X'000002',S(WEEKDAY),C'WEEKDAY'    45500000
         DS    0H                                                       45510000
         DC    AL1(07,7),B'10000011',X'000003',S(WEEKEND),C'SAT-SUN'    45520000
         DS    0H                                                       45530000
         DC    AL1(03,3),B'10000011',X'000003',S(WEEKEND),C'S-S'        45540000
         DS    0H                                                       45550000
         DC    AL1(07,5),B'10000011',X'000003',S(WEEKEND),C'WEEKEND'    45560000
         DS    0H                                                       45570000
         DC    AL1(06,5),B'11000000',X'000014',S($ADAY),C'WEEKLY'       45580000
         DS    0H                                                       45590000
         DC    AL1(07,3),B'11000000',X'000014',S($ADAY),C'+MONDAY'      45600000
         DS    0H                                                       45610000
         DC    AL1(08,3),B'10100000',X'000024',S($ADAY),C'+TUESDAY'     45620000
         DS    0H                                                       45630000
         DC    AL1(10,3),B'10010000',X'000034',S($ADAY),C'+WEDNESDAY'   45640000
         DS    0H                                                       45650000
         DC    AL1(09,3),B'10001000',X'000044',S($ADAY),C'+THURSDAY'    45660000
         DS    0H                                                       45670000
         DC    AL1(07,3),B'10000100',X'000054',S($ADAY),C'+FRIDAY'      45680000
         DS    0H                                                       45690000
         DC    AL1(09,3),B'10000010',X'000064',S($ADAY),C'+SATURDAY'    45700000
         DS    0H                                                       45710000
         DC    AL1(07,3),B'10000001',X'000074',S($ADAY),C'+SUNDAY'      45720000
         DS    0H                                                       45730000
         DC    AL1(07,5),B'10000000',X'400005',S(MONTHLY),C'MONTHLY'    45740000
         DS    0H                                                       45750000
         DC    AL1(03,3),B'10000000',X'400005',S(MONTHLY),C'=//'        45760000
         DS    0H                                                       45770000
         DC    AL1(06,4),B'10000000',X'800006',S(YEARLY),C'YEARLY'      45780000
         DS    0H                                                       45790000
         DC    AL1(05,5),B'10000000',X'800006',S(YEARLY),C'=/=/='       45800000
         DS    0H                                                       45810000
         DC    AL1(05,3),B'00000000',X'000007',S(TODAY),C'TODAY'        45820000
         DS    0H                                                       45830000
         DC    AL1(08,3),B'00000000',X'000008',S(TOMORROW),C'TOMORROW'  45840000
         DS    0H                                                       45850000
         DC    AL1(06,2),B'00000000',X'000019',S(ADAY),C'MONDAY'        45860000
         DS    0H                                                       45870000
         DC    AL1(07,2),B'00000000',X'000029',S(ADAY),C'TUESDAY'       45880000
         DS    0H                                                       45890000
         DC    AL1(09,2),B'00000000',X'000039',S(ADAY),C'WEDNESDAY'     45900000
         DS    0H                                                       45910000
         DC    AL1(08,2),B'00000000',X'000049',S(ADAY),C'THURSDAY'      45920000
         DS    0H                                                       45930000
         DC    AL1(06,2),B'00000000',X'000059',S(ADAY),C'FRIDAY'        45940000
         DS    0H                                                       45950000
         DC    AL1(08,2),B'00000000',X'000069',S(ADAY),C'SATURDAY'      45960000
         DS    0H                                                       45970000
         DC    AL1(06,2),B'00000000',X'000079',S(ADAY),C'SUNDAY'        45980000
         DS    0H                                                       45990000
         DC    AL1(04,4),B'00000000',X'000000',S(ATIME),C'NOON'         46000000
         DS    0H                                                       46010000
         DC    AL1(08,3),B'00000000',X'000000',S(ATIME),C'MIDNIGHT'     46020000
         DS    0H                                                       46030000
         DC    AL1(05,5),B'00000000',X'000000',S(ATIME),C'>NOON'        46040000
NOONCON  EQU   *-4,4                                                    46050000
         DS    0H                                                       46060000
         DC    AL1(09,4),B'00000000',X'000000',S(ATIME),C'>MIDNIGHT'    46070000
MIDNTCON EQU   *-8,8                                                    46080000
         DS    0H                                                       46090000
         DC    XL2'0000'               * End of date table              46100000
         SPACE 3                                                        46110000
DECTAB   DC    256X'FF'                * DECIMAL verification table     46120000
         ORG   DECTAB+X'F0'            * Make all bytes X'FF'           46130000
         DC    X'00000000000000000000' * Except for 0-9                 46140000
         ORG   ,                                                        46150000
         SPACE 1                                                        46160000
BLANKTAB DC    256X'00'                * BLANK verification table       46170000
         ORG   BLANKTAB+X'40'          * Make all bytes X'00'           46180000
         DC    X'FF'                   * Except for blank               46190000
         ORG   ,                                                        46200000
         SPACE 3                                                        46210000
NOBLNKTB DC    256X'FF'                * Non-blank verification table   46220000
         ORG   NOBLNKTB+X'40'          * Make all bytes X'FF'           46230000
         DC    X'00'                   * Except for blank               46240000
         ORG   ,                                                        46250000
         SPACE 3                                                        46260000
CHRZEROS DC    CL8'00000000'           * EBCDIC 8 bytes of zeros        46270000
ZEROTIME DC    CL8'00:00:00'           * Midnight time string value     46280000
ZEROTIM2 DC    CL8'00:00   '           * hh:mm at Midnight              46290000
ZERODATE DC    CL8'01/01/00'           * Starting date                  46300000
MARCH1ST DC    CL8'03/01/00'           * The first of march value       46310000
CENDATIM DC    CL8'12/31/99',CL8'23:59:59' Last sec of the this century 46320000
NUCXNAME DC    CL8'SCHEDULE'           * Module name                    46330000
TIMFNAME EQU   NUCXNAME,8              * Filename of the event schedule 46340000
TIMFTYPE DC    CL8'TIMES'              * Filetype of the event schedule 46350000
TIMFM    DC    CL2'A1'                 * Filemode of the event schedule 46360000
TIMFILE  EQU   *-TIMFNAME              * Len of the FN,FT,FM & fillers  46370000
         SPACE ,                                                        46380000
FENCE    DC    8X'FF'                  * CMS Parameter fence            46390000
AMCONST  DC    CL2'AM'                 * "AM"        constant           46400000
PMCONST  DC    CL2'PM'                 * "PM"        constant           46410000
UNTILCON DC    CL6'UNTIL '             * "UNTIL "    constant           46420000
CMSCONST DC    CL4'CMS '               * "CMS "      constant           46430000
MSGCONST DC    CL4'MSG '               * "MSG "      constant           46440000
CPCONST  DC    CL3'CP '                * "CP "       constant           46450000
QUECONST DC    CL6'QUEUE '             * "QUEUE "    constant           46460000
VERCONST DC    CL8'VERSION '           * "VERSION "  constant           46470000
STACONST DC    CL7'STATUS '            * "STATUS "   constant           46480000
ACTCONST DC    CL8'activat '           * "activat "  constant           46490000
SUSCONST DC    CL8'suspend '           * "suspend "  constant           46500000
RESCONST DC    CL8'resum '             * "resum "    constant           46510000
ALLCONST DC    CL4'ALL '               * "ALL "      constant           46520000
OFFCONST DC    CL4'OFF '               * "OFF "      constant           46530000
ONCONST  DC    CL3'ON '                * "ON "       constant           46540000
QUIETCON DC    CL6'QUIET '             * "QUIET "    constant           46550000
HEADER   DC    C' Event SchedDate  SchedTime    NextDate NextTime TillD*46560000
               ate TillTime Cmd Text...'                                46570000
DOTS     DC    CL7' ..... '            * Show that a msg/cmd follows    46580000
NOCHAIN  DC    C'Schedule list is empty'                                46590000
BLANKS   DC    CL12'          '        * 12 bytes of blanks             46600000
         DS    0D                                                       46610000
HELPSCH  DC    CL8'HELP',CL8'CMS',CL8'SCHEDULE',8X'FF'                  46620000
CENTRY21 DC    X'B361183F48000000'     * Start of the 21st century      46630000
         SPACE 3                                                        46640000
*********************************************************************** 46650000
***                                                                 *** 46660000
***  The following are the global writable variables and flags.     *** 46670000
***                                                                 *** 46680000
*********************************************************************** 46690000
CENTURY  DS    D                       * Start of the century clock     46700000
ZONEOFST DS    D                       * Timezone offset clock units    46710000
OCLKCOMP DS    D                       * Clock comparator old contents  46720000
SCLKCOMP DS    D                       * Clock comparator at suspend    46730000
BASE7    DS    F                       * Base register 7 save area      46740000
BASE1012 DS    3F                      * Base registers10 through 12    46750000
ASCHEDUL DC    A(*-*)                  * Address of scheduling routine  46760000
TIMEZONE DC    F'0'                    * Timezone value (0 to 23) hours 46770000
EXTHNDLR DC    F'0'                    * External interrupt handler adr 46780000
ANCEVENT DC    F'0'                    * Pointer to the list of events  46790000
LSTEVENT DC    F'0'                    * Ptr to the last event scheduld 46800000
IDENTNUM DC    H'1'                    * 'Next event' number            46810000
TOTEVNTS DC    H'0'                    * Total num of events in queue   46820000
         SPACE ,                                                        46830000
PROGLOBL DC    X'00'                   * Global control byte            46840000
NOFILEOP EQU   X'80'                   * NOFILE  option requested       46850000
SUSPNDOP EQU   X'40'                   * Program suspended bit          46860000
INSLIHOP EQU   X'20'                   * Processing is in SLIH          46870000
         SPACE ,                                                        46880000
*********************************************************************** 46890000
***                                                                 *** 46900000
***  The following are the lists used by various macros.            *** 46910000
***                                                                 *** 46920000
*********************************************************************** 46930000
         SPACE ,                                                        46940000
APPLPLST APPLMSG MF=L,MAXSUBS=3        * Set up APPLMSG substitut. list 46950000
HNDPLST1 HNDEXT  SET,MF=L              * Set up HNDEXT  substitut. list 46960000
HNDPLST2 HNDEXT  CLR,MF=L              * Set up HNDEXT  substitut. list 46970000
         SPACE 3                                                        46980000
*********************************************************************** 46990000
***                                                                 *** 47000000
***  Literal Pool                                                   *** 47010000
***                                                                 *** 47020000
*********************************************************************** 47030000
         SPACE 1                                                        47040000
         LTORG ,                                                        47050000
*********************************************************************** 47060000
***                                                                 *** 47070000
***  The end of literal pool should be within the first 3 pages of  *** 47080000
***  SCHEDULE routine. All error messages should start on the  4th  *** 47090000
***  page boundary.                                                 *** 47100000
***                                                                 *** 47110000
*********************************************************************** 47120000
         ORG   SCHEDULE+4096*4         * Force a new page boundary(5th) 47130000
         EJECT                                                          47140000
*********************************************************************** 47150000
***                                                                 *** 47160000
***  Error messages                                                 *** 47170000
***                                                                 *** 47180000
*********************************************************************** 47190000
         SPACE ,                                                        47200000
ERRSC01  DC    AL1(ERRSC01L),C'DMSSCH001I Nucleus extension SCHEDULE dr*47210000
               opped'                  * Message to write out           47220000
ERRSC01L EQU   *-ERRSC01-1             * Length of the above message    47230000
         SPACE ,                                                        47240000
ERRSC02  DC    AL1(ERRSC02L),C'DMSSCH002E Invalid call made to SCHEDULE*47250000
                routine'                                                47260000
ERRSC02L EQU   *-ERRSC02-1             * Length of the above message    47270000
         SPACE ,                                                        47280000
ERRSC03  DC    AL1(ERRSC03L),C'DMSSCH003E Parameter "&&1" is invalid fo*47290000
               r SCHEDULE routine'                                      47300000
ERRSC03L EQU   *-ERRSC03-1             * Length of the above message    47310000
         SPACE ,                                                        47320000
ERRSC$3  DC    AL1(ERRSC$3L),C'DMSSCH003E Parameter is missing. Use "SC*47330000
               HEDULE HELP" for the command syntax'                     47340000
ERRSC$3L EQU   *-ERRSC$3-1             * Length of the above message    47350000
         SPACE ,                                                        47360000
ERRSC04  DC    AL1(ERRSC04L),C'DMSSCH004E Insufficient storage availabl*47370000
               e to load SCHEDULE as a Nucleus Extension'               47380000
ERRSC04L EQU   *-ERRSC04-1             * Length of the above message    47390000
         SPACE ,                                                        47400000
ERRSC05  DC    AL1(ERRSC05L),C'DMSSCH005E Unable to load SCHEDULE as a *47410000
               Nucleus Extension'                                       47420000
ERRSC05L EQU   *-ERRSC05-1             * Length of the above message    47430000
         SPACE ,                                                        47440000
ERRSC06  DC    AL1(ERRSC06L),C'DMSSCH006E SCHEDULE interrupt handling r*47450000
               outine is already in place'                              47460000
ERRSC06L EQU   *-ERRSC06-1             * Length of the above message    47470000
         SPACE ,                                                        47480000
ERRSC07  DC    AL1(ERRSC07L),C'DMSSCH007I SCHEDULE interrupt handler cr*47490000
               eated'                                                   47500000
ERRSC07L EQU   *-ERRSC07-1             * Length of the above message    47510000
         SPACE ,                                                        47520000
ERRSC08  DC    AL1(ERRSC08L),C'DMSSCH008E HNDEXT SET failed for SCHEDUL*47530000
               E. Command terminated'                                   47540000
ERRSC08L EQU   *-ERRSC08-1             * Length of the above message    47550000
         SPACE ,                                                        47560000
ERRSC09  DC    AL1(ERRSC09L),C'DMSSCH009E SCHEDULE interrupt handler ca*47570000
               not be removed, since it was not set'                    47580000
ERRSC09L EQU   *-ERRSC09-1             * Length of the above message    47590000
         SPACE ,                                                        47600000
ERRSC10  DC    AL1(ERRSC10L),C'DMSSCH010I SCHEDULE interrupt handler re*47610000
               moved'                                                   47620000
ERRSC10L EQU   *-ERRSC10-1             * Length of the above message    47630000
         SPACE ,                                                        47640000
ERRSC11  DC    AL1(ERRSC11L),C'DMSSCH011E SCHEDULE interrupt handler do*47650000
               esn''t exist. Issue "SCHEDULE ON" first'                 47660000
ERRSC11L EQU   *-ERRSC11-1             * Length of the above message    47670000
         SPACE ,                                                        47680000
ERRSC12  DC    AL1(ERRSC12L),C'DMSSCH012E File "SCHEDULE TIMES A" needs*47690000
                a writable A-disk accessed'                             47700000
ERRSC12L EQU   *-ERRSC12-1             * Length of the above message    47710000
         SPACE ,                                                        47720000
ERRSC13  DC    AL1(ERRSC13L),C'DMSSCH013E SCHEDULE cannot be run withou*47730000
               t an EPLIST. Command rejected'                           47740000
ERRSC13L EQU   *-ERRSC13-1             * Length of the above message    47750000
         SPACE ,                                                        47760000
ERRSC14  DC    AL1(ERRSC14L),C'DMSSCH014E Parameter "&&1" is either inv*47770000
               alid or out of sequence'                                 47780000
ERRSC14L EQU   *-ERRSC14-1             * Length of the above message    47790000
         SPACE ,                                                        47800000
ERRSC15  DC    AL1(ERRSC15L),C'DMSSCH015E Missing parameter for SCHEDUL*47810000
               E routine'                                               47820000
ERRSC15L EQU   *-ERRSC15-1             * Length of the above message    47830000
         SPACE ,                                                        47840000
ERRSC16  DC    AL1(ERRSC16L),C'DMSSCH016E SCHEDULE requires a message o*47850000
               r a CP/CMS command text to be present'                   47860000
ERRSC16L EQU   *-ERRSC16-1             * Length of the above message    47870000
         SPACE ,                                                        47880000
ERRSC17  DC    AL1(ERRSC17L),C'DMSSCH012E Cannot write the output file *47890000
               to your A-disk. See FSWRITE MACRO return codes'          47900000
ERRSC17L EQU   *-ERRSC17-1             * Length of the above message    47910000
         SPACE ,                                                        47920000
ERRSC18  DC    AL1(ERRSC18L),C'DMSSCH018E Invalid value "&&1" encounter*47930000
               ed in file "SCHEDULE TIMES", record &&2. Program termina*47940000
               ted'                                                     47950000
ERRSC18L EQU   *-ERRSC18-1             * Length of the above message    47960000
         SPACE ,                                                        47970000
ERRSC19  DC    AL1(ERRSC19L),C'DMSSCH019E Cannot read "SCHEDULE TIMES" *47980000
               from your A-disk. See FSREAD MACRO return codes'         47990000
ERRSC19L EQU   *-ERRSC19-1             * Length of the above message    48000000
         SPACE ,                                                        48010000
ERRSC20  DC    AL1(ERRSC20L),C'DMSSCH020E Item "&&1" cannot be located;*48020000
                it is either invalid or does not exist'                 48030000
ERRSC20L EQU   *-ERRSC20-1             * Length of the above message    48040000
         SPACE ,                                                        48050000
ERRSC21  DC    AL1(ERRSC21L),C'DMSSCH021E An extraneous parameter "&&1"*48060000
                supplied on SCHEDULE command'                           48070000
ERRSC21L EQU   *-ERRSC21-1             * Length of the above message    48080000
         SPACE ,                                                        48090000
ERRSC22  DC    AL1(ERRSC22L),C'DMSSCH022I SCHEDULE processing &&1ed'    48100000
ERRSC22L EQU   *-ERRSC22-1             * Length of the above message    48110000
         SPACE ,                                                        48120000
ERRSC23  DC    AL1(ERRSC23L),C'DMSSCH023I SCHEDULE Interrupt handler is*48130000
                in place. Processing is &&1ed'                          48140000
ERRSC23L EQU   *-ERRSC23-1             * Length of the above message    48150000
         SPACE ,                                                        48160000
ERRSC24  DC    AL1(ERRSC24L),C'DMSSCH024E Query parameter "&&1" in inva*48170000
               lid.'                                                    48180000
ERRSC24L EQU   *-ERRSC24-1             * Length of the above message    48190000
         SPACE ,                                                        48200000
ERRSC25  DC    AL1(ERRSC25L),C'DMSSCH025E An unsolicited Clock Comparat*48210000
               or interrupt was received and ignored'                   48220000
ERRSC25L EQU   *-ERRSC25-1             * Length of the above message    48230000
         SPACE ,                                                        48240000
ERRSC26  DC    AL1(ERRSC26L),C'DMSSCH026E Cannot suspend SCHEDULE proce*48250000
               ssing, since it is already suspended'                    48260000
ERRSC26L EQU   *-ERRSC26-1             * Length of the above message    48270000
         SPACE ,                                                        48280000
ERRSC27  DC    AL1(ERRSC27L),C'DMSSCH027E Cannot resume SCHEDULE proces*48290000
               sing, since it is not suspended'                         48300000
ERRSC27L EQU   *-ERRSC27-1             * Length of the above message    48310000
         SPACE ,                                                        48320000
*********************************************************************** 48330000
***                                                                 *** 48340000
***  Symbolic Value Definitions                                     *** 48350000
***                                                                 *** 48360000
*********************************************************************** 48370000
         SPACE ,                                                        48380000
TOKENLEN EQU   8                                                        48390000
EPLSERVC EQU   X'FF'                   * CMS Service Call               48400000
BLANK    EQU   C' '                    * 1 byte of blank                48410000
RC104    EQU   104                     * Return code 104                48420000
DD       EQU   3                       * Offset to DD val  in MM/DD/YY  48430000
YY       EQU   6                       * Offset to YY val  in MM/DD/YY  48440000
MM       EQU   3                       * Offset to minutes in HH:MM:SS  48450000
SS       EQU   6                       * Offset to seconds in HH:MM:SS  48460000
         SPACE ,                                                        48470000
*                                      * Bits in WRKFLOW control flag   48480000
*                                      * Prevent tracing DIAG 8 NOSIM   48490000
         SPACE 3                                                        48500000
MODLEN   EQU   (*-SCHEDULE)            * Size of SCHEDULE in bytes      48510000
MODSIZE  EQU   (*-SCHEDULE+7)/8        * Size of SCHEDULE in dwords     48520000
         EJECT                                                          48530000
*********************************************************************** 48540000
***                                                                 *** 48550000
***  Work area used by SCHEDULE                                     *** 48560000
***                                                                 *** 48570000
*********************************************************************** 48580000
         SPACE ,                                                        48590000
WRKAREA  DSECT                                                          48600000
OLDR13   DS    F                       * Addr passed to SCHEDULE in R13 48610000
SCHEDSAV DS    16F                     * Scheduling routine save area   48620000
         SPACE ,                                                        48630000
NUCXADDR DS    A                       * Entry point address            48640000
NUCXUSER DS    A                       * User word                      48650000
NUCXORG  DS    A                       * Load address                   48660000
NUCXLEN  DS    A                       * Size in bytes                  48670000
EVENTSAV DS    10F                     * Temp save area for EVENT sched 48680000
SETEVSAV DS    10F                     * Temp save area for SETEVENT    48690000
TIMERSAV DS    10F                     * Temp save area for convsn subr 48700000
CVTSAVER DS    10F                     * Temp save for various rotuines 48710000
CVTSAVR2 DS    10F                     * Temp save for various rotuines 48720000
VALSAVER DS    10F                     * Temp save 4 val. date/time sub 48730000
MIDNTCLK DS    2F                      * Midnight time value            48740000
RETCODE  DS    F                       * Return code saved              48750000
SCBLOKSV DS    F                       * Saved SCBLOCK pointer          48760000
BRANCHIN DS    F                       * Area to hold a branch instruct 48770000
CONTROL0 DS    F                       * Control Register 0 save        48780000
         SPACE ,                                                        48790000
RECORDLN DS    H                       * Length of the record           48800000
MESSAGLN DS    H                       * Length of the message/command  48810000
TEMPLEN  DS    H                       * Temp length of the record      48820000
TSTINTVL DS    H                       * Temp +nnn interval save place  48830000
         SPACE ,                                                        48840000
         DS    0D                                                       48850000
CALCTIME DS    D                       * Calculated current time value  48860000
TESTTIME DS    D                       * Temp TOD clock value           48870000
TESTTIM2 DS    D                       * Temp TOD clock value           48880000
TODVALUE DS    D                       * Current clock value            48890000
TODTODAY DS    D                       * TOD value at midnight, today   48900000
MINCLOCK DS    D                       * Smallest TOD value             48910000
DATETIME DS    CL32                    * Buffer for DIAG X'0C' output   48920000
         SPACE ,                                                        48930000
DATEVAL  DS    CL8                     * Temp area for conversion calls 48940000
TIMEVAL  DS    CL8                     * Temp area for conversion calls 48950000
DATEVAL1 DS    CL8                     * Temp area for conversion calls 48960000
TIMEVAL1 DS    CL8                     * Temp area for conversion calls 48970000
DATEVAL2 DS    CL8                     * Temp area for conversion calls 48980000
TIMEVAL2 DS    CL8                     * Temp area for conversion calls 48990000
DATEVAL3 DS    CL8                     * Temp area for conversion calls 49000000
TIMEVAL3 DS    CL8                     * Temp area for conversion calls 49010000
         SPACE ,                                                        49020000
DAYOFWK  DS    CL10                    * Name of the day of week        49030000
DAYOFWKL DS    X                       * Length-1 of the day of week    49040000
DAYOFWKN DS    X                       * Number of the day of week      49050000
DAYOFWKS DS    X                       * Holding area for DAYOFWKN      49060000
         SPACE ,                                                        49070000
PROGFLOW DS    XL3                     * Control byte                   49080000
DATEINC  EQU   X'80'              X*1  * Date  parameter supplied       49090000
TIMEINC  EQU   X'40'                   * Time  parameter supplied       49100000
UNTLKINC EQU   X'20'                   * UNTIL option    supplied       49110000
UNTLPINC EQU   X'10'                   * UNTIL date parameter supplied  49120000
FORCEGMT EQU   X'08'                   * Force timer calc to G.M.T time 49130000
FUNCKINC EQU   X'04'                   * Function keyword included      49140000
FUNCPINC EQU   X'02'                   * Function parameter supplied    49150000
CMDINPUT EQU   X'01'                   * ADD request came from cmdline  49160000
         SPACE ,                                                        49170000
TMPLSINC EQU   X'80'              X*2  * '+' included on time specific  49180000
DTPLSINC EQU   X'40'                   * '+' included on date specific  49190000
IMMEDINC EQU   X'20'                   * '>' Immed exceution required   49200000
UNTLQINC EQU   X'10'                   * UNTIL time parameter supplied  49210000
QUEUELIN EQU   X'08'                   * Output from QUERY to be queued 49220000
QUERYONE EQU   X'04'                   * Only 1 output item to be given 49230000
QUIETOP  EQU   X'02'                   * QUIET   option requested       49240000
         SPACE ,                                                        49250000
* NOFILEOP =   X'80'              X*3  * NOFILE  used also in PROGLOBL  49260000
         SPACE ,                                                        49270000
DOUBLEWD DS    D                       * Bin to dec conv. work area     49280000
         DS    X                       * Just a dummy byte for pack     49290000
         SPACE ,                                                        49300000
PARMTEMP DS    CL12                    * Temp. parameter holding place  49310000
FILEID   DS    CL20                    * Output fileid for terminal MSG 49320000
DDOFFSET DS    CL2                     * Field to hold temp day offset  49330000
         SPACE ,                                                        49340000
         DS    0D                                                       49350000
INPUTDS  FSCB  'filename filetype fm',FORM=E                            49360000
OUTPUTDS FSCB  'filename filetype fm',FORM=E                            49370000
         SPACE 2                                                        49380000
*********************************************************************** 49390000
***                                                                 *** 49400000
***  Area for reading and writing to SCHEDULE TIMES A1 file.        *** 49410000
***                                                                 *** 49420000
*********************************************************************** 49430000
         SPACE ,                                                        49440000
RECCURNT DS    CL1                     * This is the scheduled event    49450000
RECEVTID DS    CL05                    * Event identifier               49460000
*                                      * Above will be used for "QUERY" 49470000
         SPACE ,                                                        49480000
RECRDMAP DS    0C                                                       49490000
RECDONE  DS    CL1                     * Inactive requests = "*"        49500000
RECDATE  DS    CL10'+Wednesday'        * M-F, WEEKDAY, WEEKEND, & etc   49510000
         DS    CL1                                                      49520000
RECTIME  DS    CL12'>+hh:mm:ssAM'      * Time to be scheduled /MIDNIGHT 49530000
         DS    CL1                                                      49540000
RECLDATE DS    CL08'mm/dd/yy'          * Last event scheduled date      49550000
QRYNDATE EQU   RECLDATE,8              * Next event scheduled date      49560000
         DS    CL1                                                      49570000
RECLTIME DS    CL08'hh:mm:ss'          * Last event scheduled time      49580000
QRYNTIME EQU   RECLTIME,8              * Next event scheduled time      49590000
         DS    CL1                                                      49600000
RECUNTID DS    CL08'mm/dd/yy'          * Until clause date              49610000
         DS    CL1                                                      49620000
RECUNTIT DS    CL08'hh:mm:ss'          * Until clause time              49630000
         DS    CL1                                                      49640000
RECFUNC  DS    CL03'msg'               * Type of event (MSG/CMS/CP) cmd 49650000
         DS    CL1                                                      49660000
RECOPERL EQU   *-RECRDMAP              * Length of the operation fields 49670000
QUERYLS  EQU   *-RECCURNT              * Len of area for date/time QUER 49680000
RECDATA  DS    CL240                   * Maximum command/message length 49690000
RECMAPLN EQU   *-RECRDMAP              * Maximum length of output recrd 49700000
QUERYLL  EQU   *-RECCURNT              * Len of area used by QUERY func 49710000
         SPACE 3                                                        49720000
         DS    0D                      * Align on doubleword boundary   49730000
EVNTBUFF DS    CL(EVNTFIXL+L'EVNTDATA) * Max. schedulued event length   49740000
         SPACE ,                                                        49750000
WRKARLEN EQU   (*+7-WRKAREA)/8                                          49760000
         EJECT ,                                                        49770000
*********************************************************************** 49780000
***                                                                 *** 49790000
***  Each scheduled event has the format described below. For each  *** 49800000
***  timer event a piece of FREE storage is obtained from the sub-  *** 49810000
***  pool 'NUCLEUS'.  It is then filled and chained together  with  *** 49820000
***  the previous event. The last  event on the list will be anch-  *** 49830000
***  ored at 'ANCEVENT'.                                            *** 49840000
***                                                                 *** 49850000
*********************************************************************** 49860000
         SPACE ,                                                        49870000
EVENT    DSECT ,                                                        49880000
EVNTPREV DS    F                       * Pointer to the previous event  49890000
EVNTIDEN DS    H                       * Event identification number    49900000
EVNTELEN DS    H                       * Length of this free stor area  49910000
EVNTCLCK DS    D                       * Scheduled timer pop            49920000
EVNTINTD DS    D                       * Day-orientd intrvl for repetit 49930000
EVNTINTT DS    D                       * Tim-orientd intrvl for repetit 49940000
EVNTTILL DS    D                       * Scheduled end time for intervl 49950000
EVNTLAST DS    D                       * Last scheduled timer value     49960000
EVNTIMTD DS    D                       * Scheduled day pop (preserved)  49970000
         SPACE ,                                                        49980000
EVNTOFFS DS    CL2                     * Day offset for an event ==/DD  49990000
EVNTFLG1 DS    X                   X*1 * Flags relating to this event   50000000
EVNTSCH  EQU   X'80'                   * Event scheduled                50010000
EVNTADDD EQU   X'40'                   * Event is in the form of ==/DD  50020000
EVNTLIM  EQU   X'20'                   * Event limited by UNTIL clause  50030000
EVNTIMM  EQU   X'10'                   * Event to be run immediately    50040000
EVNTMSG  EQU   X'08'                   * Event is to display text       50050000
EVNTCMS  EQU   X'04'                   * Event is to issue a CMS comnd  50060000
EVNTCP   EQU   X'02'                   * Event is to issue a CP command 50070000
EVNTFIN  EQU   X'01'                   * Event finished earlier, reschd 50080000
         SPACE ,                                                        50090000
EVNTFLG2 DS    X                   X*2 * Reserved for future use        50100000
EVNTREPT EQU   X'80'                   * Event is time-repetitive       50110000
EVNTIMM2 EQU   X'40'                   * The immediate functn processed 50120000
EVNTIMM3 EQU   X'20'                   * This is/was an immediate func  50130000
         SPACE ,                                                        50140000
EVNTWEEK DS    X                   X*3 * Bit map for each weekday sched 50150000
EVNTREPD EQU   X'80'                   * Event is day-repetitive        50160000
EVNTMON  EQU   X'40'                   * Event to be run each Monday    50170000
EVNTTUE  EQU   X'20'                   * Event to be run each Tuesday   50180000
EVNTWED  EQU   X'10'                   * Event to be run each Wednesday 50190000
EVNTTHU  EQU   X'08'                   * Event to be run each Thursday  50200000
EVNTFRI  EQU   X'04'                   * Event to be run each Friday    50210000
EVNTSAT  EQU   X'02'                   * Event to be run each Saturday  50220000
EVNTSUN  EQU   X'01'                   * Event to be run each Sunday    50230000
         SPACE ,                                                        50240000
EVNTFLG3 DS    X                   X*4 * 1st 2 bits of EVNTFLG3 follow: 50250000
EVNTYRLY EQU   X'80'                   * Event to be run yearly         50260000
EVNTMTLY EQU   X'40'                   * Event to be run monthly        50270000
EVNTFLG4 DS    X                   X*5 * Event to run +nn days 00-16383 50280000
         SPACE ,                                                        50290000
EVNTFLG5 DS    X                   X*6 * Index number of the function   50300000
EVNTFIXL EQU   *-EVENT                 * Length of fixed EVENT portion  50310000
EVNTDATA DS    0CL240                  * Command or MSG to be issued    50320000
         EJECT                                                          50330000
*********************************************************************** 50340000
***                                                                 *** 50350000
***  Parameter list DSECT.  Assigns a variable name to each         *** 50360000
***  token in the parameter list.                                   *** 50370000
***                                                                 *** 50380000
*********************************************************************** 50390000
         SPACE ,                                                        50400000
TOKENS   DSECT ,                       * CMS Tokenized parameter list   50410000
TOKEN0   DS    CL8                     * Command token                  50420000
TOKEN1   DS    CL8                     * Parameter 1                    50430000
TOKEN2   DS    CL8                     * Parameter 2                    50440000
TOKEN3   DS    CL8                     * Parameter 3                    50450000
TOKEN4   DS    CL8                     * Parameter 4                    50460000
TOKEN5   DS    CL8                     * Parameter 5                    50470000
         EJECT                                                          50480000
         DMSSCRCB ,                    * Session manager control block  50490000
         EJECT                                                          50500000
         EPLIST ,                      * Extended Parameter List        50510000
         EJECT                                                          50520000
         EQUATES ,                     * CMS Equates Symbols            50530000
         EJECT                                                          50540000
         IO ,                          * I/O Operation lists            50550000
         EJECT                                                          50560000
         IOSECT ,                      * Input/Output Section           50570000
         EJECT                                                          50580000
         DEVTAB ,                      * Device table mapping           50590000
         EJECT                                                          50600000
         NUCON ,                       * CMS Nucleus Constants area     50610000
         EJECT                                                          50620000
         REGEQU ,                      * Register Equates               50630000
         EJECT                                                          50640000
         SCBLOCK ,                     * Subcommand Control Block       50650000
         EJECT                                                          50660000
         FSCBD ,                       * Mapping for the FSCB           50670000
         EJECT                                                          50680000
         FSTD ,                        * File Status Table DSECT        50690000
         EJECT                                                          50700000
         USERSAVE ,                    * Map of the user save area      50710000
         DROP  R12,R11,R10,R7          * Drop all the bases             50720000
SCHEDULE CSECT                                                          50730000
         END                                                            50740000
